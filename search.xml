<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【2022寒假萌新训练-3】7-7 点赞狂魔</title>
      <link href="/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-7%20%E7%82%B9%E8%B5%9E%E7%8B%82%E9%AD%94/"/>
      <url>/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-7%20%E7%82%B9%E8%B5%9E%E7%8B%82%E9%AD%94/</url>
      
        <content type="html"><![CDATA[<p>微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。然而有这么一种人，他们会通过给自己看到的一切内容点赞来狂刷存在感，这种人就被称为“点赞狂魔”。他们点赞的标签非常分散，无法体现出明显的特性。本题就要求你写个程序，通过统计每个人点赞的不同标签的数量，找出前3名点赞狂魔。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤100），是待统计的用户数。随后<em>N</em>行，每行列出一位用户的点赞标签。格式为“<code>Name</code> <em>K</em> <em>F</em><del>1</del>⋯<em>F</em><del>K</del><em>”，其中<code>Name</code>是不超过8个英文小写字母的非空用户名，1≤</em>K<em>≤1000，</em>F*<del>i</del><em>（</em>i*=1,⋯,<em>K</em>）是特性标签的编号，我们将所有特性标签从 1 到 10^7^ 编号。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>统计每个人点赞的不同标签的数量，找出数量最大的前3名，在一行中顺序输出他们的用户名,其间以1个空格分隔,且行末不得有多余空格。如果有并列，则输出标签出现次数平均值最小的那个，题目保证这样的用户没有并列。若不足3人，则用<code>-</code>补齐缺失，例如<code>mike jenny -</code>就表示只有2人。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">bob 11 101 102 103 104 105 106 107 108 108 107 107</span><br><span class="line">peter 8 1 2 3 4 3 2 5 1</span><br><span class="line">chris 12 1 2 3 4 5 6 7 8 9 1 2 3</span><br><span class="line">john 10 8 7 6 5 4 3 2 1 7 5</span><br><span class="line">jack 9 6 7 8 9 10 11 12 13 14</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jack chris john</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    根据题意，要名字，不同标签的数量以及标签出现次数平均值，存储的元素挺多，可以采用结构体。</p><ul><li>名字直接读取</li><li>不同标签的数量可以利用set不存储重复元素的特性得到</li><li>标签出现的平均次数可以等价于，如果存在并列，则他们不同标签的数量num一定是相同的，平均次数为k / num,此时谁的k值小，谁的平均次数就小,所以只需要比较k值就好</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="comment">//num为不同标签的数量，cnt记录总次数，其实就是k</span></span><br><span class="line">    <span class="keyword">int</span> num, cnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.num != b.num)</span><br><span class="line">        <span class="keyword">return</span> a.num &gt; b.num;</span><br><span class="line">    <span class="keyword">return</span> a.cnt &lt; b.cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    Node node[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; node[i].name;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="comment">//利用set不存储重复元素的特性得到不同标签的数量</span></span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            s.<span class="built_in">insert</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        node[i].num = s.<span class="built_in">size</span>();</span><br><span class="line">        node[i].cnt = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(node, node + n, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n) cout &lt;&lt; node[i].name;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2022寒假萌新程序设计训练 </category>
          
          <category> 2022寒假萌新训练-3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL,sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2022寒假萌新训练-3】7-6 树种统计</title>
      <link href="/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-6%20%E6%A0%91%E7%A7%8D%E7%BB%9F%E8%AE%A1/"/>
      <url>/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-6%20%E6%A0%91%E7%A7%8D%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>随着卫星成像技术的应用，自然资源研究机构可以识别每一棵树的种类。请编写程序帮助研究人员统计每种树的数量，计算每种树占总数的百分比。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入首先给出正整数N（≤10^5^），随后N行，每行给出卫星观测到的一棵树的种类名称。种类名称由不超过30个英文字母和空格组成（大小写不区分）。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按字典序递增输出各种树的种类名称及其所占总数的百分比，其间以空格分隔，保留小数点后4位。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">29</span><br><span class="line">Red Alder</span><br><span class="line">Ash</span><br><span class="line">Aspen</span><br><span class="line">Basswood</span><br><span class="line">Ash</span><br><span class="line">Beech</span><br><span class="line">Yellow Birch</span><br><span class="line">Ash</span><br><span class="line">Cherry</span><br><span class="line">Cottonwood</span><br><span class="line">Ash</span><br><span class="line">Cypress</span><br><span class="line">Red Elm</span><br><span class="line">Gum</span><br><span class="line">Hackberry</span><br><span class="line">White Oak</span><br><span class="line">Hickory</span><br><span class="line">Pecan</span><br><span class="line">Hard Maple</span><br><span class="line">White Oak</span><br><span class="line">Soft Maple</span><br><span class="line">Red Oak</span><br><span class="line">Red Oak</span><br><span class="line">White Oak</span><br><span class="line">Poplan</span><br><span class="line">Sassafras</span><br><span class="line">Sycamore</span><br><span class="line">Black Walnut</span><br><span class="line">Willow</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Ash 13.7931%</span><br><span class="line">Aspen 3.4483%</span><br><span class="line">Basswood 3.4483%</span><br><span class="line">Beech 3.4483%</span><br><span class="line">Black Walnut 3.4483%</span><br><span class="line">Cherry 3.4483%</span><br><span class="line">Cottonwood 3.4483%</span><br><span class="line">Cypress 3.4483%</span><br><span class="line">Gum 3.4483%</span><br><span class="line">Hackberry 3.4483%</span><br><span class="line">Hard Maple 3.4483%</span><br><span class="line">Hickory 3.4483%</span><br><span class="line">Pecan 3.4483%</span><br><span class="line">Poplan 3.4483%</span><br><span class="line">Red Alder 3.4483%</span><br><span class="line">Red Elm 3.4483%</span><br><span class="line">Red Oak 6.8966%</span><br><span class="line">Sassafras 3.4483%</span><br><span class="line">Soft Maple 3.4483%</span><br><span class="line">Sycamore 3.4483%</span><br><span class="line">White Oak 10.3448%</span><br><span class="line">Willow 3.4483%</span><br><span class="line">Yellow Birch 3.4483%</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    根据题意，统计树的种类和它的占比，采用map存储，根据map的自动排序，string直接是按照字典序进行排序，我们只需要遍历输出即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    map&lt;string, <span class="keyword">int</span>&gt; book;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="built_in">getline</span>(cin, str);</span><br><span class="line">        book[str]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = book.<span class="built_in">begin</span>(); it != book.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %.4f%%\n&quot;</span>, it -&gt; first.<span class="built_in">c_str</span>(), (<span class="keyword">float</span>)it -&gt; second / n * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2022寒假萌新程序设计训练 </category>
          
          <category> 2022寒假萌新训练-3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2022寒假萌新训练-3】7-5 点赞</title>
      <link href="/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-5%20%E7%82%B9%E8%B5%9E/"/>
      <url>/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-5%20%E7%82%B9%E8%B5%9E/</url>
      
        <content type="html"><![CDATA[<p>微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。本题就要求你写个程序，通过统计一个人点赞的纪录，分析这个人的特性。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤1000），是该用户点赞的博文数量。随后<em>N</em>行，每行给出一篇被其点赞的博文的特性描述，格式为“<em>K</em> <em>F</em><del>1</del>⋯<em>F</em><del>K</del><em>”，其中1≤</em>K<em>≤10，</em>F*<del>i</del>（<em>i</em>=1,⋯,*K）是特性标签的编号，我们将所有特性标签从1到1000编号。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>统计所有被点赞的博文中最常出现的那个特性标签，在一行中输出它的编号和出现次数，数字间隔1个空格。如果有并列，则输出编号最大的那个。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3 889 233 2</span><br><span class="line">5 100 3 233 2 73</span><br><span class="line">4 3 73 889 2</span><br><span class="line">2 233 123</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">233 3</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    和7-4 天梯赛的善良的一样，需要记录两个值，一个值为特征描述值，一个值为出现的次数，可以采用map存储。</p><p>​    最后输出出现次数最大的特征值中编号最大的，可以采用map反向遍历（从大的特征值开始遍历），max1记录特征值，max2记录出现的次数，只要找到比max2大的，就更新max1和max2，最后输出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k, t;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            m[t]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//max1记录特征值，max2记录出现的次数</span></span><br><span class="line">    <span class="keyword">int</span> max1 = <span class="number">0</span>, max2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m.<span class="built_in">rbegin</span>(); it != m.<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(it -&gt; second &gt; max2) &#123;</span><br><span class="line">            max1 = it -&gt; first;</span><br><span class="line">            max2 = it -&gt; second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; max1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; max2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2022寒假萌新程序设计训练 </category>
          
          <category> 2022寒假萌新训练-3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2022寒假萌新训练-3】7-4 天梯赛的善良</title>
      <link href="/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-4%20%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%9A%84%E5%96%84%E8%89%AF/"/>
      <url>/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-4%20%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%9A%84%E5%96%84%E8%89%AF/</url>
      
        <content type="html"><![CDATA[<p>天梯赛是个善良的比赛。善良的命题组希望将题目难度控制在一个范围内，使得每个参赛的学生都有能做出来的题目，并且最厉害的学生也要非常努力才有可能得到高分。</p><p>于是命题组首先将编程能力划分成了 10^6^ 个等级（太疯狂了，这是假的），然后调查了每个参赛学生的编程能力。现在请你写个程序找出所有参赛学生的最小和最大能力值，给命题组作为出题的参考。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出一个正整数 <em>N</em>（≤2×10^4^），即参赛学生的总数。随后一行给出 <em>N</em> 个不超过 10^6^ 的正整数，是参赛学生的能力值。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>第一行输出所有参赛学生的最小能力值，以及具有这个能力值的学生人数。第二行输出所有参赛学生的最大能力值，以及具有这个能力值的学生人数。同行数字间以 1 个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">86 75 233 888 666 75 886 888 75 666</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">75 3</span><br><span class="line">888 2</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    根据题意，要找出最小和最大能力值已经相应的人数，要记录的是能力值和人数，可以采用map存储，利用map的自动排序，map的第一个元素就是最小能力值和人数，最后一个元素就是最大能力值和人数。</p><p>​    rbegin()返回的是一个反向迭代器，指向的是map的最后一个元素。</p><p>​    不采用end()是因为end()返回的是map最后一个元素<strong>之后</strong>的地址。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        m[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">begin</span>() -&gt; first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m.<span class="built_in">begin</span>() -&gt; second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">rbegin</span>() -&gt; first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m.<span class="built_in">rbegin</span>() -&gt; second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2022寒假萌新程序设计训练 </category>
          
          <category> 2022寒假萌新训练-3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2022寒假萌新训练-3】7-3 素数对猜想</title>
      <link href="/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-3%20%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"/>
      <url>/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-3%20%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>让我们定义<em>d<del>n</del><em>为：</em>d<del>n</del></em>=<em>p<del>n+1</del><em>−</em>p<del>n</del><em>，其中</em>p<del>i</del><em>是第</em>i</em>个素数。显然有<em>d<del>1</del></em>=1，且对于n&gt;1有*d<del>n</del>*是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p><p>现给定任意正整数<code>N</code>(&lt;10^5^)，请计算不超过<code>N</code>的满足猜想的素数对的个数。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行给出正整数<code>N</code>。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出不超过<code>N</code>的满足猜想的素数对的个数。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    套用判断素数的模板，然后遍历从2~n，判断的是数字i和数字i + 2是否同时为素数即可，同时为素数则ans++</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsPrime</span>(i) &amp;&amp; <span class="built_in">IsPrime</span>(i + <span class="number">2</span>))</span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2022寒假萌新程序设计训练 </category>
          
          <category> 2022寒假萌新训练-3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 素数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2022寒假萌新训练-3】7-2 判断素数</title>
      <link href="/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-2%20%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0/"/>
      <url>/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-2%20%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>本题的目标很简单，就是判断一个给定的正整数是否素数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<code>N</code>（≤ 10），随后<code>N</code>行，每行给出一个小于231的需要判断的正整数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个需要判断的正整数，如果它是素数，则在一行中输出<code>Yes</code>，否则输出<code>No</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">11</span><br><span class="line">111</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    根据判断素数的模板直接套就可以,为了提高运行效率，为了防止i*i超出int范围，可以采用i &lt;= sqrt(n)。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsPrime</span>(t))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2022寒假萌新程序设计训练 </category>
          
          <category> 2022寒假萌新训练-3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 素数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【2022寒假萌新训练-3】7-1 最大公因数与最小公倍数</title>
      <link href="/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-1%20%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
      <url>/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-1%20%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>求两个正整数 <em>a</em>,<em>b</em> 的最大公因数与最小公倍数。</p><p>两个数的最大公因数指的是 <em>a</em>,<em>b</em> 共有的约数中最大的一个。</p><p>两个数的最小公倍数指的是 <em>a</em>,<em>b</em> 共有的倍数中最小的一个。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>在一行中给出两个数字 <em>a</em>,<em>b</em>  (1&lt;=<em>a</em>,<em>b</em>&lt;=1,000,000,000)</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中以空格分隔输出 <em>a</em>,<em>b</em> 的最大公因数与最小公倍数。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 9</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 18</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    根据欧几里德算法或者C++的函数库求出a和b的最大公因数.</p><p>​    最小公倍数则是a*b除以它们的最大公倍数,为了防止a * b计算时由于结果过大而溢出，所以可以先让a除以最大公倍数再乘b</p><p>​    欧几里德算法：设a,b均为正整数，a,b的最大公约数等于b,a%b的最大公约数即Gcd(a,b) = Gcd(b,a % b)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">Gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a % b == <span class="number">0</span> ? b : <span class="built_in">Gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, <span class="built_in">Gcd</span>(a, b), a / <span class="built_in">Gcd</span>(a, b) * b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a, b, gcd;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    gcd = __gcd(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, gcd, a / gcd * b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2022寒假萌新程序设计训练 </category>
          
          <category> 2022寒假萌新训练-3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欧几里德算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-9 完全二叉树的层序遍历 (25 分)</title>
      <link href="/2022/01/14/7-9%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20(25%20%E5%88%86)/"/>
      <url>/2022/01/14/7-9%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20(25%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是<strong>完美二叉树</strong>。对于深度为 <em>D</em> 的，有 <em>N</em> 个结点的二叉树，若其结点对应于相同深度完美二叉树的层序遍历的前 <em>N</em> 个结点，这样的树就是<strong>完全二叉树</strong>。</p><p>给定一棵完全二叉树的后序遍历，请你给出这棵树的层序遍历结果。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出正整数 <em>N</em>（≤30），即树中结点个数。第二行给出后序遍历序列，为 <em>N</em> 个不超过 100 的正整数。同一行中所有数字都以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出该树的层序遍历序列。所有数字都以 1 个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">91</span> <span class="number">71</span> <span class="number">2</span> <span class="number">34</span> <span class="number">10</span> <span class="number">15</span> <span class="number">55</span> <span class="number">18</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span> <span class="number">34</span> <span class="number">55</span> <span class="number">71</span> <span class="number">2</span> <span class="number">10</span> <span class="number">15</span> <span class="number">91</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    用数组存树，然后根据后序遍历类推出后序建树</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,tree[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">BuildTree</span>(pos * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">BuildTree</span>(pos * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    tree[pos] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">BuildTree</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; tree[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; tree[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-8 公路村村通 (30 分)</title>
      <link href="/2022/01/14/7-8%20%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A%20(30%20%E5%88%86)/"/>
      <url>/2022/01/14/7-8%20%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A%20(30%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入数据包括城镇数目正整数<em>N</em>（≤1000）和候选道路数目<em>M</em>（≤3<em>N</em>）；随后的<em>M</em>行对应<em>M</em>条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到<em>N</em>编号。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    最小生成树的两种方法：Prime算法和Kruskal算法。Prime算法写的挺多的了，就不说了。主要是Kruskal算法。</p><p>​    Kruskal算法主要是先按权重最小到大排序，依次选最小的，但不能出现环，如何判断是否是环就成了关键问题。</p><p>​    判断是环的方法就可以等价于新加入的边的两个点是否在同一个集合上，如果在，则会形成环，所以使用并查集。</p><p>​    如果不在同一个集合上，则两个点的集合合并，结果加上该边的权重，如果最后公路都能通，则最后只有一个集合，集合的结点数为n,所以只要要判断加入了几次边就可以了</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Prime</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,mar[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prime</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[n + <span class="number">1</span>],visited[n + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;,res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        dis[i] = mar[s][i];</span><br><span class="line">    visited[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = inf,pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dis[j] &lt; cnt)&#123;</span><br><span class="line">                pos = j;</span><br><span class="line">                cnt = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">-1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += dis[pos];</span><br><span class="line">        visited[pos] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dis[j] &gt; mar[pos][j])</span><br><span class="line">                dis[j] = mar[pos][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(mar,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mar));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        mar[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        mar[a][b] = mar[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Prime</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kruskal算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m,fa[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x)  <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">Find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.z &lt; b.z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    Node node[m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        cin &gt;&gt; node[i].x &gt;&gt; node[i].y &gt;&gt; node[i].z;</span><br><span class="line">    <span class="built_in">sort</span>(node,node + m,cmp);</span><br><span class="line">    <span class="built_in">Init</span>(n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> fx = <span class="built_in">Find</span>(node[i].x),fy = <span class="built_in">Find</span>(node[i].y);</span><br><span class="line">        <span class="keyword">if</span>(fx != fy)&#123;</span><br><span class="line">            ans += node[i].z;</span><br><span class="line">            fa[fx] = fy;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == n)    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>            cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1002 [NOIP2002 普及组] 过河卒</title>
      <link href="/2022/01/12/P1002%20%5BNOIP2002%20%E6%99%AE%E5%8F%8A%E7%BB%84%5D%20%E8%BF%87%E6%B2%B3%E5%8D%92/"/>
      <url>/2022/01/12/P1002%20%5BNOIP2002%20%E6%99%AE%E5%8F%8A%E7%BB%84%5D%20%E8%BF%87%E6%B2%B3%E5%8D%92/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>棋盘上 A 点有一个过河卒，需要走到目标 B 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 C 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。</p><p>棋盘用坐标表示，A 点 (0, 0)、B 点 (n, m)，同样马的位置坐标是需要给出的。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/vg6k477j.png" alt="img"></p><p>现在要求你计算出卒从 A 点能够到达 B 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行四个正整数，分别表示 B 点坐标和马的坐标。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示所有的路径条数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>对于 100% 的数据，1≤n,m≤20，0 ≤ 马的坐标 ≤20。</p><p><strong>【题目来源】</strong></p><p>NOIP 2002 普及组第四题</p><h2 id="算法思路（动态规划）"><a href="#算法思路（动态规划）" class="headerlink" title="算法思路（动态规划）"></a>算法思路（动态规划）</h2><p>​    为了判断方便点，我们可以将左右下标都先+2，然后通过另一个数组确定马能到达的位置（不能走），如果不能走的话dp[j] = 0，如果能走的话，dp[j] += dp[j - 1];</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> bx,by,mx,my;</span><br><span class="line">    cin &gt;&gt; bx &gt;&gt; by &gt;&gt; mx &gt;&gt; my;</span><br><span class="line">    bx +=<span class="number">2</span>;by += <span class="number">2</span>;mx += <span class="number">2</span>;my += <span class="number">2</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    s[mx][my] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">8</span>; ++i)</span><br><span class="line">        s[mx + dx[i]][my + dy[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= bx; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= by; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j])&#123;</span><br><span class="line">                dp[j] = <span class="number">0</span>;<span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] +=  dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[by] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1434 [SHOI2002]滑雪</title>
      <link href="/2022/01/12/P1434%20%5BSHOI2002%5D%E6%BB%91%E9%9B%AA/"/>
      <url>/2022/01/12/P1434%20%5BSHOI2002%5D%E6%BB%91%E9%9B%AA/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"><span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span>  <span class="number">6</span></span><br><span class="line"><span class="number">15</span>  <span class="number">24</span>  <span class="number">25</span>  <span class="number">20</span>  <span class="number">7</span></span><br><span class="line"><span class="number">14</span>  <span class="number">23</span>  <span class="number">22</span>  <span class="number">21</span>  <span class="number">8</span></span><br><span class="line"><span class="number">13</span>  <span class="number">12</span>  <span class="number">11</span>  <span class="number">10</span>  <span class="number">9</span></span><br></pre></td></tr></table></figure><p>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 24－17－16－1（从 24 开始，在 1 结束）。当然 25－24－23－…－3－2－1 更长。事实上，这是最长的一条。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行为表示区域的二维数组的行数 R 和列数 C。下面是 R 行，每行有 C 个数，代表高度(两个数字之间用 1 个空格间隔)。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出区域中最长滑坡的长度。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">6</span></span><br><span class="line"><span class="number">15</span> <span class="number">24</span> <span class="number">25</span> <span class="number">20</span> <span class="number">7</span></span><br><span class="line"><span class="number">14</span> <span class="number">23</span> <span class="number">22</span> <span class="number">21</span> <span class="number">8</span></span><br><span class="line"><span class="number">13</span> <span class="number">12</span> <span class="number">11</span> <span class="number">10</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>对于 100% 的数据，1≤R,C≤100。</p><h2 id="算法思路（动态规划）"><a href="#算法思路（动态规划）" class="headerlink" title="算法思路（动态规划）"></a>算法思路（动态规划）</h2><p>​    和走迷宫差不多，只不过需要记录过去的状态。初始化s数组都为0，然后进行扫描，起初s[x][y] = 1,然后进行dfs，然后前进的结果+1和自身值取最大。dfs的过程中，如果该位置已经计算过，直接返回计算过的结果。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,ans;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">1001</span>][<span class="number">1001</span>],s[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[x][y]) <span class="keyword">return</span> s[x][y];</span><br><span class="line">    s[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> xx = dx[i] + x,yy = dy[i] + y;</span><br><span class="line">        <span class="keyword">if</span>(xx&gt;<span class="number">0</span>&amp;&amp;yy&gt;<span class="number">0</span>&amp;&amp;xx&lt;=n&amp;&amp;yy&lt;=m&amp;&amp;mar[x][y]&gt;mar[xx][yy])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(xx,yy);</span><br><span class="line">            s[x][y] = <span class="built_in">max</span>(s[x][y],s[xx][yy] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            cin &gt;&gt; mar[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m; ++j)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,<span class="built_in">dfs</span>(i,j));</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles</title>
      <link href="/2022/01/12/P1216%20%5BUSACO1.5%5D%5BIOI1994%5D%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%20Number%20Triangles/"/>
      <url>/2022/01/12/P1216%20%5BUSACO1.5%5D%5BIOI1994%5D%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%20Number%20Triangles/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>观察下面的数字金字塔。</p><p>写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        <span class="number">7</span> </span><br><span class="line">      <span class="number">3</span>   <span class="number">8</span> </span><br><span class="line">    <span class="number">8</span>   <span class="number">1</span>   <span class="number">0</span> </span><br><span class="line">  <span class="number">2</span>   <span class="number">7</span>   <span class="number">4</span>   <span class="number">4</span> </span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>   <span class="number">2</span>   <span class="number">6</span>   <span class="number">5</span> </span><br></pre></td></tr></table></figure><p>在上面的样例中,从 7→3→8→7→5 的路径产生了最大</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一个行一个正整数 r ,表示行的数目。</p><p>后面每行为这个数字金字塔特定行包含的整数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>单独的一行,包含那个可能得到的最大的和。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span> </span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>【数据范围】<br>对于 100% 的数据，1≤r≤1000，所有输入在 [0,100] 范围内。</p><p>题目翻译来自NOCOW。</p><p>USACO Training Section 1.5</p><p>IOI1994 Day1T1</p><h2 id="算法思路（动态规划）"><a href="#算法思路（动态规划）" class="headerlink" title="算法思路（动态规划）"></a>算法思路（动态规划）</h2><p>挺简单的，没啥好说的。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    cin &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            cin &gt;&gt; dp[i][j];</span><br><span class="line">    <span class="comment">//当前状态等于上一个状态中找最大的，再加上自身值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            dp[i][j] += <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] ,dp[i - <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++i)</span><br><span class="line">        res = <span class="built_in">max</span>(res,dp[r][i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-10 是否完全二叉搜索树 (30 分)</title>
      <link href="/2022/01/12/7-10%20%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20(30%20%E5%88%86)/"/>
      <url>/2022/01/12/7-10%20%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20(30%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>将一系列给定数字顺序插入一个初始为空的二叉搜索树（定义为左子树键值大，右子树键值小），你需要判断最后的树是否一棵完全二叉树，并且给出其层序遍历的结果。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个不超过20的正整数<code>N</code>；第二行给出<code>N</code>个互不相同的正整数，其间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>将输入的<code>N</code>个正整数顺序插入一个初始为空的二叉搜索树。在第一行中输出结果树的层序遍历结果，数字间以1个空格分隔，行的首尾不得有多余空格。第二行输出<code>YES</code>，如果该树是完全二叉树；否则输出<code>NO</code>。</p><h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">38</span> <span class="number">45</span> <span class="number">42</span> <span class="number">24</span> <span class="number">58</span> <span class="number">30</span> <span class="number">67</span> <span class="number">12</span> <span class="number">51</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">38</span> <span class="number">45</span> <span class="number">24</span> <span class="number">58</span> <span class="number">42</span> <span class="number">30</span> <span class="number">12</span> <span class="number">67</span> <span class="number">51</span></span><br><span class="line">YES</span><br></pre></td></tr></table></figure><h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">38</span> <span class="number">24</span> <span class="number">12</span> <span class="number">45</span> <span class="number">58</span> <span class="number">67</span> <span class="number">42</span> <span class="number">51</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">38</span> <span class="number">45</span> <span class="number">24</span> <span class="number">58</span> <span class="number">42</span> <span class="number">12</span> <span class="number">67</span> <span class="number">51</span></span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    建树的话，操作很简单，不说了。主要是怎么通过层序遍历判断是否是二叉搜索树。</p><p>​    结点的状态：</p><ul><li>空结点</li><li>有左孩子，没右孩子</li><li>没有左孩子，有右孩子</li><li>左右孩子都有</li></ul><p>判断方式</p><ul><li><p>层序遍历的队列中不会出现空结点，所以不讨论</p></li><li><p>有左孩子，没有右孩子，只要之后弹出的结点有孩子，则一定不是完全二    叉树</p></li><li><p>有右孩子，没有左孩子，一定不是完全二叉树</p></li><li><p>左右孩子都有，无法判断，继续将下一个结点出队</p></li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;*Tree;</span><br><span class="line"><span class="keyword">int</span> n,root;</span><br><span class="line"><span class="function">TreeNode* <span class="title">Insert</span><span class="params">(Tree tree,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        TreeNode * node = (TreeNode*)(malloc)(<span class="built_in"><span class="keyword">sizeof</span></span>(TreeNode));</span><br><span class="line">        node -&gt; data = x;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree -&gt; data &lt; x)    tree -&gt; left = <span class="built_in">Insert</span>(tree -&gt; left,x);</span><br><span class="line">    <span class="keyword">else</span>                    tree -&gt; right = <span class="built_in">Insert</span>(tree -&gt; right,x);</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(Tree tree)</span></span>&#123;</span><br><span class="line">    queue&lt;Tree&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(tree);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>,cnt = <span class="number">1</span>,f = <span class="number">0</span>,fl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = qu.<span class="built_in">size</span>(),number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num--)&#123;</span><br><span class="line">            Tree t = qu.<span class="built_in">front</span>();</span><br><span class="line">            cout &lt;&lt; (f ? <span class="string">&quot; &quot;</span> :<span class="string">&quot;&quot;</span>) &lt;&lt; t -&gt; data;</span><br><span class="line">            f = <span class="number">1</span>;</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//有右孩子，没有左孩子，不是完全二叉树</span></span><br><span class="line">            <span class="keyword">if</span>(t -&gt; right &amp;&amp; !t -&gt; left)    flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(t -&gt; left) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fl)  flag = <span class="number">0</span>;</span><br><span class="line">                qu.<span class="built_in">push</span>(t -&gt; left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t -&gt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fl)  flag = <span class="number">0</span>;</span><br><span class="line">                qu.<span class="built_in">push</span>(t -&gt; right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*没有右孩子，开启fl的判断，只有之后出现结点有孩子，则就不是完全二叉树*/</span></span><br><span class="line">            <span class="keyword">if</span>(!t -&gt; right)   fl = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; root;</span><br><span class="line">    Tree tree = (Tree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(TreeNode));</span><br><span class="line">    tree -&gt; data = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">Insert</span>(tree,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LevelOrder</span>(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,tree[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i] == <span class="number">-1</span>)&#123;</span><br><span class="line">        tree[i] = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; tree[i])     <span class="built_in">add</span>(i * <span class="number">2</span>,x);</span><br><span class="line">    <span class="keyword">else</span>                <span class="built_in">add</span>(i * <span class="number">2</span> + <span class="number">1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tree));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">1</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>,pos = <span class="number">0</span>,flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt &lt; n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(tree[pos] == <span class="number">-1</span>)  pos++;</span><br><span class="line">        <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>        flag = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; tree[pos];</span><br><span class="line">        cnt++;pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(pos == n + <span class="number">1</span>)     cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-4 N个数求和 (20 分)</title>
      <link href="/2022/01/12/7-4%20N%E4%B8%AA%E6%95%B0%E6%B1%82%E5%92%8C%20(20%20%E5%88%86)/"/>
      <url>/2022/01/12/7-4%20N%E4%B8%AA%E6%95%B0%E6%B1%82%E5%92%8C%20(20%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>本题的要求很简单，就是求<code>N</code>个数字的和。麻烦的是，这些数字是以有理数<code>分子/分母</code>的形式给出的，你输出的和也必须是有理数的形式。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<code>N</code>（≤100）。随后一行按格式<code>a1/b1 a2/b2 ...</code>给出<code>N</code>个有理数。题目保证所有分子和分母都在长整型范围内。另外，负数的符号一定出现在分子前面。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出上述数字和的最简形式 —— 即将结果写成<code>整数部分 分数部分</code>，其中分数部分写成<code>分子/分母</code>，要求分子小于分母，且它们没有公因子。如果结果的整数部分为0，则只输出分数部分。</p><h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span>/<span class="number">5</span> <span class="number">4</span>/<span class="number">15</span> <span class="number">1</span>/<span class="number">30</span> <span class="number">-2</span>/<span class="number">60</span> <span class="number">8</span>/<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span>/<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span>/<span class="number">3</span> <span class="number">2</span>/<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="输入样例3："><a href="#输入样例3：" class="headerlink" title="输入样例3："></a>输入样例3：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span>/<span class="number">3</span> <span class="number">-1</span>/<span class="number">6</span> <span class="number">1</span>/<span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="输出样例3："><a href="#输出样例3：" class="headerlink" title="输出样例3："></a>输出样例3：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    模拟题，就是慢慢模拟。。。（各种边界条件，还有要开个long long）</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll high[n + <span class="number">1</span>],low[n + <span class="number">1</span>],downlcm = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        ll a,b;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        cin &gt;&gt; high[i] &gt;&gt; c &gt;&gt; low[i];</span><br><span class="line">        <span class="comment">//求分母的最小公倍数</span></span><br><span class="line">        downlcm = downlcm * low[i] / __gcd(downlcm,low[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll highsum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//根据最小公倍数，求通分后分子和</span></span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; n;++i)</span><br><span class="line">        highsum += downlcm / low[i] * high[i];</span><br><span class="line">    <span class="comment">//算出分子和分母的最大公因数</span></span><br><span class="line">    ll gcd = __gcd(<span class="built_in">abs</span>(highsum),<span class="built_in">abs</span>(downlcm));</span><br><span class="line">    <span class="comment">//分子和分母化简</span></span><br><span class="line">    ll up = highsum / gcd,down = downlcm / gcd;</span><br><span class="line">    <span class="comment">//算出整数部分</span></span><br><span class="line">    ll integer = up / down;</span><br><span class="line">    <span class="comment">//分子要减去整数的值</span></span><br><span class="line">    up %= down;</span><br><span class="line">    <span class="keyword">if</span>(up == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,integer);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(integer) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,integer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,up,down);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-10 关于堆的判断 (25 分)</title>
      <link href="/2022/01/12/7-10%20%E5%85%B3%E4%BA%8E%E5%A0%86%E7%9A%84%E5%88%A4%E6%96%AD%20(25%20%E5%88%86)/"/>
      <url>/2022/01/12/7-10%20%E5%85%B3%E4%BA%8E%E5%A0%86%E7%9A%84%E5%88%A4%E6%96%AD%20(25%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>将一系列给定数字顺序插入一个初始为空的小顶堆<code>H[]</code>。随后判断一系列相关命题是否为真。命题分下列几种：</p><ul><li><code>x is the root</code>：<code>x</code>是根结点；</li><li><code>x and y are siblings</code>：<code>x</code>和<code>y</code>是兄弟结点；</li><li><code>x is the parent of y</code>：<code>x</code>是<code>y</code>的父结点；</li><li><code>x is a child of y</code>：<code>x</code>是<code>y</code>的一个子结点。</li></ul><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每组测试第1行包含2个正整数<code>N</code>（≤ 1000）和<code>M</code>（≤ 20），分别是插入元素的个数、以及需要判断的命题数。下一行给出区间[−10000,10000]内的<code>N</code>个要被插入一个初始为空的小顶堆的整数。之后<code>M</code>行，每行给出一个命题。题目保证命题中的结点键值都是存在的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对输入的每个命题，如果其为真，则在一行中输出<code>T</code>，否则输出<code>F</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">46</span> <span class="number">23</span> <span class="number">26</span> <span class="number">24</span> <span class="number">10</span></span><br><span class="line"><span class="number">24</span> is the root</span><br><span class="line"><span class="number">26</span> <span class="keyword">and</span> <span class="number">23</span> are siblings</span><br><span class="line"><span class="number">46</span> is the parent of <span class="number">23</span></span><br><span class="line"><span class="number">23</span> is a child of <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F</span><br><span class="line">T</span><br><span class="line">F</span><br><span class="line">T</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    其实我的思路我感觉也挺好，缺点就是截取数字的时候费点劲，我感觉大佬们秉持着能单个读就单个读的方法，虽然读取的时候代码挺长，但判断很简单。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1002</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> heap[MAXSIZE], heapsize;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    heap[<span class="number">0</span>] = <span class="number">-100001</span>;</span><br><span class="line">    heapsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++heapsize] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = heapsize; heap[i] &lt; heap[i / <span class="number">2</span>]; i /= <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">swap</span>(heap[i], heap[i / <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= heapsize; ++i)</span><br><span class="line">        <span class="keyword">if</span>(heap[i] == x)    <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>)       <span class="keyword">return</span> heap[<span class="number">1</span>] == x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span>)  <span class="keyword">return</span> <span class="built_in">Find</span>(x) / <span class="number">2</span> == <span class="built_in">Find</span>(y) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">3</span>)  <span class="keyword">return</span> <span class="built_in">Find</span>(x) == <span class="built_in">Find</span>(y) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span>                <span class="keyword">return</span> <span class="built_in">Find</span>(x) / <span class="number">2</span> == <span class="built_in">Find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">Insert</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,flag = <span class="number">0</span>;</span><br><span class="line">        string str;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; str;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">&quot;and&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; y &gt;&gt; str &gt;&gt; str;</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; str;</span><br><span class="line">            <span class="keyword">if</span>(str == <span class="string">&quot;a&quot;</span>)&#123;</span><br><span class="line">                cin &gt;&gt; str &gt;&gt; str &gt;&gt; y;</span><br><span class="line">                flag = <span class="number">4</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cin &gt;&gt; str;</span><br><span class="line">                <span class="keyword">if</span>(str == <span class="string">&quot;root&quot;</span>)&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cin &gt;&gt; str &gt;&gt; y;</span><br><span class="line">                    flag = <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(x,y,flag))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;T&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;F&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我自己的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1002</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> heap[MAXSIZE], heapsize;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    heap[<span class="number">0</span>] = <span class="number">-100001</span>;</span><br><span class="line">    heapsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++heapsize] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = heapsize; heap[i] &lt; heap[i / <span class="number">2</span>]; i /= <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">swap</span>(heap[i], heap[i / <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= heapsize; ++i)</span><br><span class="line">        <span class="keyword">if</span>(heap[i] == x)    <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">Insert</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="built_in">getline</span>(cin, s);</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)s.<span class="built_in">find</span>(<span class="string">&quot;root&quot;</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[pos] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                pos++;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">            <span class="keyword">if</span>(heap[<span class="number">1</span>] != num)  flag = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pos1 = <span class="number">0</span>, pos2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[pos1] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                pos1++;</span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="built_in">Find</span>(<span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, pos1)));</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(s[pos1]) &amp;&amp; s[pos1] != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                pos1++;</span><br><span class="line">            pos2 = pos1;</span><br><span class="line">            <span class="keyword">while</span>(pos2 &lt; s.<span class="built_in">size</span>() &amp;&amp; s[pos2] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                pos2++;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="built_in">Find</span>(<span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(pos1, pos2 - pos1)));</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">int</span>)s.<span class="built_in">find</span>(<span class="string">&quot;siblings&quot;</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(num1 / <span class="number">2</span> != num2 / <span class="number">2</span> || num1 == num2)</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>((<span class="keyword">int</span>)s.<span class="built_in">find</span>(<span class="string">&quot;parent&quot;</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(num1 != num2 / <span class="number">2</span>)</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(num1 / <span class="number">2</span> != num2)</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;T&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;F&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-8 后缀式求值 (25 分)</title>
      <link href="/2022/01/12/7-8%20%E5%90%8E%E7%BC%80%E5%BC%8F%E6%B1%82%E5%80%BC%20(25%20%E5%88%86)/"/>
      <url>/2022/01/12/7-8%20%E5%90%8E%E7%BC%80%E5%BC%8F%E6%B1%82%E5%80%BC%20(25%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>我们人类习惯于书写“中缀式”，如 <code>3 + 5 * 2</code> ，其值为<code>13</code>。 (p.s. 为什么人类习惯中缀式呢？是因为中缀式比后缀式好用么？）<br>而计算机更加习惯“后缀式”（也叫“逆波兰式”，Reverse Polish Notation）。上述中缀式对应的后缀式是： <code>3 5 2 * +</code><br>现在，请对输入的后缀式进行求值。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>在一行中输入一个后缀式，<code>运算数</code>和<code>运算符</code>之间用空格分隔，运算数长度不超过<code>6</code>位，运算符仅有<code>+ - * /</code> 四种。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出后缀式的值，保留一位小数。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">5.4</span> <span class="number">2.2</span> * +</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14.9</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    不得不说，看大佬们代码，对扩展思路很有帮助，我都是读一整行的字符串，然后遍历，遍历的时候进行判断还挺费劲。</p><p>​    大佬们的这个好，单个单个读，以空格作为分割</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string str;</span><br><span class="line">    stack&lt;<span class="keyword">double</span>&gt; st;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">&quot;*&quot;</span> || str == <span class="string">&quot;/&quot;</span> || str == <span class="string">&quot;+&quot;</span> || str == <span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">double</span> a = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">double</span> b = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(str == <span class="string">&quot;*&quot;</span>)      st.<span class="built_in">push</span>(b * a);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">&quot;/&quot;</span>) st.<span class="built_in">push</span>(b / a);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">&quot;+&quot;</span>) st.<span class="built_in">push</span>(b + a);</span><br><span class="line">            <span class="keyword">else</span>                st.<span class="built_in">push</span>(b - a);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="built_in">stod</span>(str));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n&quot;</span>,st.<span class="built_in">top</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我自己的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    stack&lt;<span class="keyword">double</span>&gt; st1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(s[i]) || (s[i] == <span class="string">&#x27;-&#x27;</span>&amp;&amp;<span class="built_in">isdigit</span>(s[i + <span class="number">1</span>])) || s[i] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            str += s[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            st1.<span class="built_in">push</span>(<span class="number">1.0</span> * <span class="built_in">stod</span>(str));</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">double</span> a = st1.<span class="built_in">top</span>();st1.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">double</span> b = st1.<span class="built_in">top</span>();st1.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(s[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> : st1.<span class="built_in">push</span>(b + a);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> : st1.<span class="built_in">push</span>(b - a);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> : st1.<span class="built_in">push</span>(b * a);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> : st1.<span class="built_in">push</span>(b / a);<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n&quot;</span>,st1.<span class="built_in">top</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-7 彩虹瓶 (25 分)</title>
      <link href="/2022/01/12/7-7%20%E5%BD%A9%E8%99%B9%E7%93%B6%20(25%20%E5%88%86)/"/>
      <url>/2022/01/12/7-7%20%E5%BD%A9%E8%99%B9%E7%93%B6%20(25%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><img src="https://images.ptausercontent.com/5612216c-1cbd-4dba-b9da-4f653ad00c7b.JPG" alt="rb.JPG"></p><p>彩虹瓶的制作过程（并不）是这样的：先把一大批空瓶铺放在装填场地上，然后按照一定的顺序将每种颜色的小球均匀撒到这批瓶子里。</p><p>假设彩虹瓶里要按顺序装 N 种颜色的小球（不妨将顺序就编号为 1 到 N）。现在工厂里有每种颜色的小球各一箱，工人需要一箱一箱地将小球从工厂里搬到装填场地。如果搬来的这箱小球正好是可以装填的颜色，就直接拆箱装填；如果不是，就把箱子先码放在一个临时货架上，码放的方法就是一箱一箱堆上去。当一种颜色装填完以后，先看看货架顶端的一箱是不是下一个要装填的颜色，如果是就取下来装填，否则去工厂里再搬一箱过来。</p><p>如果工厂里发货的顺序比较好，工人就可以顺利地完成装填。例如要按顺序装填 7 种颜色，工厂按照 7、6、1、3、2、5、4 这个顺序发货，则工人先拿到 7、6 两种不能装填的颜色，将其按照 7 在下、6 在上的顺序堆在货架上；拿到 1 时可以直接装填；拿到 3 时又得临时码放在 6 号颜色箱上；拿到 2 时可以直接装填；随后从货架顶取下 3 进行装填；然后拿到 5，临时码放到 6 上面；最后取了 4 号颜色直接装填；剩下的工作就是顺序从货架上取下 5、6、7 依次装填。</p><p>但如果工厂按照 3、1、5、4、2、6、7 这个顺序发货，工人就必须要愤怒地折腾货架了，因为装填完 2 号颜色以后，不把货架上的多个箱子搬下来就拿不到 3 号箱，就不可能顺利完成任务。</p><p>另外，货架的容量有限，如果要堆积的货物超过容量，工人也没办法顺利完成任务。例如工厂按照 7、6、5、4、3、2、1 这个顺序发货，如果货架够高，能码放 6 只箱子，那还是可以顺利完工的；但如果货架只能码放 5 只箱子，工人就又要愤怒了……</p><p>本题就请你判断一下，工厂的发货顺序能否让工人顺利完成任务。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先在第一行给出 3 个正整数，分别是彩虹瓶的颜色数量 <em>N</em>（1&lt;<em>N</em>≤103）、临时货架的容量 <em>M</em>（&lt;<em>N</em>）、以及需要判断的发货顺序的数量 <em>K</em>。</p><p>随后 <em>K</em> 行，每行给出 <em>N</em> 个数字，是 1 到<em>N</em> 的一个排列，对应工厂的发货顺序。</p><p>一行中的数字都以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个发货顺序，如果工人可以愉快完工，就在一行中输出 <code>YES</code>；否则输出 <code>NO</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>利用栈模拟仓库，使用now来记录当前空地需要的序号。若当前输入的箱子序号==now，在now++后，需要比对仓库，直至仓库空或者栈顶元素!= now为止。最后若栈空，并且无仓库过存问题，即为“Yes”。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span>(now == x)&#123;</span><br><span class="line">                now++;</span><br><span class="line">                <span class="keyword">while</span>(st.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; st.<span class="built_in">top</span>() == now)&#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();now++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(x);</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">size</span>() &gt; m)</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">size</span>() &gt; <span class="number">0</span> || !flag)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我自己的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>, t, flag = <span class="number">1</span>;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt;  st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                <span class="keyword">if</span>(t == num) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    <span class="keyword">while</span>(st.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; st.<span class="built_in">top</span>() == num) &#123;</span><br><span class="line">                        st.<span class="built_in">pop</span>();</span><br><span class="line">                        num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span>(st.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; st.<span class="built_in">top</span>() == num) &#123;</span><br><span class="line">                        st.<span class="built_in">pop</span>();</span><br><span class="line">                        num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">size</span>() &gt;= m)  flag = <span class="number">0</span>;</span><br><span class="line">                    st.<span class="built_in">push</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == n + <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1802 5 倍经验日</title>
      <link href="/2022/01/11/P1802%205%20%E5%80%8D%E7%BB%8F%E9%AA%8C%E6%97%A5/"/>
      <url>/2022/01/11/P1802%205%20%E5%80%8D%E7%BB%8F%E9%AA%8C%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>现在乐斗有活动了！每打一个人可以获得 5 倍经验！absi2011 却无奈的看着那一些比他等级高的好友，想着能否把他们干掉。干掉能拿不少经验的。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在 absi2011 拿出了 x个迷你装药物（嗑药打人可耻…），准备开始与那些人打了。</p><p>由于迷你装药物每个只能用一次，所以 absi2011 要谨慎的使用这些药。悲剧的是，用药量没达到最少打败该人所需的属性药药量，则打这个人必输。例如他用 2 个药去打别人，别人却表明 3 个药才能打过，那么相当于你输了并且这两个属性药浪费了。</p><p>现在有 n个好友，给定失败时可获得的经验、胜利时可获得的经验，打败他至少需要的药量。</p><p>要求求出最大经验 s，输出 5s。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个数，n和 x。</p><p>后面 n行每行三个数，分别表示失败时获得的经验 lose_i，胜利时获得的经验 win_i 和打过要至少使用的药数量use_i。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，最多获得的经验的五倍。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 8</span><br><span class="line">21 52 1</span><br><span class="line">21 70 5</span><br><span class="line">21 48 2</span><br><span class="line">14 38 3</span><br><span class="line">14 36 1</span><br><span class="line">14 36 2</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1060</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p><strong>【Hint】</strong></p><p>五倍经验活动的时候，absi2011 总是吃体力药水而不是这种属性药。</p><p><strong>【数据范围】</strong></p><ul><li>对于 10% 的数据，保证 x=0。</li><li>对于 30% 的数据，保证 0≤n≤10，0≤x≤20。</li><li>对于 60% 的数据，保证 0≤n,x≤100， 10&lt;lose_i,win_i≤100，0≤ use_i≤5。</li><li>对于 100% 的数据，保证 0≤n,x≤10^3，0&lt;lose_i≤ win_i≤10^6，0≤ use_i≤10^3。</li></ul><p><strong>【题目来源】</strong></p><p>fight.pet.qq.com</p><p>absi2011 授权题目</p><h2 id="算法思路（动态规划）"><a href="#算法思路（动态规划）" class="headerlink" title="算法思路（动态规划）"></a>算法思路（动态规划）</h2><p>OI梗：**==十年 OI 一场空，不开 long long 见祖宗。==**</p><p>和背包问题有点区别，就是如果不选当前物品的话，和前一个状态还是有区别。所以状态方程只需要把原本的dp[j] = dp[j],改成dp[j] += v1[i]</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> w[<span class="number">1001</span>],v1[<span class="number">1001</span>],v2[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,x;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n ;++i)&#123;</span><br><span class="line">        cin &gt;&gt; v1[i] &gt;&gt; v2[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j = x; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; w[i])</span><br><span class="line">                dp[j] += v1[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j] +v1[i],dp[j - w[i]] + v2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[x] * <span class="number">5</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 0-1背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1616 疯狂的采药</title>
      <link href="/2022/01/10/P1616%20%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF/"/>
      <url>/2022/01/10/P1616%20%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>此题为纪念 LiYuxiang 而生。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是 LiYuxiang，你能完成这个任务吗？</p><p>此题和原题的不同点：</p><ol><li><p>每种草药可以无限制地疯狂采摘。</p></li><li><p>药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！</p></li></ol><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第一行有两个整数，分别代表总共能够用来采药的时间 t<em>t</em> 和代表山洞里的草药的数目 m。</p><p>第 2 到第 (m + 1)行，每行两个整数，第 (i + 1)行的整数 a_i, b_i分别表示采摘第 i 种草药的时间和该草药的价值。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">70</span> <span class="number">3</span></span><br><span class="line"><span class="number">71</span> <span class="number">100</span></span><br><span class="line"><span class="number">69</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">140</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul><li>对于 30% 的数据，保证m≤10^3 。</li><li>对于 100% 的数据，保证 1≤m≤10^4， 1≤t≤10^7，且 1≤m×t≤10^7， 1≤a_i,b_i≤10^4。</li></ul><h2 id="算法思路（动态规划）"><a href="#算法思路（动态规划）" class="headerlink" title="算法思路（动态规划）"></a>算法思路（动态规划）</h2><p>经典完全背包问题</p><p>OI梗：**==十年 OI 一场空，不开 long long 见祖宗。==**</p><p>这题用二维dp数组，开出来太大了（也可以试试滚动数组），所以只能用一维dp</p><p>完全背包问题和0-1背包问题的递推式不同是，完全背包问题它放进物品的时候，是考虑它的同一行，而不是上一行，因为考虑的是同一行，所以遍历的时候可以进行顺序遍历，同时当j &lt; w[i]的时候，d[j]是不会发生改变的，因为装不进去，所以该从w[i]开始遍历</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">10000001</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">10001</span>], v[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t, m;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = w[i]; j &lt;= t; ++j)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j - w[i]] + v[i],dp[j]);</span><br><span class="line">    cout &lt;&lt; dp[t] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 完全背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1048 [NOIP2005 普及组] 采药</title>
      <link href="/2022/01/10/P1048%20%5BNOIP2005%20%E6%99%AE%E5%8F%8A%E7%BB%84%5D%20%E9%87%87%E8%8D%AF/"/>
      <url>/2022/01/10/P1048%20%5BNOIP2005%20%E6%99%AE%E5%8F%8A%E7%BB%84%5D%20%E9%87%87%E8%8D%AF/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是辰辰，你能完成这个任务吗？</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有 2 个整数 T（1≤T≤1000）和 M（1≤M≤100），用一个空格隔开，T 代表总共能够用来采药的时间，M 代表山洞里的草药的数目。</p><p>接下来的 M 行每行包括两个在 1 到 100 之间（包括 1 和 100）的整数，分别表示采摘某株草药的时间和这株草药的价值。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出在规定的时间内可以采到的草药的最大总价值。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">70 3</span><br><span class="line">71 100</span><br><span class="line">69 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p><strong>【数据范围】</strong></p><ul><li>对于 30% 的数据，M≤10；</li><li>对于全部的数据，M≤100。</li></ul><p><strong>【题目来源】</strong></p><p>NOIP 2005 普及组第三题</p><h2 id="算法思路（动态规划）"><a href="#算法思路（动态规划）" class="headerlink" title="算法思路（动态规划）"></a>算法思路（动态规划）</h2><p>​    经典0-1背包问题</p><h4 id="1-二维dp数组"><a href="#1-二维dp数组" class="headerlink" title="1.二维dp数组"></a>1.二维dp数组</h4><p>dp[i][j]代表前i个物品，容量为j的情况下的能选择的最大价值，</p><p>于是我们有如下递推式：dp[0][j] = 0</p><p><svg xmlns="http://www.w3.org/2000/svg" width="58.472ex" height="5.428ex" viewbox="0 -1449.5 25844.7 2399" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-640-TEX-I-1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/><path id="MJX-640-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/><path id="MJX-640-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-640-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path id="MJX-640-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/><path id="MJX-640-TEX-I-1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/><path id="MJX-640-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-640-TEX-S3-7B" d="M618 -943L612 -949H582L568 -943Q472 -903 411 -841T332 -703Q327 -682 327 -653T325 -350Q324 -28 323 -18Q317 24 301 61T264 124T221 171T179 205T147 225T132 234Q130 238 130 250Q130 255 130 258T131 264T132 267T134 269T139 272T144 275Q207 308 256 367Q310 436 323 519Q324 529 325 851Q326 1124 326 1154T332 1205Q369 1358 566 1443L582 1450H612L618 1444V1429Q618 1413 616 1411L608 1406Q599 1402 585 1393T552 1372T515 1343T479 1305T449 1257T429 1200Q425 1180 425 1152T423 851Q422 579 422 549T416 498Q407 459 388 424T346 364T297 318T250 284T214 264T197 254L188 251L205 242Q290 200 345 138T416 3Q421 -18 421 -48T423 -349Q423 -397 423 -472Q424 -677 428 -694Q429 -697 429 -699Q434 -722 443 -743T465 -782T491 -816T519 -845T548 -868T574 -886T595 -899T610 -908L616 -910Q618 -912 618 -928V-943Z"/><path id="MJX-640-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/><path id="MJX-640-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-640-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-640-TEX-N-3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/><path id="MJX-640-TEX-I-1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/><path id="MJX-640-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path id="MJX-640-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/><path id="MJX-640-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/><path id="MJX-640-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-640-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/><path id="MJX-640-TEX-I-1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/><path id="MJX-640-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-640-TEX-I-1D451"/></g><g data-mml-node="mi" transform="translate(520, 0)"><use xlink:href="#MJX-640-TEX-I-1D45D"/></g><g data-mml-node="mo" transform="translate(1023, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(1301, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(1646, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(1924, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(2202, 0)"><use xlink:href="#MJX-640-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(2614, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(3169.8, 0)"><use xlink:href="#MJX-640-TEX-N-3D"/></g><g data-mml-node="mrow" transform="translate(4225.6, 0)"><g data-mml-node="mo"><use xlink:href="#MJX-640-TEX-S3-7B"/></g><g data-mml-node="mtable" transform="translate(750, 0)"><g data-mml-node="mtr" transform="translate(0, 600)"><g data-mml-node="mtd"><g data-mml-node="mi"><use xlink:href="#MJX-640-TEX-I-1D451"/></g><g data-mml-node="mi" transform="translate(520, 0)"><use xlink:href="#MJX-640-TEX-I-1D45D"/></g><g data-mml-node="mo" transform="translate(1023, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(1301, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(1868.2, 0)"><use xlink:href="#MJX-640-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(2868.4, 0)"><use xlink:href="#MJX-640-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(3368.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(3646.4, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(3924.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(4336.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(4614.4, 0)"><use xlink:href="#MJX-640-TEX-N-2C"/></g><g data-mml-node="mo" transform="translate(5059.1, 0)"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">当</text></g><g data-mml-node="mi" transform="translate(6220.9, 0)"><use xlink:href="#MJX-640-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(6910.7, 0)"><use xlink:href="#MJX-640-TEX-N-3C"/></g><g data-mml-node="mi" transform="translate(7966.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D464"/></g><g data-mml-node="mo" transform="translate(8682.4, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(8960.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(9305.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g></g></g><g data-mml-node="mtr" transform="translate(0, -600)"><g data-mml-node="mtd"><g data-mml-node="mi"><use xlink:href="#MJX-640-TEX-I-1D45A"/></g><g data-mml-node="mi" transform="translate(878, 0)"><use xlink:href="#MJX-640-TEX-I-1D44E"/></g><g data-mml-node="mi" transform="translate(1407, 0)"><use xlink:href="#MJX-640-TEX-I-1D465"/></g><g data-mml-node="mo" transform="translate(1979, 0)"><use xlink:href="#MJX-640-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(2368, 0)"><use xlink:href="#MJX-640-TEX-I-1D451"/></g><g data-mml-node="mi" transform="translate(2888, 0)"><use xlink:href="#MJX-640-TEX-I-1D45D"/></g><g data-mml-node="mo" transform="translate(3391, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(3669, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(4236.2, 0)"><use xlink:href="#MJX-640-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(5236.4, 0)"><use xlink:href="#MJX-640-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(5736.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(6014.4, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(6292.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(6704.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(6982.4, 0)"><use xlink:href="#MJX-640-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(7427.1, 0)"><use xlink:href="#MJX-640-TEX-I-1D451"/></g><g data-mml-node="mi" transform="translate(7947.1, 0)"><use xlink:href="#MJX-640-TEX-I-1D45D"/></g><g data-mml-node="mo" transform="translate(8450.1, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(8728.1, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(9295.3, 0)"><use xlink:href="#MJX-640-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(10295.6, 0)"><use xlink:href="#MJX-640-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(10795.6, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(11073.6, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(11351.6, 0)"><use xlink:href="#MJX-640-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(11985.8, 0)"><use xlink:href="#MJX-640-TEX-N-2212"/></g><g data-mml-node="mi" transform="translate(12986, 0)"><use xlink:href="#MJX-640-TEX-I-1D464"/></g><g data-mml-node="mo" transform="translate(13702, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(13980, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(14325, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(14603, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(15103.2, 0)"><use xlink:href="#MJX-640-TEX-N-2B"/></g><g data-mml-node="mi" transform="translate(16103.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D463"/></g><g data-mml-node="mo" transform="translate(16588.4, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(16866.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(17211.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(17489.4, 0)"><use xlink:href="#MJX-640-TEX-N-29"/></g><g data-mml-node="mo" transform="translate(17878.4, 0)"><use xlink:href="#MJX-640-TEX-N-2C"/></g><g data-mml-node="mo" transform="translate(18323.1, 0)"><use xlink:href="#MJX-640-TEX-N-28"/></g><g data-mml-node="mo" transform="translate(18712.1, 0)"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">其</text><text data-variant="normal" transform="translate(884, 0) matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">他</text></g><g data-mml-node="mo" transform="translate(20480.1, 0)"><use xlink:href="#MJX-640-TEX-N-29"/></g></g></g></g><g data-mml-node="mo" transform="translate(21619.1, 0)"/></g></g></g></svg></p><ul><li>当容量小于w[i]，那么说明放不下第i件物品，则前i种物品的最大价值和前i-1种最大物品价值的情况相同，即dp[i][j] = dp[i-1][j]</li><li>当能装下，则要给第i件物品留下足够的空间，对应前i-1种物品，容量为j-w[i]的最大价值加上v[i]，然后和dp[i-1][j]比较取最大，即                       dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])</li></ul><h4 id="2-一维dp数组"><a href="#2-一维dp数组" class="headerlink" title="2.一维dp数组"></a>2.一维dp数组</h4><p>我们从上面二维数组可以看出，dp[i][j]只与它的上一行dp[i-1]有关，所以可以用改用一维数组，因为当前值和它的上一行有关，所以进行遍历的时候要反向遍历</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">101</span>], v[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t, m;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; w[i])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j - w[i]] + v[i], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m][t] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">101</span>], v[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t, m;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = t;j &gt;= <span class="number">1</span>; --j)</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= w[i])</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j - w[i]] +v[i]);</span><br><span class="line">    cout &lt;&lt; dp[t] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 01背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202112-2 序列查询新解</title>
      <link href="/2022/01/09/202112-2%20%E5%BA%8F%E5%88%97%E6%9F%A5%E8%AF%A2%E6%96%B0%E8%A7%A3/"/>
      <url>/2022/01/09/202112-2%20%E5%BA%8F%E5%88%97%E6%9F%A5%E8%AF%A2%E6%96%B0%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><img src="http://r.photo.store.qq.com/psc?/V12Ria3720LYpY/45NBuzDIW489QBoVep5mcfXJYuzIUsn09Rc0llLBgfU5f6DfDevaua.kXbvFHC0f0dETEmM1OrMBOaC2NtSrd9TsxVsIPThj1xVD8jrUVWg!/r"></p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>用样例一来进行解释</p><p>A = [0,2,5,8],n = 3,N = 10,r = 2</p><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>f(i)</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>3</td><td>3</td></tr><tr><td>g(i)</td><td>0</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>4</td><td>4</td></tr><tr><td>sum(i)</td><td>0</td><td>0</td><td>1</td><td>2</td><td>4</td><td>6</td><td>9</td><td>12</td><td>16</td><td>20</td></tr><tr><td>|g(i) - f(i)|</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>根据亲身体验，哎，遍历一遍i铁定超时，所以换个思路</p><p>将遍历i改为遍历f(i)，这样的话也就不用开数组保存f(i)的值了，因为f(i)的范围为[0,n],这是可以事先已知的。</p><p>以f(i) = 0为例，g(i)此时为{0,0},要求|g(i) - f(i)|，只需要让f(i)的区间和 - g(i)的区间和即可，f(i)的区间和可以直接区间长度*f(i)的值，g(i)的值需要把g(i)看成r个等差数列即可，因为g(i) = {0,0,1,1,2,2,3,3,4,4},可以看成由2（r）个等差数列组成的数列，则它的求前i项和的公式为</p><p><svg xmlns="http://www.w3.org/2000/svg" width="46.463ex" height="6.749ex" viewbox="0 -1717.4 20536.7 2983.1" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-428-TEX-LO-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"/><path id="MJX-428-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-428-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-428-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/><path id="MJX-428-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path id="MJX-428-TEX-I-1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/><path id="MJX-428-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-428-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/><path id="MJX-428-TEX-I-1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path id="MJX-428-TEX-N-D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/><path id="MJX-428-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/><path id="MJX-428-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-428-TEX-N-2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"/><path id="MJX-428-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/><path id="MJX-428-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-428-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-428-TEX-N-25" d="M465 605Q428 605 394 614T340 632T319 641Q332 608 332 548Q332 458 293 403T202 347Q145 347 101 402T56 548Q56 637 101 693T202 750Q241 750 272 719Q359 642 464 642Q580 642 650 732Q662 748 668 749Q670 750 673 750Q682 750 688 743T693 726Q178 -47 170 -52Q166 -56 160 -56Q147 -56 142 -45Q137 -36 142 -27Q143 -24 363 304Q469 462 525 546T581 630Q528 605 465 605ZM207 385Q235 385 263 427T292 548Q292 617 267 664T200 712Q193 712 186 709T167 698T147 668T134 615Q132 595 132 548V527Q132 436 165 403Q183 385 203 385H207ZM500 146Q500 234 544 290T647 347Q699 347 737 292T776 146T737 0T646 -56Q590 -56 545 0T500 146ZM651 -18Q679 -18 707 24T736 146Q736 215 711 262T644 309Q637 309 630 306T611 295T591 265T578 212Q577 200 577 146V124Q577 -18 647 -18H651Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="munderover"><g data-mml-node="mo"><use xlink:href="#MJX-428-TEX-LO-2211"/></g><g data-mml-node="TeXAtom" transform="translate(86, -1107.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-428-TEX-I-1D458"/></g><g data-mml-node="mo" transform="translate(521, 0)"><use xlink:href="#MJX-428-TEX-N-3D"/></g><g data-mml-node="mn" transform="translate(1299, 0)"><use xlink:href="#MJX-428-TEX-N-30"/></g></g><g data-mml-node="TeXAtom" transform="translate(600, 1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-428-TEX-I-1D456"/></g></g></g><g data-mml-node="mi" transform="translate(1610.7, 0)"><use xlink:href="#MJX-428-TEX-I-1D454"/></g><g data-mml-node="mo" transform="translate(2087.7, 0)"><use xlink:href="#MJX-428-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(2476.7, 0)"><use xlink:href="#MJX-428-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(2821.7, 0)"><use xlink:href="#MJX-428-TEX-N-29"/></g><g data-mml-node="mo" transform="translate(3488.4, 0)"><use xlink:href="#MJX-428-TEX-N-3D"/></g><g data-mml-node="mi" transform="translate(4544.2, 0)"><use xlink:href="#MJX-428-TEX-I-1D45F"/></g><g data-mml-node="mo" transform="translate(5217.4, 0)"><use xlink:href="#MJX-428-TEX-N-D7"/></g><g data-mml-node="mstyle" transform="translate(6217.7, 0)"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220, 589.5) scale(0.707)"><g data-mml-node="mo"><use xlink:href="#MJX-428-TEX-N-28"/></g><g data-mml-node="mfrac" transform="translate(389, 0)"><g data-mml-node="mrow" transform="translate(220, 398) scale(0.707)"><g data-mml-node="mi"><use xlink:href="#MJX-428-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(345, 0)"><use xlink:href="#MJX-428-TEX-N-2B"/></g><g data-mml-node="mn" transform="translate(1123, 0)"><use xlink:href="#MJX-428-TEX-N-31"/></g></g><g data-mml-node="mi" transform="translate(634.4, -345) scale(0.707)"><use xlink:href="#MJX-428-TEX-I-1D45F"/></g><rect width="1347.6" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1976.6, 0)"><use xlink:href="#MJX-428-TEX-N-29"/></g><g data-mml-node="mo" transform="translate(2365.6, 0)"><use xlink:href="#MJX-428-TEX-N-2217"/></g><g data-mml-node="mo" transform="translate(2865.6, 0)"><use xlink:href="#MJX-428-TEX-N-28"/></g><g data-mml-node="mfrac" transform="translate(3254.6, 0)"><g data-mml-node="mrow" transform="translate(220, 398) scale(0.707)"><g data-mml-node="mi"><use xlink:href="#MJX-428-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(345, 0)"><use xlink:href="#MJX-428-TEX-N-2B"/></g><g data-mml-node="mn" transform="translate(1123, 0)"><use xlink:href="#MJX-428-TEX-N-31"/></g></g><g data-mml-node="mi" transform="translate(634.4, -345) scale(0.707)"><use xlink:href="#MJX-428-TEX-I-1D45F"/></g><rect width="1347.6" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(4842.3, 0)"><use xlink:href="#MJX-428-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(5620.3, 0)"><use xlink:href="#MJX-428-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(6120.3, 0)"><use xlink:href="#MJX-428-TEX-N-29"/></g></g><g data-mml-node="mn" transform="translate(2344.6, -345) scale(0.707)"><use xlink:href="#MJX-428-TEX-N-32"/></g><rect width="4802.7" height="60" x="120" y="220"/></g></g><g data-mml-node="mo" transform="translate(11482.6, 0)"><use xlink:href="#MJX-428-TEX-N-2B"/></g><g data-mml-node="mo" transform="translate(12482.9, 0)"><use xlink:href="#MJX-428-TEX-N-28"/></g><g data-mml-node="mo" transform="translate(12871.9, 0)"><use xlink:href="#MJX-428-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(13260.9, 0)"><use xlink:href="#MJX-428-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(14083.1, 0)"><use xlink:href="#MJX-428-TEX-N-2B"/></g><g data-mml-node="mn" transform="translate(15083.3, 0)"><use xlink:href="#MJX-428-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(15583.3, 0)"><use xlink:href="#MJX-428-TEX-N-29"/></g><g data-mml-node="mi" transform="translate(15972.3, 0)"><use xlink:href="#MJX-428-TEX-N-25"/></g><g data-mml-node="mi" transform="translate(16805.3, 0)"><use xlink:href="#MJX-428-TEX-I-1D45F"/></g><g data-mml-node="mo" transform="translate(17256.3, 0)"><use xlink:href="#MJX-428-TEX-N-29"/></g><g data-mml-node="mo" transform="translate(17867.5, 0)"><use xlink:href="#MJX-428-TEX-N-D7"/></g><g data-mml-node="mo" transform="translate(18867.7, 0)"><use xlink:href="#MJX-428-TEX-N-28"/></g><g data-mml-node="mfrac" transform="translate(19256.7, 0)"><g data-mml-node="mi" transform="translate(273, 676)"><use xlink:href="#MJX-428-TEX-I-1D456"/></g><g data-mml-node="mi" transform="translate(220, -686)"><use xlink:href="#MJX-428-TEX-I-1D45F"/></g><rect width="651" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(20147.7, 0)"><use xlink:href="#MJX-428-TEX-N-29"/></g></g></g></svg></p><p>当然，f(i)对应的g(i)区间存在三种情况</p><ul><li>g(i)的值都大于等于f(i)</li><li>g(i)的值都小于等于f(i)</li><li>g(i)中既有比f(i)小的，也有比f(i)大的</li></ul><p>前两种情况比较好算，只需要f(i)减去g(i)的区间和取绝对值即可，对于第三种，就需要把g(i)分成两部分，一部分都比f(i)小，一部分都比f(i)大，然后等同于前两种情况。</p><p>例如当f(i) = 1时，我们可以g(i)分为{1,1}和{2}两部分，然后分别计算求和</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,N,r;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt; <span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> r * ((i + <span class="number">1</span>) / r) * ((i + <span class="number">1</span>) / r - <span class="number">1</span>) / <span class="number">2</span> + (i + <span class="number">1</span>) % r * (i / r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">cal</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> fi,<span class="keyword">long</span> <span class="keyword">long</span> left,<span class="keyword">long</span> <span class="keyword">long</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">sum</span>(right) - <span class="built_in">sum</span>(left - <span class="number">1</span>) - fi * (right - left + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; N;</span><br><span class="line">    r = N / (n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> arr[n + <span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    arr[n + <span class="number">1</span>] = N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> fi = <span class="number">0</span>; fi &lt;= n; ++fi)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> left = arr[fi],right = arr[fi + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(left / r &gt;= fi || right / r &lt;= fi)   res += <span class="built_in">cal</span>(fi,left,right);</span><br><span class="line">        <span class="keyword">else</span>    res += <span class="built_in">cal</span>(fi,left,r * fi) + <span class="built_in">cal</span>(fi,r * fi + <span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSP </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022 新生摸底测试题目集</title>
      <link href="/2022/01/08/2022%20%E6%96%B0%E7%94%9F%E6%91%B8%E5%BA%95%E6%B5%8B%E8%AF%95%E9%A2%98%E7%9B%AE%E9%9B%86/"/>
      <url>/2022/01/08/2022%20%E6%96%B0%E7%94%9F%E6%91%B8%E5%BA%95%E6%B5%8B%E8%AF%95%E9%A2%98%E7%9B%AE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="7-1-加法求值-10-分"><a href="#7-1-加法求值-10-分" class="headerlink" title="7-1 加法求值 (10 分)"></a><strong>7-1 加法求值 (10 分)</strong></h2><p>给定一个表达式<em>A</em>+<em>B</em>,输出<em>A</em>+<em>B</em>的值</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>一个长度不超过9且大于等于3的字符串，且保证是合法的中缀表达式。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出A+B的值。</p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">111</span>+<span class="number">2222</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2333</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哎，自己就是一顿字符串截取，没想过这种方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>,&amp;a,&amp;c,&amp;b);</span><br><span class="line">    cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4-然后是几点-15-分"><a href="#7-4-然后是几点-15-分" class="headerlink" title="7-4 然后是几点 (15 分)"></a><strong>7-4 然后是几点 (15 分)</strong></h2><p>有时候人们用四位数字表示一个时间，比如 <code>1106</code> 表示 11 点零 6 分。现在，你的程序要根据起始时间和流逝的时间计算出终止时间。</p><p>读入两个数字，第一个数字以这样的四位数字表示当前时间，第二个数字表示分钟数，计算当前时间经过那么多分钟后是几点，结果也表示为四位数字。当小时为个位数时，没有前导的零，例如 5 点 30 分表示为 <code>530</code>；0 点 30 分表示为 <code>030</code>。注意，第二个数字表示的分钟数可能超过 60，也可能是负数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出 2 个整数，分别是四位数字表示的起始时间、以及流逝的分钟数，其间以空格分隔。注意：在起始时间中，当小时为个位数时，没有前导的零，即 5 点 30 分表示为 <code>530</code>；0 点 30 分表示为 <code>030</code>。流逝的分钟数可能超过 60，也可能是负数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出不多于四位数字表示的终止时间，当小时为个位数时，没有前导的零。题目保证起始时间和终止时间在同一天内。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1120</span> <span class="number">110</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1310</span></span><br></pre></td></tr></table></figure><p><strong>鸣谢燕山大学穆运峰老师、用户任钰补充数据！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大佬的思路确实有点意思，我的思路太直了</span></span><br><span class="line"><span class="comment">//大佬是先算一共有多少分钟，再转换回去，%03d是为了防止出现0点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur,pass;</span><br><span class="line">    cin &gt;&gt; cur &gt;&gt; pass;</span><br><span class="line">    cur = <span class="number">60</span> * (cur / <span class="number">100</span>) + cur % <span class="number">100</span> + pass;</span><br><span class="line">    cur = <span class="number">100</span> * (cur / <span class="number">60</span>) + cur % <span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%03d&quot;</span>,cur);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-5-凯撒密码-20-分"><a href="#7-5-凯撒密码-20-分" class="headerlink" title="7-5 凯撒密码 (20 分)"></a><strong>7-5 凯撒密码 (20 分)</strong></h2><p>为了防止信息被别人轻易窃取，需要把电码明文通过加密方式变换成为密文。输入一个以回车符为结束标志的字符串（少于80个字符），再输入一个整数offset，用凯撒密码将其加密后输出。恺撒密码是一种简单的替换加密技术，将明文中的所有字母都在字母表上偏移offset位后被替换成密文，当offset大于零时，表示向后偏移；当offset小于零时，表示向前偏移。</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第一行给出一个以回车结束的非空字符串（少于80个字符）；第二行输入一个整数offset。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出加密后的结果字符串。</p><h3 id="输入样例1-1"><a href="#输入样例1-1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello Hangzhou</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1-1"><a href="#输出样例1-1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jgnnq Jcpibjqw</span><br></pre></td></tr></table></figure><h3 id="输入样例2-1"><a href="#输入样例2-1" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=x+y</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2-1"><a href="#输出样例2-1" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z=w+x</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 重点是计算这个k，首先k先对26取余，转化成[-25,25]范围，然后再加26取余，这样就转化到了[0,25]的范围 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    k = (k % <span class="number">26</span> + <span class="number">26</span>) % <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            s[i] = <span class="string">&#x27;a&#x27;</span> + (s[i] - <span class="string">&#x27;a&#x27;</span> + k) % <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            s[i] = <span class="string">&#x27;A&#x27;</span> + (s[i] - <span class="string">&#x27;A&#x27;</span> + k ) % <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-7-取模运算-15-分"><a href="#7-7-取模运算-15-分" class="headerlink" title="7-7 取模运算 (15 分)"></a><strong>7-7 取模运算 (15 分)</strong></h2><p>给定两个数<em>a</em>,<em>b</em>,请输出<em>a</em> <em>m<strong>o</strong>d</em> <em>b</em></p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>输入仅有一行，每行包括两个数<em>a</em>(1≤<em>a</em>≤10^10^6),<em>b</em>(1≤<em>b</em>≤10^9).</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>输出 <em>a</em> <em>m<strong>o</strong>d</em> <em>b</em> 的值</p><h3 id="Sample-Input1"><a href="#Sample-Input1" class="headerlink" title="Sample Input1:"></a>Sample Input1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output1"><a href="#Sample-Output1" class="headerlink" title="Sample Output1:"></a>Sample Output1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Input2"><a href="#Sample-Input2" class="headerlink" title="Sample Input2:"></a>Sample Input2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output2"><a href="#Sample-Output2" class="headerlink" title="Sample Output2:"></a>Sample Output2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Input3"><a href="#Sample-Input3" class="headerlink" title="Sample Input3:"></a>Sample Input3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33333333333333333333333333333333</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output3"><a href="#Sample-Output3" class="headerlink" title="Sample Output3:"></a>Sample Output3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为只需要得到余数，所以只需要把高精度减法进行简化，只求余数即可</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod,res = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> &amp;c : s)</span><br><span class="line">        res = (res * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>) % mod;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-9-解密邀请码-20-分"><a href="#7-9-解密邀请码-20-分" class="headerlink" title="7-9 解密邀请码 (20 分)"></a><strong>7-9 解密邀请码 (20 分)</strong></h2><p>HBU开设了一门全网独一份的新课程，因此大家迫不及待的等待选课的到来以求选到该课程，但是在选择前需要输入课程的邀请码，任何申请该课程的同学都会收到一个神秘字符串，为了保障字符串的安全性以及自己的课程不被窃取，课程老师发明了一种压缩算法对邀请码中重复的部分进行了压缩，对于字符串中连续的m个相同字符串S将会压缩为<a href="m%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%941%3C=m%3C=200"><em>m</em>∣<em>S</em></a>，例如字符串HBUHBUHBU将会被压缩为[3∣<em>H<strong>B</strong>U</em>]，现在同学们收到了课程的邀请码字，你能帮助他们进行解密么？</p><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入一个字符串<em>S</em>(∣<em>S</em>∣≤50)，<em>S</em>展开后可能含有大写字母、小写字母与数字, 题目保证输入的字符串合法以及展开后的字符串长度不超过106且展开后的邀请码中不含∣</p><h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式:"></a>输出格式:</h3><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HB[<span class="number">3</span>|U[<span class="number">2</span>|HB]]U</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HBUHBHBUHBHBUHBHBU</span><br></pre></td></tr></table></figure><p>说明 HB[3|U[2|HB]]U−&gt;HB[3|UHBHB]U−&gt; HBUHBHBUHBHBUHBHBU</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这道题倒是比大佬的算法运算速度快，大佬的是用栈而且还是递归求解，我用的字符串的截取，从右向左扫描，最先扫描到的[,就是最内层的，然后截取字符串，按规则进行解密，然后重复上述过程，直到扫描不到[*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos1 = s.<span class="built_in">size</span>() - <span class="number">1</span>, pos2 = pos1, pos3 = pos1;</span><br><span class="line">        <span class="keyword">while</span>(pos1 &gt;= <span class="number">0</span> &amp;&amp; s[pos1] != <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[pos1] == <span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">                pos2 = pos1;</span><br><span class="line">            <span class="keyword">if</span>(s[pos1] == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                pos3 = pos1;</span><br><span class="line">            pos1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[pos1] == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">            string ptr = s.<span class="built_in">substr</span>(pos2 + <span class="number">1</span>, pos3 - pos2 - <span class="number">1</span>);</span><br><span class="line">            string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(pos1 + <span class="number">1</span>, pos2 - pos1 - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">                res += ptr;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos1, pos3 - pos1 + <span class="number">1</span>);</span><br><span class="line">            s.<span class="built_in">insert</span>(pos1, res);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-10-这真的算得出来吗？-20-分"><a href="#7-10-这真的算得出来吗？-20-分" class="headerlink" title="7-10 这真的算得出来吗？ (20 分)"></a><strong>7-10 这真的算得出来吗？ (20 分)</strong></h2><p>给定一个值<em>X</em>, 求出 </p><p><svg xmlns="http://www.w3.org/2000/svg" width="11.533ex" height="4.07ex" viewbox="0 -1149.5 5097.4 1799" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-2-TEX-SO-2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"/><path id="MJX-2-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-2-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/><path id="MJX-2-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-2-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-2-TEX-LO-230A" d="M224 -649V1150H275V-598H511V-649H224Z"/><path id="MJX-2-TEX-I-1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/><path id="MJX-2-TEX-LO-230B" d="M252 -598V1150H303V-649H16V-598H252Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mstyle"><g data-mml-node="munderover"><g data-mml-node="mo"><use xlink:href="#MJX-2-TEX-SO-2211"/></g><g data-mml-node="TeXAtom" transform="translate(1056, 477.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msup"><g data-mml-node="mn"><use xlink:href="#MJX-2-TEX-N-31"/><use xlink:href="#MJX-2-TEX-N-30" transform="translate(500, 0)"/></g><g data-mml-node="TeXAtom" transform="translate(1000, 393.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use xlink:href="#MJX-2-TEX-N-31"/><use xlink:href="#MJX-2-TEX-N-30" transform="translate(500, 0)"/><use xlink:href="#MJX-2-TEX-N-30" transform="translate(1000, 0)"/></g></g></g></g><g data-mml-node="TeXAtom" transform="translate(1056, -285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D458"/></g><g data-mml-node="mo" transform="translate(521, 0)"><use xlink:href="#MJX-2-TEX-N-3D"/></g><g data-mml-node="mn" transform="translate(1299, 0)"><use xlink:href="#MJX-2-TEX-N-30"/></g></g></g><g data-mml-node="mrow" transform="translate(2598.5, 0)"><g data-mml-node="mo"><use xlink:href="#MJX-2-TEX-LO-230A"/></g><g data-mml-node="mfrac" transform="translate(528, 0)"><g data-mml-node="mi" transform="translate(420.3, 394) scale(0.707)"><use xlink:href="#MJX-2-TEX-I-1D44B"/></g><g data-mml-node="msup" transform="translate(220, -464.9) scale(0.707)"><g data-mml-node="mn"><use xlink:href="#MJX-2-TEX-N-31"/><use xlink:href="#MJX-2-TEX-N-30" transform="translate(500, 0)"/></g><g data-mml-node="TeXAtom" transform="translate(1000, 393.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D458"/></g></g></g><rect width="1203" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1971, 0)"><use xlink:href="#MJX-2-TEX-LO-230B"/></g></g></g></g></g></g></svg></p><p>的值。</p><h3 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行输入一个整数<em>X</em>(1≤<em>X</em>≤10^100000).</p><h3 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出答案。</p><h3 id="输入样例1-2"><a href="#输入样例1-2" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1225</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1-2"><a href="#输出样例1-2" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1360</span></span><br></pre></td></tr></table></figure><p>解释：1360 = 1225 + 122 + 12 + 1 + 0 + 0 + … + 0</p><h3 id="输入样例2-2"><a href="#输入样例2-2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">99999</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2-2"><a href="#输出样例2-2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">111105</span></span><br></pre></td></tr></table></figure><h3 id="输入样例3"><a href="#输入样例3" class="headerlink" title="输入样例3:"></a>输入样例3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">314159265358979323846264338327950288419716939937510</span></span><br></pre></td></tr></table></figure><h3 id="输出样例3"><a href="#输出样例3" class="headerlink" title="输出样例3:"></a>输出样例3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">349065850398865915384738153697722542688574377708317</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*写这道题是真艰辛，原本开始位数，以为是高精度运算，结果一顿超时，后面优化着优化着，慢慢接近前缀和的形式，然后写出了前缀和，AC了，但是大佬的算法实在是太简洁了*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,cr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算所有位数的总和，即前缀和的最后一位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> &amp;c : s)</span><br><span class="line">        sum += c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">/*然后开始进行计算，余数单独存储，sum值不断减本位的值进行更新，用一个变量代替了一个n个大小的前缀和数组，实在是高*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        s[i] = (sum + cr) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        cr = (sum + cr) / <span class="number">10</span>;</span><br><span class="line">        sum -= t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后判断是不是要进位</span></span><br><span class="line">    cout &lt;&lt; (cr ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;&quot;</span>) &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 训练营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1480 A/B Problem</title>
      <link href="/2022/01/08/P1480%20A%C3%B7B%20Problem/"/>
      <url>/2022/01/08/P1480%20A%C3%B7B%20Problem/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数 a,b，输出它们的商。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>两行，第一行是被除数，第二行是除数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，商的整数部分。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>0≤a≤10^5000，1≤b≤10^9。</p><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想：</strong></h2><p>​    看题干就是高精度。</p><p>​    高精度乘法需要考虑的问题：</p><ul><li>经典倒序存储，但是这次是从高位向低位进行除法计算，存储余数</li><li>余数加到下一位时需要先乘10再进行运算</li><li>最后处理前导0，和减法一样，最后至少要留下一位，比如0 / 2 = 0</li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp;a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> &amp;r)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">res</span><span class="params">(a.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() <span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        res[i] = (a[i] + r * <span class="number">10</span>) / b;</span><br><span class="line">        r= (a[i] + r * <span class="number">10</span>) % b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(res.<span class="built_in">back</span>() == <span class="number">0</span> &amp;&amp; res.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">toVector</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">res</span><span class="params">(s.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        res[pos++] =  s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string str1;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b,r;</span><br><span class="line">    cin &gt;&gt; str1 &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; a = <span class="built_in">toVector</span>(str1);</span><br><span class="line">    vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; c = <span class="built_in">div</span>(a,b,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        cout &lt;&lt; c[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种高精度除低精度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r 存储余数</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">( vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r )</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- ) &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>( r / b );</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// C存储由高位到低位</span></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> ( C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span> ) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1303 A*B Problem</title>
      <link href="/2022/01/08/P1303%20A%C3%97B%20Problem/"/>
      <url>/2022/01/08/P1303%20A%C3%97B%20Problem/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求两数的积。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>两行，两个整数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数表示乘积。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>每个数字不超过 10^2000 ，需用高精。</p><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想：</strong></h2><p>​    看题干就是高精度。</p><p>​    高精度乘法需要考虑的问题：</p><ul><li>经典倒序存储，从低位向高位进行乘法计算，更新进位</li><li>考虑到空间复杂度，我们可以一边乘一边加，不需要算完所有的中间项，最后一起相加</li><li>进位溢出问题，a*b的最大位数为a的位数+b的位数，比如99* 99= 9801，我们可以先往多了开，最后一起处理前导0</li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a,vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(a.size() + b.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">            res[i + j] += a[i] * b[j];</span><br><span class="line">            res[i + j + <span class="number">1</span>] += res[i + j] / <span class="number">10</span>;</span><br><span class="line">            res[i + j] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(res.<span class="built_in">back</span>() == <span class="number">0</span> &amp;&amp; res.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">toVector</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(s.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        res[pos++] =  s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string str1,str2;</span><br><span class="line">    cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a = <span class="built_in">toVector</span>(str1);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; b = <span class="built_in">toVector</span>(str2);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c = <span class="built_in">mul</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        cout &lt;&lt; c[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是高精度乘高精度，下面这个是高精度*低精度（不过可以同样用上面的模板算）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">( vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b )</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>( t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span> ) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2142 高精度减法</title>
      <link href="/2022/01/08/P2142%20%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/"/>
      <url>/2022/01/08/P2142%20%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>高精度减法。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>两个整数 a,b（第二个可能比第一个大）。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>结果（是负数要输出负号）。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><ul><li>20% 数据 a,b 在 long long 范围内；</li><li>100% 数据0&lt;a,b≤10^10086。</li></ul><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想：</strong></h2><p>​    看题干就是高精度。</p><p>​    高精度减法需要考虑的问题：</p><ul><li>结果为负数，我们无法用数组存储负号，我们指定a大于等于b，我们先判断a,b的大小，a小于b，那么a和b交换，一旦交换就输出一个负号<ul><li>位数不同时，谁的位数大谁大</li><li>位数相同时，从高位向低位比较，直到遇见不同位</li><li>如果完全相同，则a和b相等</li></ul></li><li>和加法一样，我们采取倒序存储，从低位向高位进行减法计算，更新借位</li><li>处理前导0，但这里需要注意，如果a和b相等，相减的结果数组全为0,但我们需要留下一位，所以删除的时候还需要判断c.size() &gt; 1</li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a,vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>())    <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span>(a[i] != b[i])    <span class="keyword">return</span> a[i] &gt; b[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a,vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">cmp</span>(a,b))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(a.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    b.<span class="built_in">resize</span>(a.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        c[i] += a[i] - b[i];</span><br><span class="line">        <span class="keyword">if</span>(c[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            c[i] += <span class="number">10</span>;</span><br><span class="line">            c[i + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">back</span>() == <span class="number">0</span> &amp;&amp; c.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        c.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">toVector</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(s.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        res[pos++] =  s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string str1,str2;</span><br><span class="line">    cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a = <span class="built_in">toVector</span>(str1);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; b = <span class="built_in">toVector</span>(str2);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c = <span class="built_in">sub</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        cout &lt;&lt; c[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sub的另一种写法（当然有很多中写法）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">( vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B )</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="comment">//  t表示借位，为0或1</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++ ) &#123;</span><br><span class="line">        t  = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> ( i &lt; B.<span class="built_in">size</span>() ) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>( (t+<span class="number">10</span>) % <span class="number">10</span> )</span><br><span class="line">        <span class="keyword">if</span>( t &lt; <span class="number">0</span> ) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉前导0</span></span><br><span class="line">    <span class="keyword">while</span> ( C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span> ) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>出错记录</title>
      <link href="/2022/01/07/%E5%87%BA%E9%94%99%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/01/07/%E5%87%BA%E9%94%99%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h4 id="1-建立堆"><a href="#1-建立堆" class="headerlink" title="1.建立堆"></a>1.建立堆</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++heapsize] = x;  <span class="comment">//先++，再赋值，所以是前缀++</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = heapsize; heap[i] &lt; heap[i / <span class="number">2</span>]; i /= <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">swap</span>(heap[i], heap[i / <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对于堆来说，和二叉排序树不一样，必须查找两个赋值，与其递归求解，还不入</span></span><br><span class="line"><span class="comment">顺序查找，哎，当时直接想到了递归，回头想想，还是顺序查找好*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= heapsize; ++i)</span><br><span class="line">        <span class="keyword">if</span>(heap[i] == x)    <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 随便写点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 其他类型转字符串</title>
      <link href="/2022/01/07/C++%20%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/01/07/C++%20%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><pre><code>#### 1.to_string()</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1234</span>;</span><br><span class="line">string b = <span class="built_in">to_string</span>(a);</span><br></pre></td></tr></table></figure><h4 id="2-字符流stringstream"><a href="#2-字符流stringstream" class="headerlink" title="2.字符流stringstream"></a>2.字符流stringstream</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1234</span>;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss &lt;&lt; a;</span><br><span class="line">string b = ss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure><p>如果转多个加上str(“”)；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>,c = <span class="number">456</span>;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss &lt;&lt; a;</span><br><span class="line">string b = ss.<span class="built_in">str</span>();</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">ss.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">ss &lt;&lt; c;</span><br><span class="line">cout &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1601 A+B Problem（高精）</title>
      <link href="/2022/01/07/P1601%20A+B%20Problem%EF%BC%88%E9%AB%98%E7%B2%BE%EF%BC%89/"/>
      <url>/2022/01/07/P1601%20A+B%20Problem%EF%BC%88%E9%AB%98%E7%B2%BE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>高精度加法，相当于a+b problem，<strong>不用考虑负数</strong>.</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>分两行输入。a,b≤10^500</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出只有一行，代表a+b的值</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输入 #2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1001</span></span><br><span class="line"><span class="number">9099</span></span><br></pre></td></tr></table></figure><p><strong>输出 #2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10100</span></span><br></pre></td></tr></table></figure><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想：</strong></h2><p>​    如果数据范围是10^500次方，显然即使是long long也得爆，所以有两种方法存储，一种是数组，一种是字符串，然后通过遍历模拟运算。</p><p>​    然后考虑计算会出现的问题</p><ul><li>首先，如果a和b位数不同时，根据竖式，低位要和低位对齐，但不管是字符串还是数组都是从高位开始依次读取，遍历的话，如果使用同一个指针进行遍历会出现以下情况</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"> + <span class="number">1</span> <span class="number">2</span></span><br><span class="line"> _________</span><br><span class="line"> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>显然这是不对的，所以按常规思路的话，使用两个指针分别遍历a和b，但显然挺复杂。</p><ul><li><p>其次是进位问题，第i位的值 = (a的第i位的值 + b的第i位的值 + 第i- 1进位) %10,第i位的进位 = (a的第i位的值 + b的第i位的值 + 第i- 1进位) /10</p></li><li><p>最后是最高位的进位，显然如果最高位需要进位的话，我们需要动态增加空间来存储最高位的进位</p><p>综合前面几点，我们可以采取倒序存储，即从低位到高位存储，然后如果位数不同可以向后补0，同时如果最高位进位，也比较好补位。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"> + <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> _________</span><br><span class="line"> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​    最后再讨论是用数组存还是字符串存，显然用数组存进行数值运算的话要比字符串要快，所以采用数组存。</p><p>总体要做的操作：</p><ul><li>首先读取两个字符串，然后把两个字符串倒序存入两个数组中，数组需要初始化为0（提前补0）</li><li>然后进行模拟运算，res可以开到a和b的最大位数，但可以把res的数组多开一位（计算方便），可以把进位直接赋值给下一位，然后计算下一位时，可以直接在已经计算进位的基础上加上a和b对应位置的值</li><li>最后，判断res的最后一位是否为0，为0的话删除，不为0的话，说明最高位有进位，不需要删除</li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a,vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(a.size() + <span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        res[i] += a[i] + b[i];</span><br><span class="line">        res[i + <span class="number">1</span>] = res[i] / <span class="number">10</span>;</span><br><span class="line">        res[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!res[res.<span class="built_in">size</span>() - <span class="number">1</span>])    res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string str1,str2;</span><br><span class="line">    cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">    <span class="keyword">int</span> maxsize = <span class="built_in">max</span>(str1.<span class="built_in">size</span>(),str2.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(maxsize,<span class="number">0</span>)</span>,<span class="title">b</span><span class="params">(maxsize,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = str1.<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        a[pos++] = str1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = str2.<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        b[pos++] = str2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res = <span class="built_in">add</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        cout &lt;&lt; res[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2574 XOR的艺术</title>
      <link href="/2022/01/06/P2574%20XOR%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
      <url>/2022/01/06/P2574%20XOR%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中，他发现，这个游戏的伤害计算有一个规律，规律如下</p><ol><li>拥有一个伤害串，是一个长度为 n 的只含字符 <code>0</code> 和字符 <code>1</code> 的字符串。规定这个字符串的首字符是第一个字符，即下标从 11 开始。</li><li>给定一个范围[l, r]，伤害为伤害串的这个范围内中字符 <code>1</code> 的个数</li><li>会修改伤害串中的数值，修改的方法是把 [l, r] 中所有原来的字符 <code>0</code> 变成 <code>1</code>，将 <code>1</code> 变成 <code>0</code>。</li></ol><p>AKN 想知道一些时刻的伤害，请你帮助他求出这个伤害。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行有两个用空格隔开的整数，分别表示伤害串的长度 n，和操作的个数 m。</p><p>输入第二行是一个长度为 n的字符串 S，代表伤害串。</p><p>第 3 到第 (m + 2) 行，每行有三个用空格隔开的整数 op,l,r。代表第 i 次操作的方式和区间，规则是：</p><ul><li>若 op = 0，则表示将伤害串的 [l, r] 区间内的 <code>0</code> 变成 <code>1</code>，<code>1</code> 变成 <code>0</code>。</li><li>若 op = 1，则表示询问伤害串的 [l, r] 区间内有多少个字符 <code>1</code>。</li></ul><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每次询问，输出一行一个整数，代表区间内 <code>1</code> 的个数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">6</span></span><br><span class="line"><span class="number">1011101001</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><h4 id="样例输入输出-1-解释"><a href="#样例输入输出-1-解释" class="headerlink" title="样例输入输出 1 解释"></a>样例输入输出 1 解释</h4><p>原伤害串为 <code>1011101001</code>。</p><p>对于第一次操作，改变 [2, 4] 的字符，伤害串变为 <code>1100101001</code>。</p><p>对于第二次操作，查询 [1, 5] 内 <code>1</code> 的个数，共有 3 个。</p><p>对于第三次操作，改变 [3, 7] 的字符，伤害串变为 <code>1111010001</code>。</p><p>对于第四次操作，查询 [1, 10] 内 <code>1</code> 的个数，共有 6 个。</p><p>对于第五次操作，改变 [1, 4] 的字符，伤害串变为 <code>0000010001</code>。</p><p>对于第六次操作，查询 [2, 6] 内 <code>1</code> 的个数，共有 1 个。</p><h4 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h4><p>对于 10% 的数据，保证 n,m≤10。</p><p>另有 30% 的数据，保证 n,m≤2×10^3。</p><p>对于 100% 的数据，保证 2≤n,m≤2×10^5，0≤op≤1，1≤l≤r≤n，S 中只含字符 <code>0</code> 和字符 <code>1</code>。</p><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想：</strong></h2><p>​    采用线段树，然后因为字符串只有0和1，所以一个子串中有多少个1，直接这个子串的0和1相加的总和就是1的个数，所以线段树维护的是区间和。</p><p>​    当op = 0时，0和1相互变化，所以新的区间和变为区间长度-原区间和，可以用懒标记下传。经过两次0和1的相互变化相当于没有变化。所以lazytag对1异或即可，因为0和1异或是1,1和1异或是0，可以通过位运算进行懒标记0和1的变化。</p><p>​    还有用了ios::sync_with_stdio(false);之后确实快，原本900+ms,缩短到了600+ms。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> pre,lazytag;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn + <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        t[p].pre = s[l] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t[p].lazytag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> ,l ,mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">    t[p].pre = t[p &lt;&lt; <span class="number">1</span>].pre + t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].lazytag)&#123;</span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span>].pre = (t[p &lt;&lt; <span class="number">1</span>].r - t[p &lt;&lt; <span class="number">1</span>].l + <span class="number">1</span>) - t[p &lt;&lt; <span class="number">1</span>].pre;</span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].pre = (t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].r - t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l + <span class="number">1</span>) - t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].pre;</span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span>].lazytag ^= <span class="number">1</span>;</span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazytag ^= <span class="number">1</span>;</span><br><span class="line">        t[p].lazytag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre = (t[p].r - t[p].l + <span class="number">1</span>) - t[p].pre;</span><br><span class="line">        t[p].lazytag ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change</span>(p &lt;&lt; <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)      <span class="built_in">change</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,x,y);</span><br><span class="line">    t[p].pre = t[p &lt;&lt; <span class="number">1</span>].pre + t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)  <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    ans += <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)      ans += <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag,x,y;</span><br><span class="line">        cin &gt;&gt; flag &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(!flag)    <span class="built_in">change</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        <span class="keyword">else</span>        cout &lt;&lt; <span class="built_in">ask</span>(<span class="number">1</span>,x,y) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高程序效率的位运算</title>
      <link href="/2022/01/05/%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E6%95%88%E7%8E%87%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2022/01/05/%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E6%95%88%E7%8E%87%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><ul><li>如果树的父亲结点为n,则左孩子结点为n &lt;&lt; 1,右孩子为 n &lt;&lt; 1 | 1;</li><li>二分查找mid = (left + right) &gt;&gt; 1;</li><li>还有自己写scanf函数读取整数值来提高运行效率（tql）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3373 【模板】线段树 2</title>
      <link href="/2022/01/05/P3373%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%202/"/>
      <url>/2022/01/05/P3373%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%202/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面三种操作：</p><ul><li>将某区间每一个数乘上 x</li><li>将某区间每一个数加上 x</li><li>求出某区间每一个数的和</li></ul><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含三个整数 n,m,p，分别表示该数列数字的个数、操作的总个数和模数。</p><p>第二行包含 n个用空格分隔的整数，其中第 i个数字表示数列第 i项的初始值。</p><p>接下来 m 行每行包含若干个整数，表示一个操作，具体如下：</p><p>操作 1： 格式：<code>1 x y k</code> 含义：将区间 [x,y][<em>x</em>,<em>y</em>] 内每个数乘上 k</p><p>操作 2： 格式：<code>2 x y k</code> 含义：将区间 [x,y][<em>x</em>,<em>y</em>] 内每个数加上 k</p><p>操作 3： 格式：<code>3 x y</code> 含义：输出区间 [x,y][<em>x</em>,<em>y</em>] 内每个数的和对 p 取模所得的结果</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 3 的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">38</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>【数据范围】</p><p>对于 30% 的数据：n≤8，m≤10<br>对于 70% 的数据：n≤10^3，m≤10^4<br>对于 100% 的数据：n≤10^5，m≤10^5</p><p>除样例外，p = 571373</p><p>（数据已经过加强^_^）</p><p>样例说明：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/2255.png" alt="img"></p><p>故输出应为 17、2（40 mod 38=2 ）</p><h2 id="锹黑板："><a href="#锹黑板：" class="headerlink" title="锹黑板："></a><strong>锹黑板：</strong></h2><p>首先我们回忆一下线段树１的加法标记<strong>他其实是打在父亲节点上的标记儿子加多少的</strong>，打完标记的同时父亲的sum其实已经加上了add * len</p><p>那我们回到这道题我们发现题目要求在加数的同时<strong>还要区间乘</strong></p><p>比如现在有3个数1,2,3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">1</span>~<span class="number">3</span>(<span class="number">1</span>)</span><br><span class="line">         /     \</span><br><span class="line">    <span class="number">1</span>~<span class="number">2</span>(<span class="number">2</span>)      <span class="number">3</span>(<span class="number">3</span>)</span><br><span class="line">   /      \</span><br><span class="line"><span class="number">1</span>(<span class="number">4</span>)      <span class="number">2</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>我们先给1~3加上2</strong>,画个小小小小的图，<strong>节点后面的括号代表节点下标</strong></p><p>所以</p><p>t[1].add += 2;</p><p>t[1].sum+=( (3 - 1) + 1) * 2;</p><p><strong>我们再给1~3乘上3</strong></p><p>所以</p><p>t[1].mu *= 3;</p><p><strong>我们再给1~3加上4，那是不是先加再乘</strong></p><p>t[1].add += 4;</p><p>obviously我们发现不能先加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">操作<span class="number">2</span>之后的式子是:</span><br><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>)*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>)*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>)*<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>如果直接加:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">式子是:</span><br><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>+<span class="number">4</span>)*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>+<span class="number">4</span>)*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>+<span class="number">4</span>)*<span class="number">3</span>;</span><br><span class="line">   =(a[<span class="number">1</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>*<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>我们发现这和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>+(a[<span class="number">2</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>+(a[<span class="number">3</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>并不等价</p><p>而要等价必须这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>+<span class="number">4</span>/<span class="number">3</span>)*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>+<span class="number">4</span>/<span class="number">3</span>)*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>+<span class="number">4</span>/<span class="number">3</span>)*<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><strong>我们发现这样就成了实数运算了,还有可能除成无限小数</strong></p><p>而先乘后加:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=(a[<span class="number">1</span>]*<span class="number">3</span>+<span class="number">2</span>*<span class="number">3</span>+<span class="number">4</span>)+(a[<span class="number">2</span>]*<span class="number">3</span>+<span class="number">2</span>*<span class="number">3</span>+<span class="number">4</span>)+(a[<span class="number">3</span>]*<span class="number">3</span>+<span class="number">2</span>*<span class="number">3</span>+<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"><span class="keyword">int</span> a[maxn + <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre,add,mul;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn + <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;t[p].r = r;</span><br><span class="line">    t[p].add = <span class="number">0</span>;t[p].mul = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        t[p].pre = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> , l , mid);</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">    t[p].pre = (t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 根据先乘后加的优先度，儿子的值 = 此刻儿子的值*爸爸乘法的lazytag +儿子的区间长度*爸爸加法的lazytag */</span></span><br><span class="line">    t[p * <span class="number">2</span>].pre = (t[p * <span class="number">2</span>].pre * t[p].mul + t[p].add * (t[p * <span class="number">2</span>].r - t[p * <span class="number">2</span>].l + <span class="number">1</span>)) % mod;</span><br><span class="line">    t[p * <span class="number">2</span> + <span class="number">1</span>].pre = (t[p * <span class="number">2</span> + <span class="number">1</span>].pre * t[p].mul + t[p].add * (t[p * <span class="number">2</span> + <span class="number">1</span>].r - t[p * <span class="number">2</span> + <span class="number">1</span>].l + <span class="number">1</span>)) % mod;</span><br><span class="line">    <span class="comment">//维护lazytag</span></span><br><span class="line">    t[p * <span class="number">2</span>].mul = (t[p * <span class="number">2</span>].mul * t[p].mul) % mod;</span><br><span class="line">    t[p * <span class="number">2</span> + <span class="number">1</span>].mul = (t[p * <span class="number">2</span> + <span class="number">1</span>].mul * t[p].mul) % mod;</span><br><span class="line">    t[p * <span class="number">2</span>].add = (t[p * <span class="number">2</span>].add * t[p].mul + t[p].add) % mod;</span><br><span class="line">    t[p * <span class="number">2</span> + <span class="number">1</span>].add = (t[p * <span class="number">2</span> + <span class="number">1</span>].add * t[p].mul + t[p].add) % mod;</span><br><span class="line">    <span class="comment">//父节点的lazytag初始哈</span></span><br><span class="line">    t[p].mul = <span class="number">1</span>;</span><br><span class="line">    t[p].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="comment">//被覆盖的话</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre = (t[p].pre * z) % mod;</span><br><span class="line">        t[p].mul = (t[p].mul * z) % mod;</span><br><span class="line">        t[p].add = (t[p].add * z) % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有被覆盖，则下传lazytag</span></span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change1</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change1</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    t[p].pre = (t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加法，和乘法同理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change2</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre = (t[p].pre + (<span class="keyword">long</span> <span class="keyword">long</span>)z * (t[p].r - t[p].l + <span class="number">1</span>)) % mod;</span><br><span class="line">        t[p].add = (t[p].add + z) % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change2</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change2</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    t[p].pre = (t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)  <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    ans += <span class="built_in">ask</span>(p * <span class="number">2</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       ans += <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> q,x,y,k;</span><br><span class="line">        cin &gt;&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            <span class="built_in">change1</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(q == <span class="number">2</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            <span class="built_in">change2</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">ask</span>(<span class="number">1</span>,x,y) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3372 【模板】线段树 1</title>
      <link href="/2022/01/05/P3372%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%201/"/>
      <url>/2022/01/05/P3372%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%201/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li>将某区间每一个数加上 k。</li><li>求出某区间每一个数的和。</li></ol><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 n, m，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 n个用空格分隔的整数，其中第 i 个数字表示数列第 i项的初始值。</p><p>接下来 m 行每行包含 3或 4 个整数，表示一个操作，具体如下：</p><ol><li><code>1 x y k</code>：将区间 [x, y][<em>x</em>,<em>y</em>] 内每个数加上 k。</li><li><code>2 x y</code>：输出区间 [x, y][<em>x</em>,<em>y</em>] 内每个数的和。</li></ol><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 2 的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>对于 30% 的数据：n≤8，m≤10。<br>对于 70% 的数据：n≤10^3，m≤10^4。<br>对于 100% 的数据：1≤n,m≤10^5。</p><p>保证任意时刻数列中任意元素的和在 [−2^63,2^63) 内。</p><p><strong>【样例解释】</strong></p><p><img src="https://cdn.luogu.com.cn/upload/pic/2251.png" alt="img"></p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    看题干就知道线段树，线段树可以维护区间加，区间查找等操作，其余还有区间乘，区间最大值，甚至最大子段和等操作。</p><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h4 id="1-线段树的存储"><a href="#1-线段树的存储" class="headerlink" title="1.线段树的存储"></a>1.线段树的存储</h4><p>采用结构体存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn + <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre,add;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn + <span class="number">2</span>];</span><br></pre></td></tr></table></figure><h4 id="2-建树"><a href="#2-建树" class="headerlink" title="2.建树"></a>2.建树</h4><p>所谓建树，就是把数组a[1 - n]放到线段树中</p><p>在线段树中，对于一个区间(编号为p),它的左儿子为2 * p,右儿子为2 * p + 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;t[p].r = r; <span class="comment">//存储该节点维护的区间范围</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;<span class="comment">//如果区间只有一个数，则直接赋值</span></span><br><span class="line">        t[p].pre = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则维护的值等于左儿子加右儿子</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> , l , mid);</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-懒标记"><a href="#3-懒标记" class="headerlink" title="3.懒标记"></a>3.懒标记</h4><p>​    懒标记的精髓就是打标计和下传操作，由于要做的操作是区间加一个数，所以不妨在区间进行修改时为该区间打上一个标记，就不必再修改它的儿子所维护的区间，等到要是用该节结点儿子维护的值，再将懒标记下放即可，可以省下很多时间，对于每次区间修改和查询，将懒标记下传，可以节省很多时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add)&#123; <span class="comment">//如果懒标记不为0，就将其下传，修改左右儿子维护的值</span></span><br><span class="line">        t[p * <span class="number">2</span>].pre += t[p].add * (t[p * <span class="number">2</span>].r - t[p * <span class="number">2</span>].l + <span class="number">1</span>);</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].pre += t[p].add * (t[p * <span class="number">2</span> + <span class="number">1</span>].r - t[p * <span class="number">2</span> + <span class="number">1</span>].l + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//为该结点的左右儿子打上标记</span></span><br><span class="line">        t[p * <span class="number">2</span>].add += t[p].add;</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].add += t[p].add;</span><br><span class="line">        <span class="comment">//下传之后将该结点的懒标记清0</span></span><br><span class="line">        t[p].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-区间修改"><a href="#4-区间修改" class="headerlink" title="4.区间修改"></a>4.区间修改</h4><p>​    考虑到将一个区间加上一个数，我们可以从根结点不断向下查找，当发现我们要修改的区间覆盖了当前结点时，我们就把这个区间修改，并打上懒标记（由于懒标记的存在，我们就不必再修改它的儿子结点），否则下传懒标记，继续向下找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123; <span class="comment">//被覆盖的话，就对其进行修改</span></span><br><span class="line">        t[p].pre += (<span class="keyword">long</span> <span class="keyword">long</span>)z * (t[p].r - t[p].l + <span class="number">1</span>);</span><br><span class="line">        t[p].add += z;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*如果发现没有被覆盖，那么继续向下找，考虑儿子所维护的区间可能因为懒标记的存在而没有修改，因此懒标记下放*/</span></span><br><span class="line">    <span class="built_in">spread</span>(p); </span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果要修改的区间覆盖了左儿子，就修改左儿子，右儿子同理</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    <span class="comment">//最终维护的值等于左儿子值加右儿子值</span></span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-区间查询"><a href="#5-区间查询" class="headerlink" title="5.区间查询"></a>5.区间查询</h4><p>​    考虑询问一个区间的和，依旧是从根结点向下查找，当发现结点被覆盖时，就返回维护的值，否则下传懒标记，查询左右儿子，累加答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果被覆盖，就返回维护的值</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)  <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    <span class="comment">//下传懒标记，并查询左右儿子</span></span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    ans += <span class="built_in">ask</span>(p * <span class="number">2</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       ans += <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn + <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre,add;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn + <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        t[p].pre = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> , l , mid);</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add)&#123;</span><br><span class="line">        t[p * <span class="number">2</span>].pre += t[p].add * (t[p * <span class="number">2</span>].r - t[p * <span class="number">2</span>].l + <span class="number">1</span>);</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].pre += t[p].add * (t[p * <span class="number">2</span> + <span class="number">1</span>].r - t[p * <span class="number">2</span> + <span class="number">1</span>].l + <span class="number">1</span>);</span><br><span class="line">        t[p * <span class="number">2</span>].add += t[p].add;</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].add += t[p].add;</span><br><span class="line">        t[p].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre += (<span class="keyword">long</span> <span class="keyword">long</span>)z * (t[p].r - t[p].l + <span class="number">1</span>);</span><br><span class="line">        t[p].add += z;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)  <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    ans += <span class="built_in">ask</span>(p * <span class="number">2</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       ans += <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> q,x,y,z;</span><br><span class="line">        cin &gt;&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">ask</span>(<span class="number">1</span>,x,y) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. 接雨水</title>
      <link href="/2022/01/05/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2022/01/05/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><blockquote><p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：height = [4,2,0,3,2,5]<br>输出：9</p></blockquote><p><strong>提示：</strong></p><ul><li>n == height.length</li><li>1 &lt;= n &lt;= 2 * 104</li><li>0 &lt;= height[i] &lt;= 105</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a><strong>方法一：动态规划</strong></h3><p>​    根据木桶原理，左右两个柱子，最后能存多少雨水，取决于最短的板子，所以可以从左到右遍历一遍，求得从左到该位置的最长的板子，从右到左遍历，求得从右到该位置的最长的板子。</p><p>​    计算完左右最长的板子后，然后再遍历一遍，该柱子能否存储雨水，取决于左右最长柱子中的最短柱子和该柱子的差。</p><p><img src="https://assets.leetcode-cn.com/solution-static/42/1.png"></p><h4 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>,<span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        left[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        right[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            left[i] = <span class="built_in">max</span>(left[i - <span class="number">1</span>],height[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            right[i] = <span class="built_in">max</span>(right[i + <span class="number">1</span>],height[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            ans += <span class="built_in">min</span>(left[i],right[i]) - height[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)，计算left，right和雨水量需要遍历三次</li><li>空间复杂度：O(n)，创建两个长度为n的数组存储left和right</li></ul><h3 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a><strong>方法二：单调栈</strong></h3><p>​    维护一个单调栈，单调栈存储的是下标，满足从栈底到栈顶的下标对应的数组 height 中的元素递减。</p><p>​    从左到右遍历数组，如果栈内至少有两个元素，记栈顶元素为 top，top 的下面一个元素是 left，则一定有 height[left] ≥ height[top]。如果 height[i]&gt;height[top]，则得到一个可以接雨水的区域，该区域的宽度是i−left−1，高度是 min(height[left],height[i])−height[top]，根据宽度和高度即可计算得到该区域能接的雨水量。</p><p>​    为了得到 left，需要将 top 出栈。在对top 计算能接的雨水量之后，left 变成新的 top，重复上述操作，直到栈变为空，或者栈顶下标对应的height 中的元素大于或等于height[i]。</p><h4 id="实现代码：-1"><a href="#实现代码：-1" class="headerlink" title="实现代码："></a>实现代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,n = height.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="keyword">int</span> top = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">int</span> curWidth = i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> curHeight = <span class="built_in">min</span>(height[left],height[i]) - height[top];</span><br><span class="line">                ans += curHeight * curWidth;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)，其中 n 是数组height 的长度。从 0 到 n−1 的每个下标最多只会入栈和出栈各一次。</li><li>空间复杂度：O(n)，主要取决于栈空间</li></ul><h3 id="方法三：双指针"><a href="#方法三：双指针" class="headerlink" title="方法三：双指针"></a><strong>方法三：双指针</strong></h3><p>​    和动态规划一样，只不过用双指针代替求左右最长板子的两个数组。</p><p>​    维护两个指针left和right，以及两个变量leftMax和rightMax,在移动过程中更新leftMax和rightMax。</p><p>​    当两个指针没有相遇时，进行如下操作：</p><ul><li>使用height[left]和height[right]的值更新leftMax和rightMax</li><li>如果height[left] &lt; height[right]，则必有leftMax &lt; rightMax，下标left能接的雨水量等于leftMax - height[left]，然后left向右移动一位</li><li>如果height[left] &gt;= height[right]，则必有leftMax &gt;= rightMax，下标right能接的雨水量等于rightMax - height[right]，然后right向左移动一位</li></ul><p>当两个指针相遇时，即可得到能接的雨水总量。</p><h4 id="实现代码：-2"><a href="#实现代码：-2" class="headerlink" title="实现代码："></a>实现代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,left = <span class="number">0</span>,right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>,rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            leftMax = <span class="built_in">max</span>(leftMax,height[left]);</span><br><span class="line">            rightMax = <span class="built_in">max</span>(rightMax,height[right]);</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                ans += leftMax - height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += rightMax - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(n)，其中 n 是数组height 的长度。两个指针的移动总次数不超过 n。</p></li><li><p>空间复杂度：O(1)，只需要使用常数的额外空间。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3368 【模板】树状数组 2</title>
      <link href="/2022/01/04/P3368%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%202/"/>
      <url>/2022/01/04/P3368%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%202/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li>将某区间每一个数数加上 x；</li><li>求出某一个数的值。</li></ol><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 N、M，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 N个用空格分隔的整数，其中第 i个数字表示数列第 i项的初始值。</p><p>接下来 M行每行包含 2 或 4个整数，表示一个操作，具体如下：</p><p>操作 1： 格式：<code>1 x y k</code> 含义：将区间 [x,y][<em>x</em>,<em>y</em>] 内每个数加上 k；</p><p>操作 2： 格式：<code>2 x</code> 含义：输出第 x个数的值。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 2的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><h4 id="样例-1-解释："><a href="#样例-1-解释：" class="headerlink" title="样例 1 解释："></a>样例 1 解释：</h4><p><img src="https://cdn.luogu.com.cn/upload/pic/2258.png" alt="img"></p><p>故输出结果为 6、10。</p><hr><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 30% 的数据：N≤8,M≤10;</p><p>对于 70% 的数据：N≤ 10000,M≤10000;</p><p>对于 100%的数据：1 ≤ N, M≤ 500000，1 ≤ x, y ≤n，保证任意时刻序列中任意元素的绝对值都不大于 2^30。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, m, tree[<span class="number">500100</span>], input[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k &amp; -k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">        tree[x] += k;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">        ans += tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; input[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y, z;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="built_in">add</span>(x, z);</span><br><span class="line">            <span class="built_in">add</span>(y + <span class="number">1</span>, -z);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; input[x] + <span class="built_in">search</span>(x) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3374 【模板】树状数组 1</title>
      <link href="/2022/01/04/P3374%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%201/"/>
      <url>/2022/01/04/P3374%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%201/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面两种操作：</p><ul><li>将某一个数加上 x</li><li>求出某区间每一个数的和</li></ul><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数 n,m，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 n个用空格分隔的整数，其中第 i 个数字表示数列第 i项的初始值。</p><p>接下来 m行每行包含 3个整数，表示一个操作，具体如下：</p><ul><li><code>1 x k</code> 含义：将第 x个数加上 k</li><li><code>2 x y</code> 含义：输出区间 [x,y][<em>x</em>,<em>y</em>] 内每个数的和</li></ul><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 2的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>【数据范围】</p><p>对于 30%30% 的数据，1 ≤ n ≤ 8，1≤ m ≤ 10；<br>对于 70%70% 的数据，1≤ n,m ≤ 10^4；<br>对于 100%100% 的数据，1≤ n,m ≤ 5×10^5。</p><p>样例说明：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/2256.png" alt="img"></p><p>故输出结果14、16</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,tree[<span class="number">2000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k &amp; -k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n)&#123;</span><br><span class="line">        tree[x] += k;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        ans += tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">add</span>(i,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">add</span>(b,c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">2</span>)</span><br><span class="line">            cout &lt;&lt; <span class="built_in">sum</span>(c) - <span class="built_in">sum</span>(b - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2880 [USACO07JAN]Balanced Lineup G</title>
      <link href="/2022/01/04/P2880%20%5BUSACO07JAN%5DBalanced%20Lineup%20G/"/>
      <url>/2022/01/04/P2880%20%5BUSACO07JAN%5DBalanced%20Lineup%20G/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>For the daily milking, Farmer John’s N cows (1 ≤ N ≤ 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height.</p><p>Farmer John has made a list of Q (1 ≤ Q ≤ 180,000) potential groups of cows and their heights (1 ≤ height ≤ 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group.</p><p>每天,农夫 John 的 n(1\le n\le 5\times 10^4)<em>n</em>(1≤<em>n</em>≤5×104) 头牛总是按同一序列排队。</p><p>有一天, John 决定让一些牛们玩一场飞盘比赛。他准备找一群在队列中位置连续的牛来进行比赛。但是为了避免水平悬殊，牛的身高不应该相差太大。John 准备了 q(1\le q\le 1.8\times10^5)<em>q</em>(1≤<em>q</em>≤1.8×105) 个可能的牛的选择和所有牛的身高 h_i(1\le h_i\le 10^6,1\le i\le n)<em>h**i</em>(1≤<em>h**i</em>≤106,1≤<em>i</em>≤<em>n</em>)。他想知道每一组里面最高和最低的牛的身高差。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Line 1: Two space-separated integers, N and Q.</p><p>Lines 2..N+1: Line i+1 contains a single integer that is the height of cow i</p><p>Lines N+2..N+Q+1: Two integers A and B (1 ≤ A ≤ B ≤ N), representing the range of cows from A to B inclusive.</p><p>第一行两个数 n,q。</p><p>接下来 n行，每行一个数 h_i。</p><p>再接下来 q行，每行两个整数 a 和 b，表示询问第 a头牛到第 b头牛里的最高和最低的牛的身高差。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>Lines 1..Q: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range.</p><p>输出共 q行，对于每一组询问，输出每一组中最高和最低的牛的身高差。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>​    因为涉及到区间最值查询，可以用ST表实现（现在还没看懂），先贴上代码再说</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//lxy数组用于求最大值，hrb数组用于求最小值</span></span><br><span class="line"><span class="keyword">int</span> n,m,lxy[<span class="number">180010</span>][<span class="number">22</span>],hrb[<span class="number">180010</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ST</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="built_in">log2</span>(r - l + <span class="number">1</span>),x,y;</span><br><span class="line">    x = <span class="built_in">max</span>(lxy[l][s],lxy[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]);    <span class="comment">//区间最大</span></span><br><span class="line">    y = <span class="built_in">min</span>(hrb[l][s],hrb[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]);  <span class="comment">//区间最小</span></span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; lxy[i][<span class="number">0</span>];</span><br><span class="line">        hrb[i][<span class="number">0</span>] = lxy[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">21</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k + (<span class="number">1</span> &lt;&lt; i) &lt;= n + <span class="number">1</span>; ++k)&#123;</span><br><span class="line">            lxy[k][i] = <span class="built_in">max</span>(lxy[k][i - <span class="number">1</span>],lxy[k + (<span class="number">1</span> &lt;&lt;(i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">            hrb[k][i] = <span class="built_in">min</span>(hrb[k][i - <span class="number">1</span>],hrb[k + (<span class="number">1</span> &lt;&lt;(i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">ST</span>(l,r) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ST表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-9 重排链表 (25 分)</title>
      <link href="/2022/01/03/7-9%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%20(25%20%E5%88%86)/"/>
      <url>/2022/01/03/7-9%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%20(25%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>给定一个单链表 <em>L</em>1→<em>L</em>2→⋯→<em>L**n</em>−1→<em>L**n</em>，请编写程序将链表重新排列为 <em>L**n</em>→<em>L</em>1→<em>L**n</em>−1→<em>L</em>2→⋯。例如：给定<em>L</em>为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数<em>N</em> (≤105)。结点的地址是5位非负整数，NULL地址用−1表示。</p><p>接下来有<em>N</em>行，每行格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中<code>Address</code>是结点地址；<code>Data</code>是该结点保存的数据，为不超过105的正整数；<code>Next</code>是下一结点的地址。题目保证给出的链表上至少有两个结点。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00100</span> <span class="number">6</span></span><br><span class="line"><span class="number">00000</span> <span class="number">4</span> <span class="number">99999</span></span><br><span class="line"><span class="number">00100</span> <span class="number">1</span> <span class="number">12309</span></span><br><span class="line"><span class="number">68237</span> <span class="number">6</span> <span class="number">-1</span></span><br><span class="line"><span class="number">33218</span> <span class="number">3</span> <span class="number">00000</span></span><br><span class="line"><span class="number">99999</span> <span class="number">5</span> <span class="number">68237</span></span><br><span class="line"><span class="number">12309</span> <span class="number">2</span> <span class="number">33218</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">68237</span> <span class="number">6</span> <span class="number">00100</span></span><br><span class="line"><span class="number">00100</span> <span class="number">1</span> <span class="number">99999</span></span><br><span class="line"><span class="number">99999</span> <span class="number">5</span> <span class="number">12309</span></span><br><span class="line"><span class="number">12309</span> <span class="number">2</span> <span class="number">00000</span></span><br><span class="line"><span class="number">00000</span> <span class="number">4</span> <span class="number">33218</span></span><br><span class="line"><span class="number">33218</span> <span class="number">3</span> <span class="number">-1</span>结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> node_data[<span class="number">100001</span>],node_next[<span class="number">100001</span>];</span><br><span class="line">    <span class="keyword">int</span> head,n;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    cin &gt;&gt; head &gt;&gt; n;</span><br><span class="line">    <span class="comment">//初始化静态链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        node_data[a] = b;</span><br><span class="line">        node_next[a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历一遍链表，将各个结点的地址进行记录</span></span><br><span class="line">    <span class="keyword">int</span> h = head;</span><br><span class="line">    <span class="keyword">while</span>(h != <span class="number">-1</span>)&#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(h);</span><br><span class="line">        h = node_next[h];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是一个坑，对应一个测试点，因为会出现有多个结点为next都为-1，即不在该链表上的结点，所以要重新算一下长度</span></span><br><span class="line">    <span class="keyword">int</span> num = v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">address</span><span class="params">(num)</span></span>;</span><br><span class="line">    <span class="comment">//按题目要求，对链表结点进行重新排序</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>,high = num - <span class="number">1</span>,k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        address[k++] = v[high--];</span><br><span class="line">        address[k++] = v[low++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low == high) address[k] = v[low];</span><br><span class="line">    <span class="comment">//输出即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> add = address[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,add,node_data[add],address[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1\n&quot;</span>,address[num - <span class="number">1</span>],node_data[address[num - <span class="number">1</span>]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 静态链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-6 最长对称子串 (25 分)</title>
      <link href="/2022/01/03/7-6%20%E6%9C%80%E9%95%BF%E5%AF%B9%E7%A7%B0%E5%AD%90%E4%B8%B2%20(25%20%E5%88%86)/"/>
      <url>/2022/01/03/7-6%20%E6%9C%80%E9%95%BF%E5%AF%B9%E7%A7%B0%E5%AD%90%E4%B8%B2%20(25%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定<code>Is PAT&amp;TAP symmetric?</code>，最长对称子串为<code>s PAT&amp;TAP s</code>，于是你应该输出11。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出长度不超过1000的非空字符串。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出最长对称子串的长度。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Is PAT&amp;TAP symmetric?</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>​    采用中心扩散法，主要是Manacher 算法一看就很复杂，不想学，中心扩散法的基本原理就是以每个元素作为中心，向左右两边扩散，如果无法继续扩散，此时和最大长度比较。</p><p>​    而字符串元素的个数分为奇数和偶数</p><ul><li>奇数：由中间一个字符作为中心进行扩散，对称轴为中间这个字符</li><li>偶数：由中间两个字符作为中心进行扩散，对称轴夹在两个字符中间</li></ul><p>力扣相关题：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5.最长回文子串</a></p><p>力扣视频链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/">最长回文子串</a></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(low &gt;= <span class="number">0</span> &amp;&amp; high &lt; s.<span class="built_in">size</span>() &amp;&amp; s[low] == s[high])&#123;</span><br><span class="line">        low--;</span><br><span class="line">        high++;</span><br><span class="line">    &#125;</span><br><span class="line">    maxlen = <span class="built_in">max</span>(maxlen,high - low - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="built_in">Judge</span>(i,i);</span><br><span class="line">        <span class="built_in">Judge</span>(i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxlen &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL vector的find实现</title>
      <link href="/2022/01/03/C++%20STL%20vector%E7%9A%84find%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/01/03/C++%20STL%20vector%E7%9A%84find%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>不同于map（map有find方法），vector本身是没有find这一方法，其find是依靠algorithm来实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">        ve.<span class="built_in">push_back</span>(i);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(ve.<span class="built_in">begin</span>(), ve.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != ve.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;can not find&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ sync_with_stdio和cin.tie(0),cout.tie(0)</title>
      <link href="/2022/01/03/C++%20sync_with_stdio%E5%92%8Ccin.tie(0),cout.tie(0)/"/>
      <url>/2022/01/03/C++%20sync_with_stdio%E5%92%8Ccin.tie(0),cout.tie(0)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="1-ios-sync-with-stdio-false-的作用"><a href="#1-ios-sync-with-stdio-false-的作用" class="headerlink" title="1.ios::sync_with_stdio(false)的作用"></a>1.ios::sync_with_stdio(false)的作用</h3><p><strong>如果要关闭同步流ios::sync_with_stdio(false)来提高cin输入速度，就不能与getchar()混用，但是getchar()可以换成cin.get()！</strong></p><p>  作用是取消缓冲区同步，例如printf(),scanf()是C函数，而cin,cout是C++函数，这些函数需要用到各自的缓冲区，为了防止各自的缓冲区错位，C++默认将C函数和C++函数的缓冲区同步。 它的原理是使本该同步的输入输出流分开，就是让C的输入输出流和C++的输入输出流分开。</p><p>​        如果在此时用getchar(),读取的指挥室C语言的缓冲区，而不影响C++的缓冲区。所以应该采用cin.get()（效果等同于getchar(),但读取的是C++的缓冲区）</p><h3 id="2-tie"><a href="#2-tie" class="headerlink" title="2.tie"></a>2.tie</h3><p>tie是将两个<a href="https://so.csdn.net/so/search?q=stream">stream</a>绑定的函数，空参数的话返回当前的输出流指针。<br>在默认的情况下cin绑定的是cout，每次执行 &lt;&lt; 操作符的时候都要调用flush，这样会增加IO负担。可以通过tie(0)（0表示NULL）来解除cin与cout的绑定，进一步加快执行效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="3-ACM应用"><a href="#3-ACM应用" class="headerlink" title="3.ACM应用"></a>3.ACM应用</h3><p>在ACM里，经常出现数据集超大造成 cin TLE的情况。这时候大部分人认为这是cin的效率不及scanf的错，甚至还上升到C语言和C++语言的执行效率层面的无聊争论。其实像上文所说，这只是C++为了兼容而采取的保守措施。我们可以在IO之前将stdio解除绑定，这样做了之后要注意不要同时混用cout和printf之类。</p><p>在默认的情况下cin绑定的是cout，每次执行 &lt;&lt; 操作符的时候都要调用flush，这样会增加IO负担。可以通过tie(0)（0表示NULL）来解除cin与cout的绑定，进一步加快执行效率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 字符串补0,setw和setfill</title>
      <link href="/2022/01/03/C++%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A50,setw%E5%92%8Csetfill/"/>
      <url>/2022/01/03/C++%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A50,setw%E5%92%8Csetfill/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>为了实现字符串补0，所以使用set和setfill</p><ul><li>setw(5) ：设置字符串宽度，这里设置5字符</li><li>setfill(‘0’) ：设置填充字符，这里设置填充 0</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; s &lt;&lt; endl;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出： 00123</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1204 [USACO1.2]挤牛奶Milking Cows</title>
      <link href="/2022/01/02/P1204%20%5BUSACO1.2%5D%E6%8C%A4%E7%89%9B%E5%A5%B6Milking%20Cows/"/>
      <url>/2022/01/02/P1204%20%5BUSACO1.2%5D%E6%8C%A4%E7%89%9B%E5%A5%B6Milking%20Cows/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>三个农民每天清晨 5 点起床，然后去牛棚给三头牛挤奶。</p><p>第一个农民在 300 秒 (从 5 点开始计时) 给他的牛挤奶，一直到 1000 秒。第二个农民在 700 秒开始，在 1200 秒结束。第三个农民在 1500 秒开始，2100 秒结束。</p><p>期间最长的至少有一个农民在挤奶的连续时间为 900 秒 (从 300 秒到 1200秒)，而最长的无人挤奶的连续时间(从挤奶开始一直到挤奶结束)为 300 秒 (从 1200 秒到 1500 秒)。</p><hr><p>你的任务是编一个程序，读入一个有 n个农民挤 n 头牛的工作时间列表，计算以下两点(均以秒为单位):</p><p>最长至少有一人在挤奶的时间段。</p><p>最长的无人挤奶的时间段。（从有人挤奶开始算起）</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个正整数 n</p><p>接下来 n 行，每行两个非负整数 l,r,表示一个农民的开始时刻与结束时刻。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，两个整数，即题目所要求的两个答案。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">300</span> <span class="number">1000</span></span><br><span class="line"><span class="number">700</span> <span class="number">1200</span></span><br><span class="line"><span class="number">1500</span> <span class="number">2100</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">900</span> <span class="number">300</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>【数据范围】<br>对于 100% 的数据，1&lt;= n &lt;= 5000,0 &lt;= l &lt;= r &lt;=10e6</p><h2 id="算法思路（贪心）"><a href="#算法思路（贪心）" class="headerlink" title="算法思路（贪心）"></a>算法思路（贪心）</h2><p>​    如果将读入的区间视作线段，则题意转变为<strong>求至少有一条线段覆盖的最大区间和没有线段覆盖的区间</strong>。</p><p>​    假设读入数据如下： <img src="https://cdn.luogu.com.cn/upload/pic/46260.png" alt="fig"></p><p>首先按照4条线段的起点位置排序（具体原因后面解释）。将begin设置为第一条线段的起点，将end设置为第一条线段的终点。</p><p>然后从第二条线段开始判断。如果该线段的起点小于end，则说明这两条线段有重合部分，将end更新为max{end,该线段的终点位置}。如果该线段的起点大于end，则说明该线段及以后的线段再也不会与前面的线段产生任何重合部分（这也就是排序的作用），那么可以更新ans1和ans2的值：ans1更新为max{ans1,end-begin},ans2更新为max{ans2,该线段的起点位置-end}。具体参见图中第4条线段，ans1被更新为1200-0，ans2被更新为1400-1200。</p><p>程序已经基本成型，但要注意在输出答案前更新一遍ans1的值，这是为了避免所有线段均有重合部分而无法判断的情况。另外，ans1和ans2要初始化为0。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> begin,end;</span><br><span class="line">&#125;m[<span class="number">5001</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.begin &lt; b.begin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        cin &gt;&gt; m[i].begin &gt;&gt; m[i].end;</span><br><span class="line">    <span class="built_in">sort</span>(m + <span class="number">1</span>,m + N + <span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> begin = m[<span class="number">1</span>].begin,end = m[<span class="number">1</span>].end;</span><br><span class="line">    <span class="keyword">int</span> ans1 = <span class="number">0</span>,ans2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m[i].begin &lt;= end)&#123;</span><br><span class="line">            end = <span class="built_in">max</span>(end,m[i].end);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans1 = <span class="built_in">max</span>(ans1,end - begin);</span><br><span class="line">            ans2 = <span class="built_in">max</span>(ans2,m[i].begin - end);</span><br><span class="line">            begin = m[i].begin;</span><br><span class="line">            end = m[i].end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans1=<span class="built_in">max</span>(ans1,end-begin);</span><br><span class="line">    cout &lt;&lt; ans1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>825. 适龄的朋友</title>
      <link href="/2021/12/27/825.%20%E9%80%82%E9%BE%84%E7%9A%84%E6%9C%8B%E5%8F%8B/"/>
      <url>/2021/12/27/825.%20%E9%80%82%E9%BE%84%E7%9A%84%E6%9C%8B%E5%8F%8B/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。</p><p>如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：</p><ul><li><p>age[y] &lt;= 0.5 * age[x] + 7</p></li><li><p>age[y] &gt; age[x]</p></li><li><p>age[y] &gt; 100 &amp;&amp; age[x] &lt; 100</p></li></ul><p>否则，x 将会向 y 发送一条好友请求。</p><p>注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。</p><p>返回在该社交媒体网站上产生的好友请求总数。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：ages = [16,16]<br>输出：2<br>解释：2 人互发好友请求。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：ages = [16,16]<br>输出：2<br>解释：2 人互发好友请求。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：ages = [20,30,100,110,120]<br>输出：3<br>解释：产生的好友请求为 110 -&gt; 100 ，120 -&gt; 110 ，120 -&gt; 100 。</p></blockquote><p><strong>提示：</strong></p><ul><li>n == ages.length</li><li>1 &lt;= n &lt;= 2 * 104</li><li>1 &lt;= ages[i] &lt;= 120</li></ul><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numFriendRequests</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; ages)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">121</span>)</span></span>;</span><br><span class="line">        <span class="comment">//计数排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> &amp;age: ages)</span><br><span class="line">            ++cnt[age];</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">pre</span><span class="params">(<span class="number">121</span>)</span></span>;</span><br><span class="line">        <span class="comment">//前缀和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">120</span>; ++i)</span><br><span class="line">            pre[i] = pre[i - <span class="number">1</span>] + cnt[i];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">15</span>; i &lt;= <span class="number">120</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> bound = <span class="number">0.5</span> * i + <span class="number">8</span>;</span><br><span class="line">                res += cnt[i] * (pre[i] - pre[bound - <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n + C)，其中 C 是用户年龄的范围，本题中 C = 120。计数排序需要 O(n) 的时间，计算前缀和以及统计答案需要 O(C)的时间。</p></li><li><p>空间复杂度：O(C)，即为计数排序以及前缀和数组需要使用的空间。</p></li></ul><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/solution/gua-ling-de-peng-you-by-leetcode-solutio-v7yk/">https://leetcode-cn.com/problems/friends-of-appropriate-ages/solution/gua-ling-de-peng-you-by-leetcode-solutio-v7yk/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 计数排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-3 顺序存储的二叉树的最近的公共祖先问题 (20 分)</title>
      <link href="/2021/11/05/7-3%20%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98%20(20%20%E5%88%86)/"/>
      <url>/2021/11/05/7-3%20%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98%20(20%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>设顺序存储的二叉树中有编号为<em>i</em>和<em>j</em>的两个结点，请设计算法求出它们最近的公共祖先结点的编号和值。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出正整数<em>n</em>（≤1000），即顺序存储的最大容量；第2行给出<em>n</em>个非负整数，其间以空格分隔。其中0代表二叉树中的空结点（如果第1个结点为0，则代表一棵空树）；第3行给出一对结点编号<em>i</em>和<em>j</em>。</p><p>题目保证输入正确对应一棵二叉树，且1≤<em>i</em>,<em>j</em>≤<em>n</em>。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>如果<em>i</em>或<em>j</em>对应的是空结点，则输出<code>ERROR: T[x] is NULL</code>，其中<code>x</code>是<em>i</em>或<em>j</em>中先发现错误的那个编号；否则在一行中输出编号为<em>i</em>和<em>j</em>的两个结点最近的公共祖先结点的编号和值，其间以1个空格分隔。</p><h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">1</span> <span class="number">10</span> <span class="number">0</span> <span class="number">7</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">9</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">11</span> <span class="number">4</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">9</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">12</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: T[<span class="number">12</span>] is <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> tree[N + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tree));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ; ++i)</span><br><span class="line">        cin &gt;&gt; tree[i];</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[a] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: T[%d] is NULL&quot;</span>,a);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[b] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: T[%d] is NULL&quot;</span>,b);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a == b)&#123;</span><br><span class="line">            cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; tree[a] &lt;&lt; endl;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//让序号大的找父亲</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt; b)   a /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span>        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 周练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08-图9 关键活动 (30 分)</title>
      <link href="/2021/11/03/08-%E5%9B%BE9%20%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8%20(30%20%E5%88%86)/"/>
      <url>/2021/11/03/08-%E5%9B%BE9%20%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8%20(30%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。</p><p>比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和C程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如C程序设计和数据结构两门课，必须先学习前者。</p><p>但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务A依赖于子任务B，子任务B依赖于子任务C，子任务C又依赖于子任务A”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。</p><p>任务调度问题中，如果还给出了完成每个子任务需要的时间，则我们可以算出完成整个工程需要的最短时间。在这些子任务中，有些任务即使推迟几天完成，也不会影响全局的工期；但是有些任务必须准时完成，否则整个项目的工期就要因此延误，这种任务就叫“关键活动”。</p><p>请编写程序判定一个给定的工程项目的任务调度是否可行；如果该调度方案可行，则计算完成整个工程项目需要的最短时间，并输出所有的关键活动。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出两个正整数<em>N</em>(≤100)和<em>M</em>，其中<em>N</em>是任务交接点（即衔接相互依赖的两个子任务的节点，例如：若任务2要在任务1完成后才开始，则两任务之间必有一个交接点）的数量。交接点按1<del><em>N</em>编号，<em>M</em>是子任务的数量，依次编号为1</del><em>M</em>。随后<em>M</em>行，每行给出了3个正整数，分别是该任务开始和完成涉及的交接点编号以及该任务所需的时间，整数间用空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>如果任务调度不可行，则输出0；否则第1行输出完成整个工程项目需要的时间，第2行开始输出所有关键活动，每个关键活动占一行，按格式“V-&gt;W”输出，其中V和W为该任务开始和完成涉及的交接点编号。关键活动输出的顺序规则是：任务开始的交接点编号小者优先，起点编号相同时，与输入时任务的顺序相反。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">2</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line"><span class="number">2</span>-&gt;<span class="number">4</span></span><br><span class="line"><span class="number">4</span>-&gt;<span class="number">6</span></span><br><span class="line"><span class="number">6</span>-&gt;<span class="number">7</span>结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M,ECT;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> Indegree[<span class="number">101</span>],Outdegree[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> ETime[<span class="number">101</span>],LTime[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Late</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    <span class="comment">//出度为0的入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ;++i)&#123;</span><br><span class="line">        LTime[i] = ECT;</span><br><span class="line">        <span class="keyword">if</span>(Outdegree[i] == <span class="number">0</span>)  qu.<span class="built_in">push</span>(i); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mar[i][t] != F)&#123;</span><br><span class="line">                <span class="comment">//如果邻接点的最晚时间大于当前结点的最晚时间减去边的活动所需时间，则更新最晚时间</span></span><br><span class="line">                <span class="keyword">if</span>(--Outdegree[i] == <span class="number">0</span>)    qu.<span class="built_in">push</span>(i);</span><br><span class="line">                <span class="keyword">if</span>(LTime[t] - mar[i][t] &lt; LTime[i])</span><br><span class="line">                    LTime[i] = LTime[t] - mar[i][t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TopSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ;++i)</span><br><span class="line">        <span class="keyword">if</span>(Indegree[i] == <span class="number">0</span>)  qu.<span class="built_in">push</span>(i); </span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mar[t][i] != F)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--Indegree[i] == <span class="number">0</span>)    qu.<span class="built_in">push</span>(i);</span><br><span class="line">                <span class="keyword">if</span>(ETime[t] + mar[t][i] &gt; ETime[i])</span><br><span class="line">                    ETime[i] = ETime[t] + mar[t][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt != N)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ECT = *<span class="built_in">max_element</span>(ETime + <span class="number">1</span>,ETime + <span class="number">1</span> + N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">fill</span>(mar[<span class="number">0</span>],mar[<span class="number">0</span>] + <span class="number">101</span> * <span class="number">101</span>,F);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        mar[a][b] = c;</span><br><span class="line">        Indegree[b]++;</span><br><span class="line">        Outdegree[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">TopSort</span>())&#123;</span><br><span class="line">        cout &lt;&lt; ECT &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Late</span>();</span><br><span class="line">        <span class="comment">//因为起点编号相同时，与输入时任务的顺序相反，则j从N开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = N; j &gt;= <span class="number">1</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mar[i][j] != F &amp;&amp; ETime[i] + mar[i][j] == LTime[j])</span><br><span class="line">                    cout &lt;&lt; i &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浙大慕课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08-图8 How Long Does It Take (25 分)</title>
      <link href="/2021/11/03/08-%E5%9B%BE8%20How%20Long%20Does%20It%20Take%20(25%20%E5%88%86)/"/>
      <url>/2021/11/03/08-%E5%9B%BE8%20How%20Long%20Does%20It%20Take%20(25%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>Given the relations of all the activities of a project, you are supposed to find the earliest completion time of the project.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing two positive integers <em>N</em> (≤100), the number of activity check points (hence it is assumed that the check points are numbered from 0 to <em>N</em>−1), and <em>M</em>, the number of activities. Then <em>M</em> lines follow, each gives the description of an activity. For the <code>i</code>-th activity, three non-negative numbers are given: <code>S[i]</code>, <code>E[i]</code>, and <code>L[i]</code>, where <code>S[i]</code> is the index of the starting check point, <code>E[i]</code> of the ending check point, and <code>L[i]</code> the lasting time of the activity. The numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, if the scheduling is possible, print in a line its earliest completion time; or simply output “Impossible”.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> <span class="number">12</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">9</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">7</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span> <span class="number">8</span> <span class="number">2</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span> <span class="number">4</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> degree[<span class="number">101</span>],dis[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>,lasttime = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    <span class="comment">//把入度为0的结点入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ;++i)</span><br><span class="line">        <span class="keyword">if</span>(degree[i] == <span class="number">0</span>)  qu.<span class="built_in">push</span>(i); </span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="comment">//计算该点到下一个结点的所需要的时间，如果更大则更新</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mar[t][i] != F)&#123;</span><br><span class="line">                <span class="comment">//删除结点后，邻接点的入度-1，更新lasttime</span></span><br><span class="line">                <span class="keyword">if</span>(--degree[i] == <span class="number">0</span>)    qu.<span class="built_in">push</span>(i);</span><br><span class="line">                dis[i] = <span class="built_in">max</span>(dis[t] + mar[t][i],dis[i]);</span><br><span class="line">                lasttime = <span class="built_in">max</span>(lasttime,dis[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == N)    cout &lt;&lt; lasttime &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>            cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">fill</span>(mar[<span class="number">0</span>],mar[<span class="number">0</span>] + <span class="number">101</span> * <span class="number">101</span>,F);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        mar[a][b] = c;</span><br><span class="line">        degree[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TopSort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浙大慕课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08-图7 公路村村通 (30 分)</title>
      <link href="/2021/11/03/08-%E5%9B%BE7%20%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A%20(30%20%E5%88%86)/"/>
      <url>/2021/11/03/08-%E5%9B%BE7%20%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A%20(30%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入数据包括城镇数目正整数<em>N</em>（≤1000）和候选道路数目<em>M</em>（≤3<em>N</em>）；随后的<em>M</em>行对应<em>M</em>条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到<em>N</em>编号。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">3</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 9999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> visited[N + <span class="number">1</span>],dis[N + <span class="number">1</span>],sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ;++i)</span><br><span class="line">        dis[i] = mar[s][i];</span><br><span class="line">    visited[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">-1</span>,cnt = F;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N ;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dis[j] &lt; cnt)&#123;</span><br><span class="line">                pos = j;</span><br><span class="line">                cnt = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">-1</span>)&#123;</span><br><span class="line">            flag = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += dis[pos];</span><br><span class="line">        visited[pos] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果到j的距离大于从集合中新加的点到j的距离，则更新路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N ; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dis[j] &gt; mar[pos][j])&#123;</span><br><span class="line">                dis[j] = mar[pos][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N ; ++j)</span><br><span class="line">            mar[i][j] = F;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ; ++i)</span><br><span class="line">        mar[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        mar[a][b] = mar[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">prime</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浙大慕课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-图6 旅游规划 (25 分)</title>
      <link href="/2021/11/03/07-%E5%9B%BE6%20%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92%20(25%20%E5%88%86)/"/>
      <url>/2021/11/03/07-%E5%9B%BE6%20%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92%20(25%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入数据的第1行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0~(<em>N</em>−1)；<em>M</em>是高速公路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。随后的<em>M</em>行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">20</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">30</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">4</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">20</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">20</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">40</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 9999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M,S,D;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> price[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[N],visited[N],pay[N];</span><br><span class="line">    <span class="comment">//初始化距离数组和价格数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; ++i)&#123;</span><br><span class="line">        dis[i] = mar[S][i];</span><br><span class="line">        pay[i] = price[S][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    visited[S] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">-1</span>,cnt = F;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; N ; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dis[j] &lt; cnt)&#123;</span><br><span class="line">                pos = j;</span><br><span class="line">                cnt = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">-1</span>)   <span class="keyword">break</span>;</span><br><span class="line">        visited[pos] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j])&#123;</span><br><span class="line">                <span class="comment">//如果距离能更短，直接更新距离和价格，如果距离相同，则比较价格，价格更小则更新价格</span></span><br><span class="line">                <span class="keyword">if</span>(dis[j] &gt; dis[pos] + mar[pos][j])&#123;</span><br><span class="line">                    dis[j] = dis[pos] + mar[pos][j];</span><br><span class="line">                    pay[j] = pay[pos] + price[pos][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dis[j] ==  dis[pos] + mar[pos][j] &amp;&amp; pay[j] &gt; pay[pos] + price[pos][j])</span><br><span class="line">                    pay[j] = pay[pos] + price[pos][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dis[D] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pay[D] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; D;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; N ; ++j)</span><br><span class="line">            mar[i][j] = price[i][j] = F;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; ++i)</span><br><span class="line">        mar[i][i] = price[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        mar[a][b] = mar[b][a] = c;</span><br><span class="line">        price[a][b] = price[b][a] = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浙大慕课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-图5 Saving James Bond - Hard Version (30 分)</title>
      <link href="/2021/11/03/07-%E5%9B%BE5%20Saving%20James%20Bond%20-%20Hard%20Version%20(30%20%E5%88%86)/"/>
      <url>/2021/11/03/07-%E5%9B%BE5%20Saving%20James%20Bond%20-%20Hard%20Version%20(30%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).</p><p>Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him a shortest path to reach one of the banks. The length of a path is the number of jumps that James has to make.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing two positive integers <em>N</em> (≤100), the number of crocodiles, and <em>D</em>, the maximum distance that James could jump. Then <em>N</em> lines follow, each containing the (<em>x</em>,<em>y</em>) location of a crocodile. Note that no two crocodiles are staying at the same position.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, if James can escape, output in one line the minimum number of jumps he must make. Then starting from the next line, output the position (<em>x</em>,<em>y</em>) of each crocodile on the path, each pair in one line, from the island to the bank. If it is impossible for James to escape that way, simply give him 0 as the number of jumps. If there are many shortest paths, just output the one with the minimum first jump, which is guaranteed to be unique.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span> <span class="number">15</span></span><br><span class="line"><span class="number">10</span> <span class="number">-21</span></span><br><span class="line"><span class="number">10</span> <span class="number">21</span></span><br><span class="line"><span class="number">-40</span> <span class="number">10</span></span><br><span class="line"><span class="number">30</span> <span class="number">-50</span></span><br><span class="line"><span class="number">20</span> <span class="number">40</span></span><br><span class="line"><span class="number">35</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">-10</span></span><br><span class="line"><span class="number">-25</span> <span class="number">22</span></span><br><span class="line"><span class="number">40</span> <span class="number">-40</span></span><br><span class="line"><span class="number">-30</span> <span class="number">30</span></span><br><span class="line"><span class="number">-10</span> <span class="number">22</span></span><br><span class="line"><span class="number">0</span> <span class="number">11</span></span><br><span class="line"><span class="number">25</span> <span class="number">21</span></span><br><span class="line"><span class="number">25</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">35</span></span><br><span class="line"><span class="number">-30</span> <span class="number">10</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">11</span></span><br><span class="line"><span class="number">10</span> <span class="number">21</span></span><br><span class="line"><span class="number">10</span> <span class="number">35</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="number">-12</span> <span class="number">12</span></span><br><span class="line"><span class="number">12</span> <span class="number">12</span></span><br><span class="line"><span class="number">-12</span> <span class="number">-12</span></span><br><span class="line"><span class="number">12</span> <span class="number">-12</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> N,D,answer;</span><br><span class="line">Node cro[<span class="number">102</span>];</span><br><span class="line"><span class="keyword">int</span> visited[<span class="number">102</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.d &lt; b.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstJump</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1.0</span> * cro[pos].d &lt;= <span class="built_in">pow</span>(D + <span class="number">15.0</span> / <span class="number">2</span>,<span class="number">2.0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Jump</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pow</span>(cro[cur].x - cro[next].x,<span class="number">2.0</span>) + <span class="built_in">pow</span>(cro[cur].y - cro[next].y,<span class="number">2.0</span>) &lt;= D * D)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsSafe</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cro[pos].x-D&lt;=<span class="number">-50</span>||cro[pos].y-D&lt;=<span class="number">-50</span>||cro[pos].x+D&gt;=<span class="number">50</span>||cro[pos].y+D&gt;=<span class="number">50</span>)</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printpath</span><span class="params">(<span class="keyword">int</span> answer)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(answer == <span class="number">-1</span>)    <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printpath</span>(cro[answer].pre);</span><br><span class="line">    cout &lt;&lt; cro[answer].x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; cro[answer].y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    answer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">1</span>,last = <span class="number">-1</span>,tail = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="comment">//将第一跳就能跳到的结点入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">FirstJump</span>(i))&#123;</span><br><span class="line">            qu.<span class="built_in">push</span>(i);</span><br><span class="line">            last = i;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果能第一跳能到的最远的结点能直接到岸边，则直接输出1</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsSafe</span>(last))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参考六度空间，通过tail和last记录层数</span></span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; <span class="built_in">Jump</span>(pos,i))&#123;</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                qu.<span class="built_in">push</span>(i);</span><br><span class="line">                tail = i;</span><br><span class="line">                cro[i].pre = pos;</span><br><span class="line">                answer = <span class="built_in">IsSafe</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(answer) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(answer)  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos == last)&#123;</span><br><span class="line">            ++step;</span><br><span class="line">            last = tail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//首先如果能顺利到岸，当前节点需要加上自身所在的一层以及最后跳到岸边的一次</span></span><br><span class="line">    <span class="keyword">if</span>(answer)&#123;</span><br><span class="line">        cout &lt;&lt; step + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">printpath</span>(answer);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; D;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; cro[i].x &gt;&gt; cro[i].y;</span><br><span class="line">        cro[i].d = cro[i].x * cro[i].x + cro[i].y * cro[i].y;</span><br><span class="line">        cro[i].pre = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对距离进行排序，先从距离最近的跳</span></span><br><span class="line">    <span class="built_in">sort</span>(cro + <span class="number">1</span>,cro + N + <span class="number">1</span>,cmp);</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浙大慕课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-图4 哈利·波特的考试 (25 分)</title>
      <link href="/2021/11/03/07-%E5%9B%BE4%20%E5%93%88%E5%88%A9%C2%B7%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95%20(25%20%E5%88%86)/"/>
      <url>/2021/11/03/07-%E5%9B%BE4%20%E5%93%88%E5%88%A9%C2%B7%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95%20(25%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。</p><p>现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入第1行给出两个正整数<em>N</em> (≤100)和<em>M</em>，其中<em>N</em>是考试涉及的动物总数，<em>M</em>是用于直接变形的魔咒条数。为简单起见，我们将动物按1~<em>N</em>编号。随后<em>M</em>行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">11</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">70</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">50</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">50</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">60</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">70</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">60</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">80</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">100</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">60</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">80</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">70</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 9999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindAnimal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minpath = F,minpos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> maxpath = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//找从当前动物变到其他动物的最长路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N ; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != j &amp;&amp; mar[i][j] &gt; maxpath)</span><br><span class="line">                maxpath = mar[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前动物有变不了的动物</span></span><br><span class="line">        <span class="keyword">if</span>(maxpath == F)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从所有动物的最长路径中找最小的</span></span><br><span class="line">        <span class="keyword">if</span>(minpath &gt; maxpath)&#123;</span><br><span class="line">            minpath = maxpath;</span><br><span class="line">            minpos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; minpos &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; minpath &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= N ; ++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++j)</span><br><span class="line">                mar[i][j] = <span class="built_in">min</span>(mar[i][j],mar[i][k] + mar[k][j]);</span><br><span class="line">    <span class="built_in">FindAnimal</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N ; ++j)</span><br><span class="line">            mar[i][j] = F;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ; ++i)</span><br><span class="line">        mar[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        mar[a][b] = mar[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Floyd</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浙大慕课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-图3 六度空间 (30 分)</title>
      <link href="/2021/11/03/06-%E5%9B%BE3%20%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4%20(30%20%E5%88%86)/"/>
      <url>/2021/11/03/06-%E5%9B%BE3%20%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4%20(30%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。</p><p><img src="https://images.ptausercontent.com/35" alt="img"><br>图1 六度空间示意图</p><p>“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。</p><p>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出两个正整数，分别表示社交网络图的结点数<em>N</em>（1&lt;<em>N</em>≤103，表示人数）、边数<em>M</em>（≤33×<em>N</em>，表示社交关系数）。随后的<em>M</em>行对应<em>M</em>条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到<em>N</em>编号）。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">9</span> <span class="number">10</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="number">70.00</span>%</span><br><span class="line"><span class="number">2</span>: <span class="number">80.00</span>%</span><br><span class="line"><span class="number">3</span>: <span class="number">90.00</span>%</span><br><span class="line"><span class="number">4</span>: <span class="number">100.00</span>%</span><br><span class="line"><span class="number">5</span>: <span class="number">100.00</span>%</span><br><span class="line"><span class="number">6</span>: <span class="number">100.00</span>%</span><br><span class="line"><span class="number">7</span>: <span class="number">100.00</span>%</span><br><span class="line"><span class="number">8</span>: <span class="number">90.00</span>%</span><br><span class="line"><span class="number">9</span>: <span class="number">80.00</span>%</span><br><span class="line"><span class="number">10</span>: <span class="number">70.00</span>%结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> visited[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    visited[id] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//last记录每一层的最后一个节点，tail记录当前访问的节点</span></span><br><span class="line">    <span class="comment">//如果当前弹出的节点时last，则层数需要+1，新的last为tail</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>,level = <span class="number">0</span>,last = id,tail = id;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(id);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mar[t][i] == <span class="number">1</span> &amp;&amp; !visited[i])&#123;</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                qu.<span class="built_in">push</span>(i);</span><br><span class="line">                cnt++;</span><br><span class="line">                tail = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t == last)&#123;</span><br><span class="line">            level++;last = tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(level == <span class="number">6</span>)  <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        mar[a][b] = mar[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;++i)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %.2lf%\n&quot;</span>,i,<span class="number">1.0</span>* <span class="built_in">bfs</span>(i) / N * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浙大慕课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-3 社交网络图中结点的“重要性”计算 (25 分)</title>
      <link href="/2021/10/27/2-3%20%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E5%9B%BE%E4%B8%AD%E7%BB%93%E7%82%B9%E7%9A%84%E2%80%9C%E9%87%8D%E8%A6%81%E6%80%A7%E2%80%9D%E8%AE%A1%E7%AE%97%20(25%20%E5%88%86)/"/>
      <url>/2021/10/27/2-3%20%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E5%9B%BE%E4%B8%AD%E7%BB%93%E7%82%B9%E7%9A%84%E2%80%9C%E9%87%8D%E8%A6%81%E6%80%A7%E2%80%9D%E8%AE%A1%E7%AE%97%20(25%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>在社交网络中，个人或单位（结点）之间通过某些关系（边）联系起来。他们受到这些关系的影响，这种影响可以理解为网络中相互连接的结点之间蔓延的一种相互作用，可以增强也可以减弱。而结点根据其所处的位置不同，其在网络中体现的重要性也不尽相同。</p><p>“紧密度中心性”是用来衡量一个结点到达其它结点的“快慢”的指标，即一个有较高中心性的结点比有较低中心性的结点能够更快地（平均意义下）到达网络中的其它结点，因而在该网络的传播过程中有更重要的价值。在有<em>N</em>个结点的网络中，结点<em>v**i</em>的“紧密度中心性”<em>C**c</em>(<em>v**i</em>)数学上定义为<em>v**i</em>到其余所有结点<em>v**j</em> (<em>j</em>\=<em>i</em>) 的最短距离<em>d</em>(<em>v**i</em>,<em>v**j</em>)的平均值的倒数：</p><p><img src="https://images.ptausercontent.com/54" alt="img"></p><p>对于非连通图，所有结点的紧密度中心性都是0。</p><p>给定一个无权的无向图以及其中的一组结点，计算这组结点中每个结点的紧密度中心性。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第一行给出两个正整数<em>N</em>和<em>M</em>，其中<em>N</em>（≤104）是图中结点个数，顺便假设结点从1到<em>N</em>编号；<em>M</em>（≤105）是边的条数。随后的<em>M</em>行中，每行给出一条边的信息，即该边连接的两个结点编号，中间用空格分隔。最后一行给出需要计算紧密度中心性的这组结点的个数<em>K</em>（≤100）以及<em>K</em>个结点编号，用空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按照<code>Cc(i)=x.xx</code>的格式输出<em>K</em>个给定结点的紧密度中心性，每个输出占一行，结果保留到小数点后2位。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> <span class="number">14</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">9</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Cc</span>(<span class="number">3</span>)=<span class="number">0.47</span></span><br><span class="line"><span class="built_in">Cc</span>(<span class="number">4</span>)=<span class="number">0.62</span></span><br><span class="line"><span class="built_in">Cc</span>(<span class="number">9</span>)=<span class="number">0.35</span>结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码-迪杰斯特拉算法"><a href="#AC代码-迪杰斯特拉算法" class="headerlink" title="AC代码(迪杰斯特拉算法)"></a>AC代码(迪杰斯特拉算法)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 9999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M,K;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">10001</span>][<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijstrak</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[N + <span class="number">1</span>],visited[N + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++i)</span><br><span class="line">        dis[i] = mar[s][i];</span><br><span class="line">    visited[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = F,pos;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N ; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dis[j] &lt; min)&#123;</span><br><span class="line">                min = dis[j];</span><br><span class="line">                pos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min == F)  <span class="keyword">break</span>;</span><br><span class="line">        visited[pos] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dis[j] &gt; dis[pos] + mar[pos][j])</span><br><span class="line">                dis[j] = dis[pos] + mar[pos][j]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ;++i)</span><br><span class="line">            sum += dis[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cc(%d)=%.2f\n&quot;</span>,s,<span class="number">1.0</span> * (N - <span class="number">1</span>) / sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">mar[i][j] = F;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        mar[a][b] = mar[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;++i)</span><br><span class="line">        mar[i][i] = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; K;</span><br><span class="line">    <span class="keyword">while</span>(K--)&#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="built_in">dijstrak</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码-弗洛伊德算法"><a href="#AC代码-弗洛伊德算法" class="headerlink" title="AC代码(弗洛伊德算法)"></a>AC代码(弗洛伊德算法)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 9999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M,K;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">10001</span>][<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyld</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= N; a++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= N; b++)</span><br><span class="line">                <span class="keyword">if</span>(mar[a][b] &gt; mar[a][k] + mar[k][b])</span><br><span class="line">                    mar[a][b] = mar[a][k] + mar[k][b]; <span class="comment">//用点k缩短a与b的距离</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;++i)</span><br><span class="line">        sum += mar[s][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cc(%d)=%.2f\n&quot;</span>,s,<span class="number">1.0</span> * (N - <span class="number">1</span>) / sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">fill</span>(mar[<span class="number">0</span>],mar[<span class="number">0</span>] + <span class="number">100</span> * <span class="number">100</span>,F);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        mar[a][b] = mar[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;++i)</span><br><span class="line">        mar[i][i] = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; K;</span><br><span class="line">    <span class="keyword">while</span>(K--)&#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="built_in">floyld</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-图1 列出连通集 (25 分)</title>
      <link href="/2021/10/24/06-%E5%9B%BE2%20Saving%20James%20Bond%20-%20Easy%20Version%20(25%20%E5%88%86)/"/>
      <url>/2021/10/24/06-%E5%9B%BE2%20Saving%20James%20Bond%20-%20Easy%20Version%20(25%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).</p><p>Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing two positive integers <em>N</em> (≤100), the number of crocodiles, and <em>D</em>, the maximum distance that James could jump. Then <em>N</em> lines follow, each containing the (<em>x</em>,<em>y</em>) location of a crocodile. Note that no two crocodiles are staying at the same position.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line “Yes” if James can escape, or “No” if not.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span> <span class="number">20</span></span><br><span class="line"><span class="number">25</span> <span class="number">-15</span></span><br><span class="line"><span class="number">-25</span> <span class="number">28</span></span><br><span class="line"><span class="number">8</span> <span class="number">49</span></span><br><span class="line"><span class="number">29</span> <span class="number">15</span></span><br><span class="line"><span class="number">-35</span> <span class="number">-2</span></span><br><span class="line"><span class="number">5</span> <span class="number">28</span></span><br><span class="line"><span class="number">27</span> <span class="number">-29</span></span><br><span class="line"><span class="number">-8</span> <span class="number">-28</span></span><br><span class="line"><span class="number">-20</span> <span class="number">-35</span></span><br><span class="line"><span class="number">-25</span> <span class="number">-20</span></span><br><span class="line"><span class="number">-13</span> <span class="number">29</span></span><br><span class="line"><span class="number">-30</span> <span class="number">15</span></span><br><span class="line"><span class="number">-35</span> <span class="number">40</span></span><br><span class="line"><span class="number">12</span> <span class="number">12</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="number">-12</span> <span class="number">12</span></span><br><span class="line"><span class="number">12</span> <span class="number">12</span></span><br><span class="line"><span class="number">-12</span> <span class="number">-12</span></span><br><span class="line"><span class="number">12</span> <span class="number">-12</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,D,answer;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> flag;   <span class="comment">//是否访问过</span></span><br><span class="line">    <span class="keyword">int</span> safe;   <span class="comment">//是否可以到达岸边</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> diameter=<span class="number">15</span>;</span><br><span class="line">Node cro[<span class="number">100001</span>];</span><br><span class="line"><span class="comment">//判断当前的位置是否可以到达岸边</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsSafe</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cro[pos].x - D &lt;= <span class="number">-50</span> || cro[pos].x + D &gt;= <span class="number">50</span> || cro[pos].y - D &lt;= <span class="number">-50</span> ||cro[pos].y + D &gt;= <span class="number">50</span>)</span><br><span class="line">        cro[pos].safe = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cro[pos].safe = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cro[pos].safe;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为第一跳要考虑到岛的半径，所以单独写一个函数，判断第一跳能跳到的范围</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstJump</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pow</span>(cro[pos].x,<span class="number">2.0</span>) + <span class="built_in">pow</span>(cro[pos].y,<span class="number">2.0</span>) &lt;= <span class="built_in">pow</span>(D + diameter / <span class="number">2</span>,<span class="number">2.0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断下一个结点是否能跳到</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Jump</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> next)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">pow</span>(cro[cur].x - cro[next].x,<span class="number">2.0</span>) + <span class="built_in">pow</span>(cro[cur].y - cro[next].y,<span class="number">2.0</span>) &lt;= D * D )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先搜索，找到可行解就好</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    cro[pos].flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsSafe</span>(pos)) answer = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cro[i].flag &amp;&amp; <span class="built_in">Jump</span>(pos,i))</span><br><span class="line">                answer = <span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(answer)  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Save007</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//尝试各个连通分量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cro[i].flag &amp;&amp; <span class="built_in">FirstJump</span>(i))&#123;</span><br><span class="line">            answer = <span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(answer)  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(answer) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; D;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)</span><br><span class="line">        cin &gt;&gt; cro[i].x &gt;&gt; cro[i].y;</span><br><span class="line">    <span class="built_in">Save007</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浙大慕课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-图1 列出连通集 (25 分)</title>
      <link href="/2021/10/24/06-%E5%9B%BE1%20%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86%20(25%20%E5%88%86)/"/>
      <url>/2021/10/24/06-%E5%9B%BE1%20%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86%20(25%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>给定一个有<em>N</em>个顶点和<em>E</em>条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到<em>N</em>−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出2个整数<em>N</em>(0&lt;<em>N</em>≤10)和<em>E</em>，分别是图的顶点数和边数。随后<em>E</em>行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按照”{ <em>v</em>1 <em>v</em>2 … <em>v**k</em> }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">7</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> &#125;</span><br><span class="line">&#123; <span class="number">3</span> <span class="number">5</span> &#125;</span><br><span class="line">&#123; <span class="number">6</span> &#125;</span><br><span class="line">&#123; <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">7</span> <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="number">3</span> <span class="number">5</span> &#125;</span><br><span class="line">&#123; <span class="number">6</span> &#125;结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,e;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="keyword">bool</span> book[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">bool</span> book1[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; id;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!book[i] &amp;&amp; mar[id][i] == <span class="number">1</span>)&#123;</span><br><span class="line">            book[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(id);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = qu.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t;</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!book1[i] &amp;&amp; mar[t][i] == <span class="number">1</span>)&#123;</span><br><span class="line">                book1[i] = <span class="literal">true</span>;</span><br><span class="line">                qu.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; e;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= e; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        mar[a][b] = mar[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!book[i])&#123;</span><br><span class="line">            book[i] = <span class="literal">true</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!book1[i])&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">            book1[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">bfs</span>(i);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浙大慕课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-树9 Huffman Codes (30 分)</title>
      <link href="/2021/10/24/05-%E6%A0%919%20Huffman%20Codes%20(30%20%E5%88%86)/"/>
      <url>/2021/10/24/05-%E6%A0%919%20Huffman%20Codes%20(30%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>In 1953, David A. Huffman published his paper “A Method for the Construction of Minimum-Redundancy Codes”, and hence printed his name in the history of computer science. As a professor who gives the final exam problem on Huffman codes, I am encountering a big problem: the Huffman codes are NOT unique. For example, given a string “aaaxuaxz”, we can observe that the frequencies of the characters ‘a’, ‘x’, ‘u’ and ‘z’ are 4, 2, 1 and 1, respectively. We may either encode the symbols as {‘a’=0, ‘x’=10, ‘u’=110, ‘z’=111}, or in another way as {‘a’=1, ‘x’=01, ‘u’=001, ‘z’=000}, both compress the string into 14 bits. Another set of code can be given as {‘a’=0, ‘x’=11, ‘u’=100, ‘z’=101}, but {‘a’=0, ‘x’=01, ‘u’=011, ‘z’=001} is NOT correct since “aaaxuaxz” and “aazuaxax” can both be decoded from the code 00001011001001. The students are submitting all kinds of codes, and I need a computer program to help me determine which ones are correct and which ones are not.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives an integer <em>N</em> (2≤<em>N</em>≤63), then followed by a line that contains all the <em>N</em> distinct characters and their frequencies in the following format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[1] f[1] c[2] f[2] ... c[N] f[N]</span><br></pre></td></tr></table></figure><p>where <code>c[i]</code> is a character chosen from {‘0’ - ‘9’, ‘a’ - ‘z’, ‘A’ - ‘Z’, ‘_’}, and <code>f[i]</code> is the frequency of <code>c[i]</code> and is an integer no more than 1000. The next line gives a positive integer <em>M</em> (≤1000), then followed by <em>M</em> student submissions. Each student submission consists of <em>N</em> lines, each in the format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[i] code[i]</span><br></pre></td></tr></table></figure><p>where <code>c[i]</code> is the <code>i</code>-th character and <code>code[i]</code> is an non-empty string of no more than 63 ‘0’s and ‘1’s.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in each line either “Yes” if the student’s submission is correct, or “No” if not.</p><p>Note: The optimal solution is not necessarily generated by Huffman algorithm. Any prefix code with code length being optimal is considered correct.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line">A <span class="number">1</span> B <span class="number">1</span> C <span class="number">1</span> D <span class="number">3</span> E <span class="number">3</span> F <span class="number">6</span> G <span class="number">6</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">A <span class="number">00000</span></span><br><span class="line">B <span class="number">00001</span></span><br><span class="line">C <span class="number">0001</span></span><br><span class="line">D <span class="number">001</span></span><br><span class="line">E <span class="number">01</span></span><br><span class="line">F <span class="number">10</span></span><br><span class="line">G <span class="number">11</span></span><br><span class="line">A <span class="number">01010</span></span><br><span class="line">B <span class="number">01011</span></span><br><span class="line">C <span class="number">0100</span></span><br><span class="line">D <span class="number">011</span></span><br><span class="line">E <span class="number">10</span></span><br><span class="line">F <span class="number">11</span></span><br><span class="line">G <span class="number">00</span></span><br><span class="line">A <span class="number">000</span></span><br><span class="line">B <span class="number">001</span></span><br><span class="line">C <span class="number">010</span></span><br><span class="line">D <span class="number">011</span></span><br><span class="line">E <span class="number">100</span></span><br><span class="line">F <span class="number">101</span></span><br><span class="line">G <span class="number">110</span></span><br><span class="line">A <span class="number">00000</span></span><br><span class="line">B <span class="number">00001</span></span><br><span class="line">C <span class="number">0001</span></span><br><span class="line">D <span class="number">001</span></span><br><span class="line">E <span class="number">00</span></span><br><span class="line">F <span class="number">10</span></span><br><span class="line">G <span class="number">11</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> heapsize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> heap[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = ++heapsize; data &lt; heap[i / <span class="number">2</span>] ; i /= <span class="number">2</span>)</span><br><span class="line">        heap[i] = heap[i / <span class="number">2</span>];</span><br><span class="line">    heap[i] = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除根节点，然后从第二个结点开始找到第一个比last大的，然后结束循环，进行赋值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = heap[<span class="number">1</span>],i;</span><br><span class="line">    <span class="keyword">int</span> last = heap[heapsize];</span><br><span class="line">    heap[heapsize--] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= heapsize ; i *= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap[i] &gt; heap[i + <span class="number">1</span>] &amp;&amp; i + <span class="number">1</span> &lt;= heapsize) ++i;</span><br><span class="line">        <span class="keyword">if</span>(heap[i] &lt; last) heap[i / <span class="number">2</span>] = heap[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i / <span class="number">2</span>] = last;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否有相同的前缀</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hasPrefixCode</span><span class="params">(string s[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N;++j)</span><br><span class="line">            <span class="keyword">if</span>(s[i].<span class="built_in">find</span>(s[j]) == <span class="number">0</span>)   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,WPL = <span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    heap[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; num;</span><br><span class="line">        m[c] = num;</span><br><span class="line">        <span class="built_in">insert</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = heapsize;</span><br><span class="line">    <span class="comment">//计算WPL</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size ; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp1 = <span class="built_in">Delete</span>(),tmp2 = <span class="built_in">Delete</span>();</span><br><span class="line">        <span class="built_in">insert</span>(tmp1 + tmp2);</span><br><span class="line">        WPL += tmp1 + tmp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> checknum;</span><br><span class="line">    cin &gt;&gt; checknum;</span><br><span class="line">    <span class="keyword">while</span>(checknum--)&#123;</span><br><span class="line">        <span class="keyword">int</span> thiswpl = <span class="number">0</span>;</span><br><span class="line">        string s[N];</span><br><span class="line">        <span class="comment">//先计算wpl</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            <span class="keyword">char</span> c;</span><br><span class="line">            cin &gt;&gt; c &gt;&gt; s[i];</span><br><span class="line">            thiswpl += m[c] * s[i].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先判断WPL是否相等，然后再判断是否有前缀码</span></span><br><span class="line">        <span class="keyword">if</span>(thiswpl == WPL &amp;&amp; !<span class="built_in">hasPrefixCode</span>(s,N))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浙大慕课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-树8 File Transfer (25 分)</title>
      <link href="/2021/10/24/05-%E6%A0%918%20File%20Transfer%20(25%20%E5%88%86)/"/>
      <url>/2021/10/24/05-%E6%A0%918%20File%20Transfer%20(25%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each test case, the first line contains <em>N</em> (2≤<em>N</em>≤104), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and <em>N</em>. Then in the following lines, the input is given in the format:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I c1 c2  </span><br></pre></td></tr></table></figure><p>where <code>I</code> stands for inputting a connection between <code>c1</code> and <code>c2</code>; or</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C c1 c2    </span><br></pre></td></tr></table></figure><p>where <code>C</code> stands for checking if it is possible to transfer files between <code>c1</code> and <code>c2</code>; or</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S</span><br></pre></td></tr></table></figure><p>where <code>S</code> stands for stopping this case.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each <code>C</code> case, print in one line the word “yes” or “no” if it is possible or impossible to transfer files between <code>c1</code> and <code>c2</code>, respectively. At the end of each case, print in one line “The network is connected.” if there is a path between any pair of computers; or “There are <code>k</code> components.” where <code>k</code> is the number of connected components in this network.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">C <span class="number">3</span> <span class="number">2</span></span><br><span class="line">I <span class="number">3</span> <span class="number">2</span></span><br><span class="line">C <span class="number">1</span> <span class="number">5</span></span><br><span class="line">I <span class="number">4</span> <span class="number">5</span></span><br><span class="line">I <span class="number">2</span> <span class="number">4</span></span><br><span class="line">C <span class="number">3</span> <span class="number">5</span></span><br><span class="line">S</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">There are <span class="number">2</span> components.</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">C <span class="number">3</span> <span class="number">2</span></span><br><span class="line">I <span class="number">3</span> <span class="number">2</span></span><br><span class="line">C <span class="number">1</span> <span class="number">5</span></span><br><span class="line">I <span class="number">4</span> <span class="number">5</span></span><br><span class="line">I <span class="number">2</span> <span class="number">4</span></span><br><span class="line">C <span class="number">3</span> <span class="number">5</span></span><br><span class="line">I <span class="number">1</span> <span class="number">3</span></span><br><span class="line">C <span class="number">1</span> <span class="number">5</span></span><br><span class="line">S</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">The network is connected.</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialization</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++i)</span><br><span class="line">        s[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到根节点，并且压缩路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[x] &lt; <span class="number">0</span>)    <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> s[x] = <span class="built_in">Find</span>(s[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过根节点的数组确定这棵树的结点总数，然后把结点少的接到结点多的树上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> Root1,<span class="keyword">int</span> Root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[Root2] &lt; s[Root1])&#123;</span><br><span class="line">        s[Root2] += s[Root1];</span><br><span class="line">        s[Root1] = Root2;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s[Root1] += s[Root2];</span><br><span class="line">        s[Root2] = Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果两个结点不属于同一个集合，则进行合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input_connection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    <span class="keyword">int</span> Root1 = <span class="built_in">Find</span>(u),Root2 = <span class="built_in">Find</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(Root1 != Root2)</span><br><span class="line">        <span class="built_in">Union</span>(Root1,Root2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查两个结点是否属于同一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Check_connection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    <span class="keyword">int</span> Root1 = <span class="built_in">Find</span>(u),Root2 = <span class="built_in">Find</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(Root1 != Root2)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查有几个集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Check_network</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">if</span>(s[i] &lt; <span class="number">0</span>)    ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The network is connected.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot; components.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">Initialization</span>();</span><br><span class="line">    <span class="keyword">char</span> in;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(in)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span> : <span class="built_in">Input_connection</span>();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span> : <span class="built_in">Check_connection</span>();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span> : <span class="built_in">Check_network</span>();<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(in != <span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浙大慕课 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-树7 堆中的路径 (25 分)</title>
      <link href="/2021/10/24/05-%E6%A0%917%20%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%20(25%20%E5%88%86)/"/>
      <url>/2021/10/24/05-%E6%A0%917%20%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%20(25%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>将一系列给定数字插入一个初始为空的小顶堆<code>H[]</code>。随后对任意给定的下标<code>i</code>，打印从<code>H[i]</code>到根结点的路径。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>每组测试第1行包含2个正整数<em>N</em>和<em>M</em>(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的<em>N</em>个要被插入一个初始为空的小顶堆的整数。最后一行给出<em>M</em>个下标。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对输入中给出的每个下标<code>i</code>，在一行中输出从<code>H[i]</code>到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">46</span> <span class="number">23</span> <span class="number">26</span> <span class="number">24</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">24</span> <span class="number">23</span> <span class="number">10</span></span><br><span class="line"><span class="number">46</span> <span class="number">23</span> <span class="number">10</span></span><br><span class="line"><span class="number">26</span> <span class="number">10</span>结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> heap[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> heap_size;<span class="comment">//1~heap_size</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">()</span></span>&#123;</span><br><span class="line">    heap_size = <span class="number">0</span>;</span><br><span class="line">    heap[<span class="number">0</span>] = <span class="number">-100001</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> X)</span></span>&#123;</span><br><span class="line">    heap[++heap_size] = X;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = heap_size;heap[i] &lt; heap[i / <span class="number">2</span>]; i /= <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">swap</span>(heap[i],heap[i / <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">look_heap</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &gt; <span class="number">1</span>; i /= <span class="number">2</span>)</span><br><span class="line">        cout &lt;&lt; heap[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; heap[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,M,t;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">Create</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">Insert</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">look_heap</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浙大慕课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-树6 Complete Binary Search Tree (30 分)</title>
      <link href="/2021/10/24/04-%E6%A0%916%20Complete%20Binary%20Search%20Tree%20(30%20%E5%88%86)/"/>
      <url>/2021/10/24/04-%E6%A0%916%20Complete%20Binary%20Search%20Tree%20(30%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p><ul><li><p>The left subtree of a node contains only nodes with keys less than the node’s key.</p></li><li><p>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</p></li><li><p>Both the left and right subtrees must also be binary search trees.</p></li></ul><p>A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p><p>Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤1000). Then <em>N</em> distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">8</span> <span class="number">1</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">0</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; AVL,CBT;</span><br><span class="line"><span class="keyword">int</span> N,root = <span class="number">1</span>,pos = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//递归建树，不断深入左子树，然后从小到大开始建立结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build_CBT</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root &gt; N)    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * root;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//递归，按照左根右，从小到大的顺序建树</span></span><br><span class="line">        <span class="built_in">Build_CBT</span>(left);</span><br><span class="line">        CBT[root] = AVL[pos++];</span><br><span class="line">        <span class="built_in">Build_CBT</span>(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    AVL = vector&lt;<span class="keyword">int</span>&gt; (N,<span class="number">0</span>);</span><br><span class="line">    CBT = vector&lt;<span class="keyword">int</span>&gt; (N + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; AVL[i];</span><br><span class="line">    <span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(AVL.<span class="built_in">begin</span>(),AVL.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">Build_CBT</span>(root);</span><br><span class="line">    cout &lt;&lt; CBT[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N ; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; CBT[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浙大慕课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-11 Isomorphic (10 分)</title>
      <link href="/2021/10/24/4-11%20Isomorphic%20(10%20%E5%88%86)/"/>
      <url>/2021/10/24/4-11%20Isomorphic%20(10%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>Two trees, <code>T1</code> and <code>T2</code>, are <strong>isomorphic</strong> if <code>T1</code> can be transformed into <code>T2</code> by swapping left and right children of (some of the) nodes in <code>T1</code>. For instance, the two trees in Figure 1 are isomorphic because they are the same if the children of A, B, and G, but not the other nodes, are swapped. Give a polynomial time algorithm to decide if two trees are isomorphic.</p><p> <img src="https://images.ptausercontent.com/37" alt="img"><br>Figure 1</p><h3 id="Format-of-functions"><a href="#Format-of-functions" class="headerlink" title="Format of functions:"></a>Format of functions:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Isomorphic</span><span class="params">( Tree T1, Tree T2 )</span></span>;</span><br></pre></td></tr></table></figure><p>where <code>Tree</code> is defined as the following:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree  Left;</span><br><span class="line">    Tree  Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The function is supposed to return 1 if <code>T1</code> and <code>T2</code> are indeed isomorphic, or 0 if not.</p><h3 id="Sample-program-of-judge"><a href="#Sample-program-of-judge" class="headerlink" title="Sample program of judge:"></a>Sample program of judge:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree  Left;</span><br><span class="line">    Tree  Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">BuildTree</span><span class="params">()</span></span>; <span class="comment">/* details omitted */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Isomorphic</span><span class="params">( Tree T1, Tree T2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree T1, T2;</span><br><span class="line">    T1 = <span class="built_in">BuildTree</span>();</span><br><span class="line">    T2 = <span class="built_in">BuildTree</span>();</span><br><span class="line">    <span class="built_in">printf</span>(“%d\n”, <span class="built_in">Isomorphic</span>(T1, T2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Your function will be put here */</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1-for-the-trees-shown-in-Figure-1"><a href="#Sample-Output-1-for-the-trees-shown-in-Figure-1" class="headerlink" title="Sample Output 1 (for the trees shown in Figure 1):"></a>Sample Output 1 (for the trees shown in Figure 1):</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2-for-the-trees-shown-in-Figure-2"><a href="#Sample-Output-2-for-the-trees-shown-in-Figure-2" class="headerlink" title="Sample Output 2 (for the trees shown in Figure 2):"></a>Sample Output 2 (for the trees shown in Figure 2):</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p><img src="https://images.ptausercontent.com/38" alt="img"><br>Figure2</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​    如果T1,T2都为空，则一定相等，如果其中只有一个不为空或者两个结点的值，则一定不等。</p><p>​    就是比较两个结点各自的左与左，右与右孩子；或者进行一个交换，比较两个结点各自的左与右，右与左孩子</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Isomorphic</span><span class="params">( Tree T1, Tree T2 )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T1 == <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T1 == <span class="literal">NULL</span> || T2 == <span class="literal">NULL</span> || T1 -&gt; Element != T2 -&gt; Element) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (Isomorphic(T1-&gt;Left,T2-&gt;Left)&amp;&amp;Isomorphic(T1-&gt;Right,T2-&gt;Right))||(Isomorphic(T1-&gt;Left,T2-&gt;Right)&amp;&amp;Isomorphic(T1-&gt;Right,T2-&gt;Left));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 周练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-15 根据后序和中序遍历输出先序遍历 (15 分)</title>
      <link href="/2021/10/24/4-15%20%E6%A0%B9%E6%8D%AE%E5%90%8E%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%20(15%20%E5%88%86)/"/>
      <url>/2021/10/24/4-15%20%E6%A0%B9%E6%8D%AE%E5%90%8E%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%20(15%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>本题要求根据给定的一棵二叉树的后序遍历和中序遍历结果，输出该树的先序遍历结果。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行给出正整数<em>N</em>(≤30)，是树中结点的个数。随后两行，每行给出<em>N</em>个整数，分别对应后序遍历和中序遍历结果，数字间以空格分隔。题目保证输入正确对应一棵二叉树。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出<code>Preorder: </code>以及该树的先序遍历结果。数字间有1个空格，行末不得有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2 3 1 5 7 6 4</span><br><span class="line">1 2 3 4 5 6 7结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Preorder: 4 1 3 2 6 5 7</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span> *<span class="title">BTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    BTree left,right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; post,in;</span><br><span class="line"><span class="comment">//利用递归，先从后序遍历中找到根节点，然后在中序遍历中找到该节点，分出左右子树来</span></span><br><span class="line"><span class="comment">//然后后序遍历根的上一个就是右子树的根，而做子树的根位置为根的位置减去右子树全部结点的个数</span></span><br><span class="line"><span class="function">BTree <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span>(pos = start ; pos &lt; end; ++pos)</span><br><span class="line">        <span class="keyword">if</span>(in[pos] == post[root])  <span class="keyword">break</span>;</span><br><span class="line">    BTree node = (BTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BtNode));</span><br><span class="line">    node -&gt; data = post[root];</span><br><span class="line">    node -&gt; left = <span class="built_in">BuildTree</span>(root - <span class="number">1</span> - end + pos,start,pos - <span class="number">1</span>);</span><br><span class="line">    node -&gt; right = <span class="built_in">BuildTree</span>(root - <span class="number">1</span>,pos + <span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BTree bt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!bt) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; bt -&gt; data;</span><br><span class="line">    <span class="built_in">PreOrder</span>(bt -&gt; left);</span><br><span class="line">    <span class="built_in">PreOrder</span>(bt -&gt; right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    post.<span class="built_in">resize</span>(N);</span><br><span class="line">    in.<span class="built_in">resize</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)</span><br><span class="line">        cin &gt;&gt; post[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)</span><br><span class="line">        cin &gt;&gt; in[i];</span><br><span class="line">    BTree bt = <span class="built_in">BuildTree</span>(N - <span class="number">1</span>,<span class="number">0</span>,N - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Preorder:&quot;</span> ;</span><br><span class="line">    <span class="built_in">PreOrder</span>(bt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 周练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-14 还原二叉树</title>
      <link href="/2021/10/24/4-14%20%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2021/10/24/4-14%20%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>4-14 还原二叉树 (15 分)</p><p>给定一棵二叉树的先序遍历序列和中序遍历序列，要求计算该二叉树的高度。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入首先给出正整数N（≤50），为树中结点总数。下面两行先后给出先序和中序遍历序列，均是长度为N的不包含重复英文字母（区别大小写）的字符串。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出为一个整数，即该二叉树的高度。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">ABDFGHIEC</span><br><span class="line">FDHGIBEAC结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span> *<span class="title">BTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    BTree left,right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">string pre,in;<span class="comment">//存储先序和中序序列</span></span><br><span class="line"><span class="comment">//利用递归，先从先序遍历中找到根节点，然后在中序遍历中找到该节点，分出左右子树来</span></span><br><span class="line"><span class="comment">//然后先序遍历根的下一个就是左子树的根，而右子树的根位置为根的位置加上左子树全部结点的个数</span></span><br><span class="line"><span class="function">BTree <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span>(pos = start ; pos &lt; end; ++pos)</span><br><span class="line">        <span class="keyword">if</span>(in[pos] == pre[root])  <span class="keyword">break</span>;</span><br><span class="line">    BTree node = (BTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BtNode));</span><br><span class="line">    node -&gt; data = pre[root];</span><br><span class="line">    node -&gt; left = <span class="built_in">BuildTree</span>(root + <span class="number">1</span>,start,pos - <span class="number">1</span>);</span><br><span class="line">    node -&gt; right = <span class="built_in">BuildTree</span>(root + <span class="number">1</span> + pos - start,pos + <span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">(BTree bt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!bt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">GetHeight</span>(bt -&gt; left),<span class="built_in">GetHeight</span>(bt -&gt; right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">getline</span>(cin,pre);</span><br><span class="line">    <span class="built_in">getline</span>(cin,in);</span><br><span class="line">    BTree bt = <span class="built_in">BuildTree</span>(<span class="number">0</span>,<span class="number">0</span>,N - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">GetHeight</span>(bt) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 周练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-树1 树的同构 (25 分)</title>
      <link href="/2021/10/22/03-%E6%A0%911%20%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84%20(25%20%E5%88%86)/"/>
      <url>/2021/10/22/03-%E6%A0%911%20%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84%20(25%20%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p><table><thead><tr><th><img src="https://images.ptausercontent.com/0c8bbacf-d64e-4c6d-8d4e-1249e33fb0b1.jpg" alt="fig1.jpg"></th></tr></thead><tbody><tr><td>图1</td></tr><tr><td><img src="https://images.ptausercontent.com/29" alt="img"></td></tr><tr><td>图2</td></tr></tbody></table><p>现给定两棵树，请你判断它们是否是同构的。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数<em>N</em> (≤10)，即该树的结点数（此时假设结点从0到<em>N</em>−1编号）；随后<em>N</em>行，第<em>i</em>行对应编号第<em>i</em>个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p><h3 id="输入样例1（对应图1）："><a href="#输入样例1（对应图1）：" class="headerlink" title="输入样例1（对应图1）："></a>输入样例1（对应图1）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">A <span class="number">1</span> <span class="number">2</span></span><br><span class="line">B <span class="number">3</span> <span class="number">4</span></span><br><span class="line">C <span class="number">5</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">6</span> -</span><br><span class="line">G <span class="number">7</span> -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line"><span class="number">8</span></span><br><span class="line">G - <span class="number">4</span></span><br><span class="line">B <span class="number">7</span> <span class="number">6</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">5</span> <span class="number">1</span></span><br><span class="line">H - -</span><br><span class="line">C <span class="number">0</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">2</span> -结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输入样例2（对应图2）："><a href="#输入样例2（对应图2）：" class="headerlink" title="输入样例2（对应图2）："></a>输入样例2（对应图2）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">B <span class="number">5</span> <span class="number">7</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">0</span> <span class="number">3</span></span><br><span class="line">C <span class="number">6</span> -</span><br><span class="line">H - -</span><br><span class="line">D - -</span><br><span class="line">G <span class="number">4</span> -</span><br><span class="line">E <span class="number">1</span> -</span><br><span class="line"><span class="number">8</span></span><br><span class="line">D <span class="number">6</span> -</span><br><span class="line">B <span class="number">5</span> -</span><br><span class="line">E - -</span><br><span class="line">H - -</span><br><span class="line">C <span class="number">0</span> <span class="number">2</span></span><br><span class="line">G - <span class="number">3</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Tree left,right;</span><br><span class="line">    <span class="keyword">int</span> flag;  <span class="comment">//是否访问过</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>;  <span class="comment">//创建树的根节点</span></span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>;  <span class="comment">//构建一棵树</span></span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>;  <span class="comment">//在树中插入新的节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>;  <span class="comment">//检查树的节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T,<span class="keyword">int</span> N)</span></span>;  <span class="comment">//判断是否是同一棵二叉搜索树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span>;     <span class="comment">//将树的各个节点flag重置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span>;  <span class="comment">//释放树的空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,L;</span><br><span class="line">    Tree T;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        cin &gt;&gt; L;</span><br><span class="line">        T = <span class="built_in">MakeTree</span>(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L ; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Judge</span>(T,N))</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">ResetT</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FreeTree</span>(T);</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    Tree T = (Tree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(TreeNode));</span><br><span class="line">    T -&gt; v = V;</span><br><span class="line">    T -&gt; left = T -&gt; right = <span class="literal">NULL</span>;</span><br><span class="line">    T -&gt; flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    Tree T;</span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line">    cin &gt;&gt; V;</span><br><span class="line">    T = <span class="built_in">NewNode</span>(V);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N ; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; V;</span><br><span class="line">        T = <span class="built_in">Insert</span>(T,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) T = <span class="built_in">NewNode</span>(V);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(V &gt; T -&gt; v)</span><br><span class="line">            T -&gt; right = <span class="built_in">Insert</span>(T -&gt; right,V);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T -&gt; left = <span class="built_in">Insert</span>(T -&gt; left,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果flag为1，则当前节点已经访问过，要找的节点可能在左右子树，或者节点已经重复</span></span><br><span class="line">    <span class="keyword">if</span>(T -&gt; flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(V &lt; T -&gt; v)  <span class="keyword">return</span> <span class="built_in">check</span>(T -&gt; left,V);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(V &gt; T -&gt; v) <span class="keyword">return</span> <span class="built_in">check</span>(T -&gt; right,V);</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果没访问过，如果该节点正好是要找的节点，则flag设为1</span></span><br><span class="line">        <span class="keyword">if</span>(V == T -&gt; v)&#123;</span><br><span class="line">            T -&gt; flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为要把一个测试用例的全部数据读完，所以设置flag判断是否是同一棵，读完所有数据后，才返回0或者1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V,flag = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; V;</span><br><span class="line">    <span class="comment">//如果根节点不同，则直接flag = 1</span></span><br><span class="line">    <span class="keyword">if</span>(V != T -&gt; v) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    T -&gt; flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N ; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; V;</span><br><span class="line">        <span class="comment">//如果已经判断不是同一棵，则不用调用check函数</span></span><br><span class="line">        <span class="keyword">if</span>((!flag) &amp;&amp; (!<span class="built_in">check</span>(T,V)))</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; left)   <span class="built_in">ResetT</span>(T -&gt; left);</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; right)  <span class="built_in">ResetT</span>(T -&gt; right);</span><br><span class="line">    T -&gt; flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; left)   <span class="built_in">FreeTree</span>(T -&gt; left);</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; right)  <span class="built_in">FreeTree</span>(T -&gt; right);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浙大慕课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-树4 是否是同一棵二叉搜索树</title>
      <link href="/2021/10/18/04-%E6%A0%914%20%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2021/10/18/04-%E6%A0%914%20%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入包含若干组测试数据。每组数据的第1行给出两个正整数<em>N</em> (≤10)和<em>L</em>，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出<em>N</em>个以空格分隔的正整数，作为初始插入序列。随后<em>L</em>行，每行给出<em>N</em>个插入的元素，属于<em>L</em>个需要检查的序列。</p><p>简单起见，我们保证每个插入序列都是1到<em>N</em>的一个排列。当读到<em>N</em>为0时，标志输入结束，这组数据不要处理。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No结尾无空行</span><br></pre></td></tr></table></figure><p><strong>鸣谢青岛大学周强老师补充测试数据！</strong></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Tree left,right;</span><br><span class="line">    <span class="keyword">int</span> flag;  <span class="comment">//是否访问过</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>;  <span class="comment">//创建树的根节点</span></span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>;  <span class="comment">//构建一棵树</span></span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>;  <span class="comment">//在树中插入新的节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>;  <span class="comment">//检查树的节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T,<span class="keyword">int</span> N)</span></span>;  <span class="comment">//判断是否是同一棵二叉搜索树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span>;     <span class="comment">//将树的各个节点flag重置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span>;  <span class="comment">//释放树的空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,L;</span><br><span class="line">    Tree T;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        cin &gt;&gt; L;</span><br><span class="line">        T = <span class="built_in">MakeTree</span>(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L ; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Judge</span>(T,N))</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">ResetT</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FreeTree</span>(T);</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    Tree T = (Tree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(TreeNode));</span><br><span class="line">    T -&gt; v = V;</span><br><span class="line">    T -&gt; left = T -&gt; right = <span class="literal">NULL</span>;</span><br><span class="line">    T -&gt; flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    Tree T;</span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line">    cin &gt;&gt; V;</span><br><span class="line">    T = <span class="built_in">NewNode</span>(V);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N ; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; V;</span><br><span class="line">        T = <span class="built_in">Insert</span>(T,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) T = <span class="built_in">NewNode</span>(V);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(V &gt; T -&gt; v)</span><br><span class="line">            T -&gt; right = <span class="built_in">Insert</span>(T -&gt; right,V);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T -&gt; left = <span class="built_in">Insert</span>(T -&gt; left,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果flag为1，则当前节点已经访问过，要找的节点可能在左右子树，或者节点已经重复</span></span><br><span class="line">    <span class="keyword">if</span>(T -&gt; flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(V &lt; T -&gt; v)  <span class="keyword">return</span> <span class="built_in">check</span>(T -&gt; left,V);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(V &gt; T -&gt; v) <span class="keyword">return</span> <span class="built_in">check</span>(T -&gt; right,V);</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果没访问过，如果该节点正好是要找的节点，则flag设为1</span></span><br><span class="line">        <span class="keyword">if</span>(V == T -&gt; v)&#123;</span><br><span class="line">            T -&gt; flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为要把一个测试用例的全部数据读完，所以设置flag判断是否是同一棵，读完所有数据后，才返回0或者1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V,flag = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; V;</span><br><span class="line">    <span class="comment">//如果根节点不同，则直接flag = 1</span></span><br><span class="line">    <span class="keyword">if</span>(V != T -&gt; v) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    T -&gt; flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N ; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; V;</span><br><span class="line">        <span class="comment">//如果已经判断不是同一棵，则不用调用check函数</span></span><br><span class="line">        <span class="keyword">if</span>((!flag) &amp;&amp; (!<span class="built_in">check</span>(T,V)))</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; left)   <span class="built_in">ResetT</span>(T -&gt; left);</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; right)  <span class="built_in">ResetT</span>(T -&gt; right);</span><br><span class="line">    T -&gt; flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; left)   <span class="built_in">FreeTree</span>(T -&gt; left);</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; right)  <span class="built_in">FreeTree</span>(T -&gt; right);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浙大慕课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ string find()的返回值</title>
      <link href="/2021/10/18/C++%20string%20find()%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
      <url>/2021/10/18/C++%20string%20find()%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = s.<span class="built_in">find</span>(<span class="string">&quot;o&quot;</span>);</span><br><span class="line">        cout &lt;&lt; index &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>能找到，则返回在字符串的第一个位置的下标</li><li>找不到的话返回-1</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ fill和memset</title>
      <link href="/2021/10/02/C++%20fill%E5%92%8Cmemset/"/>
      <url>/2021/10/02/C++%20fill%E5%92%8Cmemset/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><ul><li><p>memset 函数</p><ul><li>按照字节填充某字符</li><li>在头文件<cstring>中</cstring></li></ul></li><li><p> fill 函数</p></li><li><p>按照单元赋值，将一个区间的元素都赋同一个值</p></li><li><p>在命名空间std里</p></li><li><p>因为memset函数按照直接填充，所以一般memset只能用来填充char型数组，因为只有char型占一字节，如果填充int型数组，除了0和-1，其他的不能，因为只有00000000 = 0，-1同理，如果每一位都填充1，则11111111 = -1.</p></li><li><p>而fill 函数可以赋任何值</p><ul><li><p>赋值int数组：fill(arr , arr + n ,要赋的值)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[n];</span><br><span class="line">    <span class="built_in">fill</span>(arr, arr + n, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;   &quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给vector赋值：fill(v.begin(),v.end(),要赋的值)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">      <span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">          cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- memset的用法</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[n];</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;   &quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ cin和getline</title>
      <link href="/2021/09/30/C++%20cin%E5%92%8Cgetline/"/>
      <url>/2021/09/30/C++%20cin%E5%92%8Cgetline/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>​    cin是在缓存区里把字符读走，会剩下\n在缓存区中，但getline对\n非常敏感，导致getline刚开始读取缓存区里直接读到\n就结束读入数据。</p><p>​    cin，流提取运算符根据它后面的变量类型读取数据，从非空白符号开始，遇到Enter、Space、Tab键时结束。</p><p>​    getline函数从istream中读取一行数据，当遇到”\n”时结束返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;变量n : &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串s : &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如上面，输入123后，123赋值给n，字符串读取缓冲区的\n直接结束。</p><p>可以在 cin &gt;&gt; n;后面加上cin.ignore();或者getchar();来解决</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迷宫的最短路径</title>
      <link href="/2021/09/23/%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/09/23/%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>在一个m * n的迷宫中，0表示通路，1表示墙壁。左上角为迷宫的入口，右下角为迷宫的出口。求到达迷宫入口的最短路径。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    为了省去判断是否为迷宫边缘，可以把迷宫整体加一层强，变成（m + 2）* (n + 2)的迷宫，入口则变成了（1,1），出口为（m,n）.为了能够记录路径，我们可以记录当前的点的前驱点。</p><p>​    用结构体数组代替队列，以便进行打印路径。</p><p>​    我们从入口开始，进行试探。</p><p>​    从队头开始试探，只要有临近的格子能走就入队，然后队头出队，再从新的队头探索。一旦到达出口，就是最短路径，然后打印路径，因为没有去走多余的格子。就是直接试探当前点能走的临近的格子。</p><p>​    如果有多条路径可以到达终点，最短路径，其前驱的节点的数目少，则最先入队，所以只要谁最先判断成功是终点，谁就是最短路径。</p><p>​    为了防止走到重复节点，把走过的格子都赋值为-1即可。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 8</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; Item;</span><br><span class="line">Item mv[<span class="number">8</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[m + <span class="number">2</span>][n + <span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printpath</span><span class="params">(Node qu[], <span class="keyword">int</span> rear)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rear != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printpath</span>(qu,qu[rear].pre);</span><br><span class="line">        <span class="keyword">if</span>(qu[rear].x != m &amp;&amp; qu[rear].y != n)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) -&gt;&quot;</span>,qu[rear].x,qu[rear].y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>,qu[rear].x,qu[rear].y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node qu[m * n];</span><br><span class="line">    qu[front].x = <span class="number">1</span>;qu[front].y = <span class="number">1</span>;qu[front].pre = <span class="number">-1</span>;   <span class="comment">//记录入口</span></span><br><span class="line">    <span class="keyword">int</span> x, y, i, j;</span><br><span class="line">    <span class="keyword">while</span>(front &lt;= rear) &#123;</span><br><span class="line">        x = qu[front].x;y = qu[front].y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span> ; v &lt; <span class="number">8</span>; ++v) &#123;</span><br><span class="line">            i = x + mv[v].x;j = y + mv[v].y;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j] == <span class="number">0</span>) &#123;                            <span class="comment">//新点可到达的话，入队</span></span><br><span class="line">                arr[i][j] = <span class="number">-1</span>;</span><br><span class="line">                ++rear;</span><br><span class="line">                qu[rear].x = i;qu[rear].y = j;qu[rear].pre = front;</span><br><span class="line">                <span class="keyword">if</span>(i == m &amp;&amp; j == n) &#123;                  <span class="comment">//新的点如果是入口，则打印路径</span></span><br><span class="line">                    <span class="built_in">printpath</span>(qu, rear);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++front;            <span class="comment">//出队，继续试探一下个点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">path</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构复习 </tag>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迷宫求解</title>
      <link href="/2021/09/23/%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/"/>
      <url>/2021/09/23/%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>在一个m * n的迷宫中，0表示通路，1表示墙壁。左上角为迷宫的入口，右下角为迷宫的出口。判断迷宫是否有解。</p><h2 id="算法思路（深度优先搜索）"><a href="#算法思路（深度优先搜索）" class="headerlink" title="算法思路（深度优先搜索）"></a>算法思路（深度优先搜索）</h2><p>​    为了省去判断是否为迷宫边缘，可以把迷宫整体加一层强，变成（m + 2）* (n + 2)的迷宫，入口则变成了（1,1），出口为（m,n）.</p><p>​    我们从入口开始，进行试探。</p><p>​    当前格子具有两种情况:</p><ol><li>它临近的格子可走，则将当前格子入栈，移动到新的格子上，继续试探。</li><li>它所有临近的格子不可走，则回到已经入栈的上一个格子，上一个格子出栈。继续试探。</li></ol><p>​    当前格子正是出口时，return 1,如果搜索完所有能到达的格子都无法到达出口时，return 0.    </p><p>​    为了防止走到重复节点，把走过的格子都赋值为-1即可。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 8</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;Item;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;Node;</span><br><span class="line">Item mv[<span class="number">8</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> vis[m + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> arr[m + <span class="number">2</span>][n + <span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;    <span class="comment">//深度优先搜索的代码</span></span><br><span class="line">    <span class="keyword">if</span>(x == m &amp;&amp; y == n)    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[x + mv[i].x][y + mv[i].y] == <span class="number">0</span> &amp;&amp; vis[x + mv[i].x][y + mv[i].y] == <span class="number">0</span>)&#123;</span><br><span class="line">            vis[x + mv[i].x][y + mv[i].y] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x + mv[i].x,y + mv[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> arr[][n + <span class="number">2</span>])</span></span>&#123;</span><br><span class="line">    stack&lt;Node&gt; s;</span><br><span class="line">    Node tmp;</span><br><span class="line">    <span class="keyword">int</span> x,y,d,i,j;</span><br><span class="line">    tmp.x = <span class="number">1</span>;tmp.y = <span class="number">1</span>;tmp.d = <span class="number">-1</span>;</span><br><span class="line">    s.<span class="built_in">push</span>(tmp);</span><br><span class="line">    <span class="keyword">while</span>(s.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        tmp = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        x = tmp.x;y = tmp.y;d = tmp.d + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(d &lt; <span class="number">8</span>)&#123;</span><br><span class="line">            i = x + mv[d].x;</span><br><span class="line">            j = y + mv[d].y;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                tmp = &#123;x,y,d&#125;;</span><br><span class="line">                s.<span class="built_in">push</span>(tmp);</span><br><span class="line">                x = i;y = j;arr[x][y] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(x == m &amp;&amp; y == n)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>    d = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ++d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    vis[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">path</span>(arr))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构复习 </tag>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表合并</title>
      <link href="/2021/09/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6/"/>
      <url>/2021/09/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>设有两个单链表A、B，其中元素递增有序，编写算法将A、B归并成一个按元素值递减（允许有相同值）有序的链表C，要求用A、B的原结点形成，不能重新申请节点。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>利用A、B两表有序的特点，依次进行比较，将当前较小值取出，插入到C表的头部，得到的C表为递降有序。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">merge</span><span class="params">(LinkList A, LinkList B)</span> </span>&#123;</span><br><span class="line">    LinkList C;</span><br><span class="line">    LinkNode *p, *q, *s;</span><br><span class="line">    p = A -&gt; next;</span><br><span class="line">    q = B -&gt; next;</span><br><span class="line">    C = A;</span><br><span class="line">    C -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p -&gt; data &lt; q -&gt; data) &#123;</span><br><span class="line">            s = p;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            s -&gt; next = C -&gt; next;</span><br><span class="line">            C -&gt; next = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)  p = q;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        s = p;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        s -&gt; next = C -&gt; next;</span><br><span class="line">        C -&gt; next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表逆置</title>
      <link href="/2021/09/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE/"/>
      <url>/2021/09/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>依次取出原链表的每个结点，并将其作为第一个节点进行头插法，指针p用来指向原表中的当前节点，p为空时结束</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(LinkList head)</span> </span>&#123;</span><br><span class="line">    LinkNode *p, *q;</span><br><span class="line">    p = head -&gt; next;</span><br><span class="line">    head -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        q -&gt; next = head -&gt; next;</span><br><span class="line">        head -&gt; next = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19. 删除链表的倒数第 N 个结点</title>
      <link href="/2021/09/19/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2021/09/19/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"></p><blockquote><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：head = [1], n = 1<br>输出：[]</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：head = [1,2], n = 1<br>输出：[1]</p></blockquote><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 sz</li><li>1 &lt;= sz &lt;= 30</li><li>0 &lt;= Node.val &lt;= 100</li><li>1 &lt;= n &lt;= sz</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>定义快慢指针，快指针先移动k - 1步，然后快慢指针一起移动，当快指针移动到链表表尾时，慢指针移动到倒数第k的结点的前驱结点，然后让前驱结点指向下一结点的下一个节点，实现删除。</p><p>当链表长不足k时，返回慢指针的下一个节点，即删除第一个节点。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* left = head;</span><br><span class="line">        ListNode* right = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            right = right -&gt; next;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">nullptr</span>)   <span class="keyword">return</span> left -&gt; next;</span><br><span class="line">        <span class="keyword">while</span>(right -&gt; next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            right = right -&gt; next;</span><br><span class="line">            left = left -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        left -&gt; next = left -&gt; next -&gt; next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>678. 有效的括号字符串</title>
      <link href="/2021/09/12/678.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/09/12/678.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><ol><li>任何左括号 <strong>(</strong> 必须有相应的右括号 **)**。</li><li>任何右括号 <strong>)</strong> 必须有相应的左括号 <strong>(</strong> 。</li><li>左括号 <strong>(</strong> 必须在对应的右括号之前 **)**。</li><li>*****可以被视为单个右括号 <strong>)</strong> ，或单个左括号 <strong>(</strong> ，或一个空字符串。</li><li>一个空字符串也被视为有效字符串。</li></ol><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parenthesis-string">https://leetcode-cn.com/problems/valid-parenthesis-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>示例 1：</strong></p><blockquote><p>输入: “()”<br>输出: True</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入: “(*)”<br>输出: True</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入: “(*))”<br>输出: True</p></blockquote><p><strong>注意：</strong></p><ul><li>字符串大小将在 [1，100] 范围内。</li></ul><h2 id="题解（贪心）"><a href="#题解（贪心）" class="headerlink" title="题解（贪心）"></a>题解（贪心）</h2><p>从左到右遍历字符串，遍历过程中，未匹配的左括号数量可能会出现如下变化：</p><ul><li>如果遇到左括号，则未匹配的左括号数量加 1；</li><li>如果遇到右括号，则需要有一个左括号和右括号匹配，因此未匹配的左括号数量减 1；</li><li>如果遇到星号，由于星号可以看成左括号、右括号或空字符串，因此未匹配的左括号数量可能加 1、减 1 或不变。</li></ul><p>基于上述结论，可以在遍历过程中维护未匹配的左括号数量可能的最小值和最大值，根据遍历到的字符更新最小值和最大值：</p><ul><li>如果遇到左括号，则将最小值和最大值分别加 1；</li><li>如果遇到右括号，则将最小值和最大值分别减 1；</li><li>如果遇到星号，则将最小值减 1，将最大值加 1。</li></ul><p>任何情况下，未匹配的左括号数量必须非负，因此当最大值变成负数时，说明没有左括号可以和右括号匹配，返回 false。</p><p>当最小值为 0 时，不应将最小值继续减少，以确保最小值非负。</p><p>遍历结束时，所有的左括号都应和右括号匹配，因此只有当最小值为 0 时，字符串 s才是有效的括号字符串。</p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/valid-parenthesis-string/solution/you-xiao-de-gua-hao-zi-fu-chuan-by-leetc-osi3/">https://leetcode-cn.com/problems/valid-parenthesis-string/solution/you-xiao-de-gua-hao-zi-fu-chuan-by-leetc-osi3/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。    </p><h2 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkValidString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lmin = <span class="number">0</span>,lmax = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                ++lmin;</span><br><span class="line">                ++lmax;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                --lmax;</span><br><span class="line">                lmin = <span class="built_in">max</span>(lmin - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(lmax &lt; <span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ++lmax;</span><br><span class="line">                lmin = <span class="built_in">max</span>(lmin - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lmin == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>​    <strong>时间复杂度：</strong>O(n)</p><p>​    <strong>空间复杂度：</strong>O(1)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>881. 救生艇</title>
      <link href="/2021/08/26/881.%20%E6%95%91%E7%94%9F%E8%89%87/"/>
      <url>/2021/08/26/881.%20%E6%95%91%E7%94%9F%E8%89%87/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。</p><p>返回载到每一个人所需的最小船数。(保证每个人都能被船载)。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/boats-to-save-people">https://leetcode-cn.com/problems/boats-to-save-people</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：people = [1,2], limit = 3<br>输出：1<br>解释：1 艘船载 (1, 2)</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：people = [3,2,2,1], limit = 3<br>输出：3<br>解释：3 艘船分别载 (1, 2), (2) 和 (3)</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：people = [3,5,3,4], limit = 5<br>输出：4<br>解释：4 艘船分别载 (3), (3), (4), (5)</p></blockquote><p><strong>提示：</strong></p><ul><li>1 &lt;= people.length &lt;= 50000</li><li>1 &lt;= people[i] &lt;= limit &lt;= 30000</li></ul><h2 id="题解（贪心）"><a href="#题解（贪心）" class="headerlink" title="题解（贪心）"></a>题解（贪心）</h2><p>​    由于一条船最多做两个人，首先考虑体重最小的和最高的，如果两个人能做一条船，则是最优做法，这样把求解范围缩小到 n - 2,如果体重和超过限制，则没有人能和最重的人做一条船，则最重的单独做一条船，把求解范围缩小到 n - 1</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRescueBoats</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; people, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = people.<span class="built_in">size</span>() - <span class="number">1</span>,cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(people[left] + people[right] &lt;= limit)</span><br><span class="line">                ++left;</span><br><span class="line">            --right;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802. 找到最终的安全状态</title>
      <link href="/2021/08/05/802.%20%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/"/>
      <url>/2021/08/05/802.%20%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。</p><p>对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。</p><p>返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。</p><p>该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-eventual-safe-states">https://leetcode-cn.com/problems/find-eventual-safe-states</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>示例 1：</strong></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png"></p><blockquote><p>输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]]<br>输出：[2,4,5,6]<br>解释：示意图如上。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]<br>输出：[4]</p></blockquote><p><strong>提示：</strong></p><ul><li>n == graph.length</li><li>1 &lt;= n &lt;= 104</li><li>0 &lt;= graph[i].length &lt;= n</li><li>graph[i] 按严格递增顺序排列。</li><li>图中可能包含自环。</li><li>图中边的数目在范围 [1, 4 * 104] 内</li></ul><h2 id="题解（DFS、三色标记）"><a href="#题解（DFS、三色标记）" class="headerlink" title="题解（DFS、三色标记）"></a>题解（DFS、三色标记）</h2><p>​    若起始节点在一个环内，或者能到达一个环，则这个节点是不安全的。否则，该节点是安全的。</p><p>​    我们可以使用深度优先搜索来找环，并在深度优先搜索时，用三种颜色对节点进标记，标记的规则如下：</p><ul><li>白色（用0表示）：该节点尚未被访问</li><li>灰色（用1表示）：该节点位于递归栈中，或者在某个环上</li><li>黑色（用2表示）：该节点搜索完毕，是一个安全节点。</li></ul><p>​    当我们首次访问一个节点时，将其标记为灰色，并继续搜索与其相连的节点。</p><p>​    如果在搜索过程中遇到了一个灰色节点，则说明找到了一个环，此时退出搜索，栈中的节点仍保持为灰色，这一做法可以将[找到了环]这一信息传递到栈中的所有节点上。</p><p>​    如果搜索过程中没有遇到灰色节点，则说明没有遇到环，那么递归返回前，我们将其标记由灰色改为黑色，即表示它是一个安全的节点。</p><h2 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">eventualSafeNodes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">color</span><span class="params">(n)</span></span>; </span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>)&gt; safe = [&amp;](<span class="keyword">int</span> x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[x] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> color[x] == <span class="number">2</span>;</span><br><span class="line">            color[x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y : graph[x])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">safe</span>(y))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            color[x] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">safe</span>(i))</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度：O(n+m)，其中 n 是图中的点数，m 是图中的边数。</p></li><li><p>空间复杂度：O(n)，存储节点颜色以及递归栈的开销均为 O(n)</p></li></ul><h2 id="题解（拓扑排序）"><a href="#题解（拓扑排序）" class="headerlink" title="题解（拓扑排序）"></a>题解（拓扑排序）</h2><p>​    根据题意，若一个节点没有出边，则该节点是安全的；若一个节点出边相连的点都是安全的，则该节点是安全的。</p><p>​    根据这一性质，我们可以将图中所有边反向，得到一个反图，然后在反图上进行拓扑排序。</p><p>​    具体来说，首先得到反图rg及其入度数组indeg。将所有入度为0的点加入队列，然后不断取出队首数组，将其出边相连的点的入度减一，若该点入度减一后为0，则该点加入队列，如此循环至队列为空。循环结束后，所有入度为0的节点均为安全的。我们遍历入度数组，并将入度为0的点加入答案数组。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">eventualSafeNodes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">rg</span>(n);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">indeg</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j : graph[i])&#123;</span><br><span class="line">                rg[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            indeg[i] = graph[i].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indeg[i] == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> it : rg[t])&#123;</span><br><span class="line">                <span class="keyword">if</span>(--indeg[it] == <span class="number">0</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indeg[i] == <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度：O(n+m)，其中 n 是图中的点数，m 是图中的边数。</p></li><li><p>空间复杂度：O(n+m)。需要 O(n+m) 的空间记录反图。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 三色标记 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>581. 最短无序连续子数组</title>
      <link href="/2021/08/03/581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2021/08/03/581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 最短 子数组，并输出它的长度。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray">https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [2,6,4,8,10,9,15]<br>输出：5<br>解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [1,2,3,4]<br>输出：0</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：nums = [1]<br>输出：0</p></blockquote><p><strong>提示：</strong></p><ul><li>1 &lt;= nums.length &lt;= 104</li><li>-105 &lt;= nums[i] &lt;= 105</li></ul><h2 id="题解（双指针）"><a href="#题解（双指针）" class="headerlink" title="题解（双指针）"></a>题解（双指针）</h2><p>​        将数组分成三部分numsA,numsB,numsC，然后对numsB进行排序，使整体数组有序，即整体排序后numsA和numsC不变。我们只要找到numsB，返回其长度即可。<br>      我们创建数组nums的拷贝t,然后对其排序，分别从左和右进行比较，找到第一个不相同的位置，确定numsB的左边界和右边界，返回numsB的长度。<br>      特别地，当原数组有序时，numB的长度为0，直接返回结果。</p><h2 id="实现代码：（双指针）"><a href="#实现代码：（双指针）" class="headerlink" title="实现代码：（双指针）"></a>实现代码：（双指针）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_sorted</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>())) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; t = nums;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(t[left] == nums[left])</span><br><span class="line">            ++left;</span><br><span class="line">        <span class="keyword">while</span>(t[right] == nums[right])</span><br><span class="line">            --right;</span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>​    <strong>时间复杂度：</strong>O(nlogn)，其中 n 为给定数组的长度。我们需要 O(nlogn) 的时间进行排序，以及 O(n) 的时间遍历数组，因此总时间复杂度为O(nlogn)。</p><p>​    <strong>空间复杂度：</strong>O(n)，其中 n为给定数组的长度。我们需要额外的一个数组保存排序后的数组t.</p><h2 id="题解（一次遍历）"><a href="#题解（一次遍历）" class="headerlink" title="题解（一次遍历）"></a>题解（一次遍历）</h2><p>​    假设numsB在nums中对应区间为 [left,right],注意到numsB和numsC的任意一个数都大于等于numsA中任意一个数，因此有numsA中每一个数都满足：</p><p>​    numsⅰ ≤ min numsj (i + 1 ≤  j  ≤  n  - 1 )</p><p>我们可以从大到小枚举 i，用minn记录民 numsj(i + 1 ≤  j  ≤  n  - 1)。每次移动i,都可以O（1）地更新minn。这样最后一个使得不等式成立的i即为left.</p><p>​    同理，我们可以用类似的方法确定right。我们可以通过一次循环同时完成左右边界的计算。</p><p>​    特别地，当原数组有序时，numB的长度为0，直接返回结果。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxn = INT_MIN, right = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> minn = INT_MAX, left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxn &gt; nums[i])</span><br><span class="line">                right = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                maxn = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(minn &lt; nums[n - <span class="number">1</span> - i])</span><br><span class="line">                left = n - <span class="number">1</span> -i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                minn = nums[n - <span class="number">1</span> - i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right == <span class="number">-1</span> ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>​    <strong>时间复杂度：</strong>O(n)，其中 n 是给定数组的长度，我们仅需要遍历该数组一次。</p><p>​    <strong>空间复杂度：</strong>O(1)。我们只需要常数的空间保存若干变量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>743. 网络延迟时间</title>
      <link href="/2021/08/02/743.%20%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/"/>
      <url>/2021/08/02/743.%20%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>有 n 个网络节点，标记为 1 到 n。</p><p>给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。</p><p>现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/network-delay-time">https://leetcode-cn.com/problems/network-delay-time</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2<br>输出：2</p><img src="https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png" style="zoom: 100%;"></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：times = [[1,2,1]], n = 2, k = 1<br>输出：1</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：times = [[1,2,1]], n = 2, k = 2<br>输出：-1</p></blockquote><p><strong>提示：</strong></p><ul><li>1 &lt;= k &lt;= n &lt;= 100</li><li>1 &lt;= times.length &lt;= 6000</li><li>times[i].length == 3</li><li>1 &lt;= ui, vi &lt;= n</li><li>ui != vi</li><li>0 &lt;= wi &lt;= 100</li><li>所有 (ui, vi) 对都 互不相同（即，不含重复边）</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>​    Dijkstra算法：从源点开始，更新未确定节点到确定节点的路径，然后从未确定节点中选择路径最小的，加入确定节点中，然后更新新加入节点与其临近节点的距离，重复上述步骤，直到全部节点都确定。</p><h2 id="实现代码：（枚举）"><a href="#实现代码：（枚举）" class="headerlink" title="实现代码：（枚举）"></a>实现代码：（枚举）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> inf = INT_MAX / <span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">cost</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, inf));</span><br><span class="line">        <span class="keyword">int</span> d[n];</span><br><span class="line">        <span class="keyword">bool</span> used[n];</span><br><span class="line">        <span class="built_in">fill</span>(d,d + n,inf);</span><br><span class="line">        <span class="built_in">fill</span>(used,used + n ,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : times)&#123;</span><br><span class="line">            cost[it[<span class="number">0</span>] - <span class="number">1</span>][it[<span class="number">1</span>] - <span class="number">1</span>] =  it[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        d[k<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//从尚未使用过的顶点中选择一个距离最小的顶点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>;u &lt; n;++u)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!used[u] &amp;&amp; (v == <span class="number">-1</span> || d[u] &lt; d[v]))</span><br><span class="line">                    v = u;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            used[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n;++u)&#123;</span><br><span class="line">                d[u] = <span class="built_in">min</span>(d[u],d[v] + cost[v][u]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = *<span class="built_in">max_element</span>(d, d + n);</span><br><span class="line">        <span class="keyword">return</span> ans == inf ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ-1979 Red and Black</title>
      <link href="/2021/08/01/POJ-1979%20Red%20and%20Black/"/>
      <url>/2021/08/01/POJ-1979%20Red%20and%20Black/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.</p><p>Write a program to count the number of black tiles which he can reach by repeating the moves described above.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.</p><p>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.</p><p>‘.’ - a black tile<br>‘#’ - a red tile<br>‘@’ - a man on a black tile(appears exactly once in a data set)<br>The end of the input is indicated by a line consisting of two zeros.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">9</span></span><br><span class="line">....#.</span><br><span class="line">.....#</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">#@...#</span><br><span class="line">.#..#.</span><br><span class="line"><span class="number">11</span> <span class="number">9</span></span><br><span class="line">.#.........</span><br><span class="line">.#.#######.</span><br><span class="line">.#.#.....#.</span><br><span class="line">.#.#.###.#.</span><br><span class="line">.#.#..@#.#.</span><br><span class="line">.#.#####.#.</span><br><span class="line">.#.......#.</span><br><span class="line">.#########.</span><br><span class="line">...........</span><br><span class="line"><span class="number">11</span> <span class="number">6</span></span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..###</span><br><span class="line">..#..#..#@.</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line"><span class="number">7</span> <span class="number">7</span></span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">###.###</span><br><span class="line">...@...</span><br><span class="line">###.###</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">45</span></span><br><span class="line"><span class="number">59</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>​    直接DFS，通过visited数组记录是否走过，避免重复访问，然后对当前节点进行移动，返回结果</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 21</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> m,n,sx,sy;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> mar[N][N];</span><br><span class="line"><span class="keyword">int</span> visited[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    visited[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> nx = x + dx[i],ny = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(nx &lt; <span class="number">1</span> || nx &gt; n|| ny &lt; <span class="number">1</span> || ny &gt; m)    <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited[nx][ny] || mar[nx][ny] != <span class="string">&#x27;.&#x27;</span>)   <span class="keyword">continue</span>;</span><br><span class="line">        ret += <span class="built_in">dfs</span>(nx,ny);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; m &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)&#123;</span><br><span class="line">                cin &gt;&gt; mar[i][j];</span><br><span class="line">                <span class="keyword">if</span>(mar[i][j] == <span class="string">&#x27;@&#x27;</span>)    sx = i,sy = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">dfs</span>(sx,sy) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1337. 矩阵中战斗力最弱的 K 行</title>
      <link href="/2021/08/01/1337.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%88%98%E6%96%97%E5%8A%9B%E6%9C%80%E5%BC%B1%E7%9A%84%20K%20%E8%A1%8C/"/>
      <url>/2021/08/01/1337.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%88%98%E6%96%97%E5%8A%9B%E6%9C%80%E5%BC%B1%E7%9A%84%20K%20%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。</p><p>请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。</p><p>如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。</p><p>军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix">https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong>mat =<br>[[1,1,0,0,0],<br> [1,1,1,1,0],<br> [1,0,0,0,0],<br> [1,1,0,0,0],<br> [1,1,1,1,1]],<br>k = 3<br><strong>输出：</strong>[2,0,3]<br><strong>解释：</strong><br>每行中的军人数目：<br>行 0 -&gt; 2<br>行 1 -&gt; 4<br>行 2 -&gt; 1<br>行 3 -&gt; 2<br>行 4 -&gt; 5<br>从最弱到最强对这些行排序后得到 [2,0,3,1,4]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong>mat =<br>[[1,0,0,0],<br> [1,1,1,1],<br> [1,0,0,0],<br> [1,0,0,0]],<br>k = 2<br><strong>输出：</strong>[0,2]<br><strong>解释：</strong><br>每行中的军人数目：<br>行 0 -&gt; 1<br>行 1 -&gt; 4<br>行 2 -&gt; 1<br>行 3 -&gt; 1<br>从最弱到最强对这些行排序后得到 [0,2,3,1]</p></blockquote><p><strong>提示：</strong></p><ul><li>m == mat.length</li><li>n == mat[i].length</li><li>2 &lt;= n, m &lt;= 100</li><li>1 &lt;= k &lt;= m</li><li>matrix[i][j] 不是 0 就是 1</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>二元组：</strong>因为map不能自己实现sort排序，所以采用tuple二元组，利用二分查找记录大小，存储行和大小，然后sort排序，最后返回结果。<br>​    二分查找：找出一行中最后那个1的位置，如果其位置为pos,那么这一行 1 的个数为pos + 1，如果这一行没有 1，那么令pos = -1。</p><p><strong>优先队列：</strong>题目给定的是判断第 i行弱于第 j 行的判断依据，我们便维护一个优先队列，按照 pair&lt;士兵数量，行索引&gt; 的方式将每行信息存入优先队列。由于默认为大顶堆，我们要找最小的 K行，则需要先将前 n - K行忽略（在代码中弹出队列即可），将后 K 行存入结果序列后，再逆序即可（逆序是因为从队列访问顺序是从强到弱，而我们需要从弱到强）。</p><h2 id="实现代码（二元组）"><a href="#实现代码（二元组）" class="headerlink" title="实现代码（二元组）"></a>实现代码（二元组）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;a,tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(get&lt;<span class="number">1</span>&gt;(a) == get&lt;<span class="number">1</span>&gt;(b))  </span><br><span class="line">            <span class="keyword">return</span> get&lt;<span class="number">0</span>&gt;(a) &lt; get&lt;<span class="number">0</span>&gt;(b);</span><br><span class="line">        <span class="keyword">return</span> get&lt;<span class="number">1</span>&gt;(a)&lt;get&lt;<span class="number">1</span>&gt;(b);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">kWeakestRows</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;  res[mat.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; mat.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            get&lt;<span class="number">0</span>&gt;(res[i]) = i;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>,r = mat[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) /<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][mid]) &#123;</span><br><span class="line">                    pos = mid;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>    r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            get&lt;<span class="number">1</span>&gt;(res[i]) = pos + <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(res,res+mat.<span class="built_in">size</span>(),cmp);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;++i)</span><br><span class="line">            ret.<span class="built_in">push_back</span>(get&lt;<span class="number">0</span>&gt;(res[i]));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O（max(mlogn,n<em>log2(n))）<br>二分查找：O（mlogn）<br>sort排序：O（n</em>log2(n)）</li><li>空间复杂度：O（n）</li></ul><h2 id="实现代码（优先队列）"><a href="#实现代码（优先队列）" class="headerlink" title="实现代码（优先队列）"></a>实现代码（优先队列）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">kWeakestRows</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span> n = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 记录当前行士兵个数</span></span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x : mat[i]) &#123;</span><br><span class="line">                <span class="comment">// x = 0 不会影响结果</span></span><br><span class="line">                cnt += x;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;cnt, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前优先队列是从强到弱排的</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; k) q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().second);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">reverse</span>(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：O(max(nm, nlgn))，首先遍历了一遍矩阵，复杂度 O(nm)，将每行存入优先队列复杂度 O(nlgn)。</li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 二元组 </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL vector的push_back()和emplace_back()</title>
      <link href="/2021/07/31/C++%20STL%20vector%E7%9A%84push_back()%E5%92%8Cemplace_back()/"/>
      <url>/2021/07/31/C++%20STL%20vector%E7%9A%84push_back()%E5%92%8Cemplace_back()/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>emplace_back() 和 push_back() 的区别，在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> num):<span class="built_in">num</span>(num) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace_back:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    vector&lt;Test&gt; demo1;</span><br><span class="line">demo1.<span class="built_in">emplace_back</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push_back:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    vector&lt;Test&gt; demo2;</span><br><span class="line">    demo2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>emplace_back:<br>调用构造函数<br>push_back:<br>调用构造函数<br>调用移动构造函数</p></blockquote><p>把移动构造函数注释后，运行结果如下：</p><blockquote><p>emplace_back:<br>调用构造函数<br>push_back:<br>调用构造函数<br>调用拷贝构造函数</p></blockquote><p>由此可以看出，push_back() 在底层实现时，会优先选择调用移动构造函数，如果没有才会调用拷贝构造函数。</p><p>显然完成同样的操作，push_back() 的底层实现过程比 emplace_back() 更繁琐，换句话说，emplace_back() 的执行效率比 push_back() 高。因此，在实际使用时，建议大家优先选用 emplace_back()。</p><blockquote><p>由于 emplace_back() 是 C++ 11 标准新增加的，如果程序要兼顾之前的版本，还是应该使用 push_back()。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C++函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>987. 二叉树的垂序遍历</title>
      <link href="/2021/07/31/987.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2021/07/31/987.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。</p><p>对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。</p><p>二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p><p>返回二叉树的 垂序遍历 序列。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree">https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>示例 1：</strong></p><blockquote><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg" style="zoom: 80%;"><p><strong>输入：</strong>root = [3,9,20,null,null,15,7]<br><strong>输出：</strong>[[9],[3,15],[20],[7]]<br><strong>解释：</strong><br>列 -1 ：只有结点 9 在此列中。<br>列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。<br>列  1 ：只有结点 20 在此列中。<br>列  2 ：只有结点 7 在此列中。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg" style="zoom: 80%;"><p><strong>输入：</strong>root = [1,2,3,4,5,6,7]<br><strong>输出：</strong>[[4],[2],[1,5,6],[3],[7]]<br><strong>解释：</strong><br>列 -2 ：只有结点 4 在此列中。<br>列 -1 ：只有结点 2 在此列中。<br>列  0 ：结点 1 、5 和 6 都在此列中。<br>          1 在上面，所以它出现在前面。<br>          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。<br>列  1 ：只有结点 3 在此列中。<br>列  2 ：只有结点 7 在此列中。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg" style="zoom: 80%;"><p><strong>输入：</strong>root = [1,2,3,4,6,5,7]<br><strong>输出：</strong>[[4],[2],[1,5,6],[3],[7]]<br><strong>解释：</strong><br>这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。<br>因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。</p></blockquote><p><strong>提示：</strong></p><ul><li>树中结点数目总数在范围 <code>[1, 1000]</code> 内</li><li>0 &lt;= Node.val &lt;= 1000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>​    vector有个很好的优点，当对它进行排序时，会考虑里面所有的元素，升序遍历</p><p>​    首先通过DFS用三元组存储每个节点的行，列和值（由于垂序遍历是按列从左到右进行遍历，所以三元组为**&lt;列，行，值&gt;**），然后进行sort排序，返回结果</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">verticalTraversal</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; pos;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">0</span>,<span class="number">0</span>,pos);</span><br><span class="line">        <span class="built_in">sort</span>(pos.<span class="built_in">begin</span>(),pos.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> lastrow = <span class="number">1001</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[row,col,val] : pos)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lastrow != row)&#123;</span><br><span class="line">                lastrow = row;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在res的最后一个里插入元素</span></span><br><span class="line">            res.<span class="built_in">back</span>().<span class="built_in">push_back</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node,<span class="keyword">int</span> col,<span class="keyword">int</span> row,vector&lt;tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; &amp;pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        pos.<span class="built_in">push_back</span>(&#123;row,col,node -&gt; val&#125;);</span><br><span class="line">        <span class="comment">//左子树，行+1，列-1</span></span><br><span class="line">        <span class="built_in">dfs</span>(node -&gt; left,col + <span class="number">1</span>,row - <span class="number">1</span>,pos);</span><br><span class="line">        <span class="comment">//右子树，行+1，列+1</span></span><br><span class="line">        <span class="built_in">dfs</span>(node -&gt; right,col + <span class="number">1</span>,row + <span class="number">1</span>,pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(nlogn),其中n是树的节点数，O(n)的时间对整棵树进行一次DFS，随后需要O(nlogn)的时间对pos的数组进行sort排序以及O(n)的时间对pos进行遍历得到结果，由于O(nlogn)在渐进意义上大于O(n)，所以算法的总时间复杂度为O(nlogn)。</li><li>空间复杂度：O(n)，DFS需要O(n)的栈空间，同时pos也需要O(n)的空间。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> DFS </tag>
            
            <tag> 三元组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学问题的解题窍门</title>
      <link href="/2021/07/30/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E9%A2%98%E7%AA%8D%E9%97%A8/"/>
      <url>/2021/07/30/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E9%A2%98%E7%AA%8D%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="1-辗转相除法"><a href="#1-辗转相除法" class="headerlink" title="1.辗转相除法"></a>1.辗转相除法</h1><h2 id="1-1求最大公约数"><a href="#1-1求最大公约数" class="headerlink" title="1.1求最大公约数"></a>1.1求最大公约数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,b % a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2拓展欧几里德算法"><a href="#1-2拓展欧几里德算法" class="headerlink" title="1.2拓展欧几里德算法"></a>1.2拓展欧几里德算法</h2><p><strong>扩展欧几里得算法</strong>是<a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675">欧几里得算法</a>（又叫辗转相除法）的扩展。除了计算a、b两个整数的<a href="https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/869308">最大公约数</a>，此算法还能找到整数x、y（其中一个很可能是负数）。通常谈到<a href="https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/6760265">最大公因子</a>时, 我们都会提到一个非常基本的事实: **给予二整数 a 与 b, 必存在有整数 x 与 y 使得ax + by = gcd(a,b)**。有两个数a,b，对它们进行<a href="https://baike.baidu.com/item/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/4625352">辗转相除法</a>，可得它们的最大公约数——这是众所周知的。然后，收集辗转相除法中产生的式子，倒回去，可以得到ax+by=gcd(a,b)的整数解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span>&amp; x,<span class="keyword">int</span>&amp; y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> d = a;</span><br><span class="line">    <span class="keyword">if</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">        d = <span class="built_in">extgcd</span>(b,a % b,y,x);</span><br><span class="line">        y -= (a / b) * x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-有关素数的基础算法"><a href="#2-有关素数的基础算法" class="headerlink" title="2.有关素数的基础算法"></a>2.有关素数的基础算法</h1><h2 id="2-1-素数测试"><a href="#2-1-素数测试" class="headerlink" title="2.1 素数测试"></a>2.1 素数测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设输入的都是正数</span></span><br><span class="line"><span class="comment">//素数测试O(√n)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n != <span class="number">1</span>; <span class="comment">// 1除外 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//约数枚举O(√n)</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">divisor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / i; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">res.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span>(i != n / i) res.<span class="built_in">push</span>(n / i); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数分解</span></span><br><span class="line"><span class="function">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="title">prime_factor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; ++i)&#123;</span><br><span class="line"><span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">++res[i];</span><br><span class="line">n /= i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n != <span class="number">1</span>) res[n] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="2-2-埃氏筛法"><a href="#2-2-埃氏筛法" class="headerlink" title="2.2 埃氏筛法"></a>2.2 埃氏筛法</h2><p>首先，将2到n范围内的所有整数写下来。其中最小的数字2是素数。将表中所有2的倍数都划去。表中剩余的最小数字是3，它不能被更小的数整除，所以是素数。再将表中所有3的倍数都划去。依此类推，如果表中剩余的最小数字是m时，m是素数。然后将表中所有m的倍数都划去。像这样反复操作，就能依次枚举n以内的素数。</p><table><thead><tr><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th>9</th><th align="center">10</th><th align="center">11</th><th align="center">12</th><th align="center">13</th><th align="center">14</th><th align="center">15</th><th align="center">16</th><th align="center">17</th><th align="center">18</th><th align="center">19</th><th align="center">20</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">3</td><td align="center">-</td><td align="center">5</td><td align="center">-</td><td align="center">7</td><td align="center">-</td><td>9</td><td align="center">-</td><td align="center">11</td><td align="center">-</td><td align="center">13</td><td align="center">-</td><td align="center">15</td><td align="center">-</td><td align="center">17</td><td align="center">-</td><td align="center">19</td><td align="center">-</td></tr><tr><td align="center">2</td><td align="center">3</td><td align="center">-</td><td align="center">5</td><td align="center">-</td><td align="center">7</td><td align="center">-</td><td>-</td><td align="center">-</td><td align="center">11</td><td align="center">-</td><td align="center">13</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">17</td><td align="center">-</td><td align="center">19</td><td align="center">-</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[MAX_N];<span class="comment">// 第i个素数</span></span><br><span class="line"><span class="keyword">bool</span> is_prime[MAX_N + <span class="number">1</span>];<span class="comment">// is_prime[i]为true表示i是素数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回n以为素数的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) is_prime[i] = <span class="literal">true</span>;</span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">prime[p++] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i;j &lt;= n; j+=i)</span><br><span class="line">                is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="3-快速幂运算"><a href="#3-快速幂运算" class="headerlink" title="3.快速幂运算"></a>3.快速幂运算</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">//迭代 </span></span><br><span class="line"><span class="function">ll <span class="title">mod_pow</span><span class="params">(ll x,ll n,ll mod)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">x = x * x % mod;</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归 </span></span><br><span class="line"><span class="function">ll <span class="title">mod_pow</span><span class="params">(ll x,ll n,ll mod)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ll res = <span class="built_in">mod_pow</span>(x * x % mod,n / <span class="number">2</span>,mod);</span><br><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>)res = res * x % mod; </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++取整函数ceil，floor，fix，round</title>
      <link href="/2021/07/29/C++%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0ceil%EF%BC%88%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4%EF%BC%89%E5%92%8Cfloor%EF%BC%88%E5%90%91%E4%B8%8B%E5%8F%96%E6%95%B4%EF%BC%89/"/>
      <url>/2021/07/29/C++%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0ceil%EF%BC%88%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4%EF%BC%89%E5%92%8Cfloor%EF%BC%88%E5%90%91%E4%B8%8B%E5%8F%96%E6%95%B4%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>使用ceil函数。ceil(x)返回的是大于x的最小整数(朝正无穷方向取整)。<br>    ceil(10.5) == 11    ceil(-10.5) ==-10</p><p>使用floor函数。floor(x)返回的是小于或等于x的最大整数(朝负无穷方向取整)。<br>    floor(10.5) == 10    floor(-10.5) == -11</p><p>使用fix函数。fix(x)是朝零方向取整 。<br>    fix(-1.3)=-1; fix(1.3)=1;</p><p>使用round函数。round(x)是四舍五入到最近的整数。<br>    round(-1.3)=-1;round(-1.52)=-2;round(1.3)=1;round(1.52)=2</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1104. 二叉树寻路</title>
      <link href="/2021/07/29/1104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%BB%E8%B7%AF/"/>
      <url>/2021/07/29/1104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%BB%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。</p><p>如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；</p><p>而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/06/28/tree.png"></p><p>给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree">https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：label = 14<br>输出：[1,3,4,14]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：label = 26<br>输出：[1,2,6,10,26]</p></blockquote><p><strong>提示：</strong></p><ul><li>1 &lt;= label &lt;= 10^6</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>​    如果是正常二叉树标记顺序，每个结点的父结点值应为子节点值 val / 2。而在这种 “之” 字形排序下，父结点应为正常父结点在当层的 <strong>对称位置</strong>。</p><p>​    每层节点对称结点和为定值，用该值减去val/2,即可得到对称后label父节点的值。</p><p>​    假设当前层为level:当前层最小值:<strong>pow(2 , level - 1)</strong> ,最大值:<strong>pow(2 , level) - 1</strong>，对称后level的父节点为<strong>pow(2 , level - 1) + pow(2 , level) - 1 - label  /  2</strong>,然后进行循环，取得路径。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">pathInZigZagTree</span><span class="params">(<span class="keyword">int</span> label)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int level = ceil(log(label + 1) / log(2));</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">pow</span>(<span class="number">2</span>,level) &lt;= label)</span><br><span class="line">            ++level;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(level)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(level--)&#123;</span><br><span class="line">            ret[level]=label;</span><br><span class="line">            label=<span class="built_in">pow</span>(<span class="number">2</span>,level)<span class="number">-1</span>+<span class="built_in">pow</span>(<span class="number">2</span>,level<span class="number">-1</span>)-label/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>863. 二叉树中所有距离为 K 的结点</title>
      <link href="/2021/07/28/863.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BA%20K%20%E7%9A%84%E7%BB%93%E7%82%B9/"/>
      <url>/2021/07/28/863.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BA%20K%20%E7%9A%84%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。</p><p>返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree">https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2<br>输出：[7,4,1]<br>解释：<br>所求结点为与目标结点（值为 5）距离为 2 的结点，<br>值分别为 7，4，以及 1</p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" style="zoom: 33%;"><p>注意，输入的 “root” 和 “target” 实际上是树上的结点。<br>上面的输入仅仅是对这些对象进行了序列化描述。</p></blockquote><p><strong>提示：</strong></p><ul><li>给定的树是非空的。</li><li>树上的每个结点都具有唯一的值 0 &lt;= node.val &lt;= 500 。</li><li>目标结点 target 是树上的结点。</li><li>0 &lt;= K &lt;= 1000.</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>​    将target当做树的根节点，进行DFS遍历，寻找与target距离为k的所有节点，即深度为k的所有节点。</p><p>​    由于二叉树没有记录父节点，为此我们从根节点出发，进行BFS遍历，通过哈希表记录每个节点的父节点。</p><p>​    然后从target出发， 进行DFS，进行左右儿子搜索，同时进行沿父节点向上搜索。</p><p>​    由于，每个节点的值唯一，所以节点的val可以作为哈希表的键。此外，为了避免在DFS中对节点进行重复访问，递归时额外传入来源节点parent,在递归前比较目标节点是否与来源节点相同，不同才进行递归。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,TreeNode*&gt; parents;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findres</span><span class="params">(TreeNode* node, TreeNode* from,<span class="keyword">int</span> deepth, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(deepth == k)&#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; left != from)</span><br><span class="line">            <span class="built_in">findres</span>(node -&gt; left,node,deepth + <span class="number">1</span>,k);</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; right != from)</span><br><span class="line">            <span class="built_in">findres</span>(node -&gt; right,node,deepth + <span class="number">1</span>,k);</span><br><span class="line">        <span class="keyword">if</span>(parents[node -&gt; val] != from)</span><br><span class="line">            <span class="built_in">findres</span>(parents[node -&gt; val],node,deepth + <span class="number">1</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">distanceK</span><span class="params">(TreeNode* root, TreeNode* target, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                parents[node -&gt; left -&gt; val] = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                parents[node -&gt; right -&gt; val] = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">findres</span>(target,<span class="literal">nullptr</span>,<span class="number">0</span>,k);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1743. 从相邻元素对还原数组</title>
      <link href="/2021/07/25/1743.%20%E4%BB%8E%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E5%AF%B9%E8%BF%98%E5%8E%9F%E6%95%B0%E7%BB%84/"/>
      <url>/2021/07/25/1743.%20%E4%BB%8E%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E5%AF%B9%E8%BF%98%E5%8E%9F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>存在一个由 n 个不同元素组成的整数数组 nums ，但你已经记不清具体内容。好在你还记得 nums 中的每一对相邻元素。</p><p>给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个 adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。</p><p>题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。这些相邻元素对可以 按任意顺序 出现。</p><p>返回 原始数组 nums 。如果存在多种解答，返回 其中任意一个 即可</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs">https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：adjacentPairs = [[2,1],[3,4],[3,2]]<br>输出：[1,2,3,4]<br>解释：数组的所有相邻元素对都在 adjacentPairs 中。<br>特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：adjacentPairs = [[4,-2],[1,4],[-3,1]]<br>输出：[-2,4,1,-3]<br>解释：数组中可能存在负数。<br>另一种解答是 [-3,1,4,-2] ，也会被视作正确答案。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：adjacentPairs = [[100000,-100000]]<br>输出：[100000,-100000]</p></blockquote><p><strong>提示：</strong></p><ul><li>nums.length == n</li><li>adjacentPairs.length == n - 1</li><li>adjacentPairs[i].length == 2</li><li>2 &lt;= n &lt;= 105</li><li>-105 &lt;= nums[i], ui, vi &lt;= 105</li><li>题目数据保证存在一些以 adjacentPairs 作为元素对的数组 nums</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>​    遍历vector，对出现的数字进行计数，若数字只出现一次，则其在整体的两端，根据确定的一端，依次推断第二位，第三位，直到最后一个元素</p><p>​    具体方法，使用哈希表记录每个元素的相邻元素有哪些，然后我们遍历哈希表，找到有且仅作为第二个元素，有一个相邻元素的元素e1作为结果数组的第一个元素，然后e1唯一相邻的元素，此时排除e2相邻的e1后，确定与e2相邻的e3作为第三个元素。。。以此类推，推断出全部的元素</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">restoreArray</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; adjacentPairs)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;adjacentPair : adjacentPairs)&#123;</span><br><span class="line">            mp[adjacentPair[<span class="number">0</span>]].<span class="built_in">push_back</span>(adjacentPair[<span class="number">1</span>]);</span><br><span class="line">            mp[adjacentPair[<span class="number">1</span>]].<span class="built_in">push_back</span>(adjacentPair[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n =adjacentPairs.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[e,adj] : mp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(adj.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">                res[<span class="number">0</span>] = e;</span><br><span class="line">                res[<span class="number">1</span>] = mp[res[<span class="number">0</span>]][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; adj = mp[res[i - <span class="number">1</span>]];</span><br><span class="line">            res[i] = res[i - <span class="number">2</span>] == adj[<span class="number">0</span>] ? adj[<span class="number">1</span>] : adj[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
