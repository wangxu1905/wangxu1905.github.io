<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moon</title>
  
  
  <link href="http://wangxu1905.github.io/atom.xml" rel="self"/>
  
  <link href="http://wangxu1905.github.io/"/>
  <updated>2022-03-19T03:53:24.943Z</updated>
  <id>http://wangxu1905.github.io/</id>
  
  <author>
    <name>Moon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>L2-036 网红点打卡攻略 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/19/L2-036%20%E7%BD%91%E7%BA%A2%E7%82%B9%E6%89%93%E5%8D%A1%E6%94%BB%E7%95%A5%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/19/L2-036%20%E7%BD%91%E7%BA%A2%E7%82%B9%E6%89%93%E5%8D%A1%E6%94%BB%E7%95%A5%20(25%20%E5%88%86)/</id>
    <published>2022-03-19T03:46:52.550Z</published>
    <updated>2022-03-19T03:53:24.943Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>首先第一行给出两个正整数：网红点的个数 <em>N</em>（1&lt;<em>N</em>≤200）和网红点之间通路的条数 <em>M</em>。随后 <em>M</em> 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 <em>N</em> 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 <code>0</code>。</p><p>再下一行给出一个正整数 <em>K</em>，是待检验的攻略的数量。随后 <em>K</em> 行，每行给出一条待检攻略，格式为：</p><p><em>n</em> <em>V</em>1 <em>V</em>2 ⋯ <em>V**n</em></p><p>其中 <em>n</em>(≤200) 是攻略中的网红点数，<em>V**i</em> 是路径上的网红点编号。这里假设你从家里出发，从 <em>V</em>1 开始打卡，最后从 <em>V**n</em> 回家。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在第一行输出满足要求的攻略的个数。</p><p>在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。</p><p>题目保证至少存在一个有效攻略，并且总路费不超过 109。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">13</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">6</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">6</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">6</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">8</span> <span class="number">6</span> <span class="number">2</span> <span class="number">1</span> <span class="number">6</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><h3 id="样例说明："><a href="#样例说明：" class="headerlink" title="样例说明："></a>样例说明：</h3><p>第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。</p><p>第 1 条攻略的总路费是：(0-&gt;5) 2 + (5-&gt;1) 2 + (1-&gt;4) 2 + (4-&gt;3) 2 + (3-&gt;6) 2 + (6-&gt;2) 2 + (2-&gt;0) 2 = 14；</p><p>第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 = 11，是一条更省钱的攻略；</p><p>第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 = 11，与第 5 条花费相同，但序号较大，所以不输出。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    很简单，就是建立图，然后用unordered_set判断是否经过所有景点一次且仅一次</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(mar,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mar));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) mar[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        mar[a][b] = mar[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>,res = INF,pos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k ; ++i)&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; se;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>,num,a = <span class="number">0</span>,b,sum = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; num; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span>(se.<span class="built_in">find</span>(b) == se.<span class="built_in">end</span>())  se.<span class="built_in">insert</span>(b);</span><br><span class="line">            <span class="keyword">else</span>    flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(mar[a][b] == INF)    flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>    sum += mar[a][b];</span><br><span class="line">            a = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mar[a][<span class="number">0</span>] == INF)    flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>    sum += mar[a][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(se.<span class="built_in">size</span>() != n || !flag) <span class="keyword">continue</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(res &gt; sum)&#123;</span><br><span class="line">            res = sum;</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pos &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。&lt;</summary>
      
    
    
    
    
    <category term="天梯赛" scheme="http://wangxu1905.github.io/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>7-3 冠军魔术 (10 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/19/7-3%20%E5%86%A0%E5%86%9B%E9%AD%94%E6%9C%AF%20(10%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/19/7-3%20%E5%86%A0%E5%86%9B%E9%AD%94%E6%9C%AF%20(10%20%E5%88%86)/</id>
    <published>2022-03-19T02:51:08.094Z</published>
    <updated>2022-03-19T02:58:14.368Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://images.ptausercontent.com/a4b1f9c6-007d-4137-aa94-28b343aa3c34.jpg" alt="魔术.jpg"></p><p>2018年FISM（世界魔术大会）近景总冠军简纶廷的表演中有一个情节：以桌面上一根带子为界，当他将纸牌从带子的一边推到另一边时，纸牌会变成硬币；把硬币推回另一边会变成纸牌。</p><p>这里我们假设纸牌会变成等量的硬币，而硬币变成纸牌时，纸牌的数量会加倍。那么给定纸牌的初始数量，当他来回推了 N 次（来/回各算一次）后，手里拿的是纸牌还是硬币？数量是多少？</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行里给出两个正整数，分别是纸牌的初始数量和魔术师推送的次数。这里假设初始状态下魔术师手里全是纸牌。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如果最后魔术师手里是纸牌，输出 0 和纸牌数量；如果是硬币，则输出 1 和硬币数量。数字间须有 1 个空格。题目保证结果数值不超出整型范围（即 2^31−1）。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">24</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">32</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    是我菜了,round的返回值是double,不管是int,还是long long,乘double的话，都会自动转成double，所以round计算之后要转成int</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,k,t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(m &amp; <span class="number">1</span>)   cout &lt;&lt; <span class="string">&quot;1 &quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;0 &quot;</span>;</span><br><span class="line">    cout &lt;&lt; n * (<span class="keyword">int</span>)<span class="built_in">round</span>(<span class="built_in">pow</span>(<span class="number">2</span>,m / <span class="number">2</span>)) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ptausercontent.com/a4b1f9c6-007d-4137-aa94-28b343aa3c34.jpg&quot; alt=&quot;魔术.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2018年</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>L2-001 紧急救援 (25 分) 堆优化版</title>
    <link href="http://wangxu1905.github.io/2022/03/19/L2-001%20%E7%B4%A7%E6%80%A5%E6%95%91%E6%8F%B4%20(25%20%E5%88%86)%20%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88/"/>
    <id>http://wangxu1905.github.io/2022/03/19/L2-001%20%E7%B4%A7%E6%80%A5%E6%95%91%E6%8F%B4%20(25%20%E5%88%86)%20%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88/</id>
    <published>2022-03-19T02:27:47.450Z</published>
    <updated>2022-03-19T02:51:15.018Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任务是带领你的救援队尽快赶往事发地，同时，一路上召集尽可能多的救援队。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第一行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0 ~ (<em>N</em>−1)；<em>M</em>是快速道路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。</p><p>第二行给出<em>N</em>个正整数，其中第<em>i</em>个数是第<em>i</em>个城市的救援队的数目，数字间以空格分隔。随后的<em>M</em>行中，每行给出一条快速道路的信息，分别是：城市1、城市2、快速道路的长度，中间用空格分开，数字均为整数且不超过500。输入保证救援可行且最优解唯一。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>第一行输出最短路径的条数和能够召集的最多的救援队数量。第二行输出从<em>S</em>到<em>D</em>的路径中经过的城市编号。数字间以空格分隔，输出结尾不能有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">60</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​        根据前天测试卡我朴素Dijkstra,让我开始学习堆优化版。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">int</span> n, m, s, d, val[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">505</span>];</span><br><span class="line">vector&lt;PII&gt; mar[<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[n],cnt[n],num[n], pre[n];</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mar[s].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        dis[mar[s][i].x] = mar[s][i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    cnt[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//建成小根堆，然后PII第一个值存距离，第二个值存点</span></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//注意是second</span></span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">top</span>().y;</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//如果已经访问过，就继续</span></span><br><span class="line">        <span class="keyword">if</span>(visited[u])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//标记已经访问</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mar[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">           <span class="comment">//这里就是按正常顺序的first，sceond</span></span><br><span class="line">            <span class="keyword">int</span> v = mar[u][i].x, w = mar[u][i].y;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v] &amp;&amp; dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                cnt[v] = cnt[u];</span><br><span class="line">                pre[v] = u;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                num[v] = num[u] + val[v];</span><br><span class="line">                qu.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!visited[v] &amp;&amp; dis[v] == dis[u] + w) &#123;</span><br><span class="line">                cnt[v] += cnt[u];</span><br><span class="line">                <span class="keyword">if</span>(num[v] &lt; num[u] + val[v]) &#123;</span><br><span class="line">                    pre[v] = u;</span><br><span class="line">                    num[v] = num[u] + val[v];</span><br><span class="line">                &#125;</span><br><span class="line">                qu.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt[d] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num[d] + val[s] &lt;&lt; endl;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">while</span>(d != <span class="number">-1</span>)&#123;</span><br><span class="line">        st.<span class="built_in">push</span>(d);</span><br><span class="line">        d = pre[d];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>    flag = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt;  st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  cin &gt;&gt; val[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        mar[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">        mar[v].<span class="built_in">push_back</span>(&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任</summary>
      
    
    
    
    
    <category term="Dijkstra" scheme="http://wangxu1905.github.io/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>素数筛</title>
    <link href="http://wangxu1905.github.io/2022/03/18/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    <id>http://wangxu1905.github.io/2022/03/18/%E7%B4%A0%E6%95%B0%E7%AD%9B/</id>
    <published>2022-03-18T13:51:19.639Z</published>
    <updated>2022-03-18T14:26:16.785Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="一、暴力（略）"><a href="#一、暴力（略）" class="headerlink" title="一、暴力（略）"></a>一、暴力（略）</h3><h3 id="二、埃氏筛"><a href="#二、埃氏筛" class="headerlink" title="二、埃氏筛"></a>二、埃氏筛</h3><p>​        简单来说，筛选[1,n]内的素数，2是最小的素数，那么把2的倍数全都划去。表中剩下最小的数是3，它不能被更小的数整除，所以是素数，再把3的素数都划去。以此类推，如果表中剩余的最小数字是m，m就是素数，将m的倍数都划去。</p><p>像这样反复操作，就能依次枚举n以内的素数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> cnt,prime[MAX_N];</span><br><span class="line"><span class="keyword">bool</span> is_prime[MAX_N + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(is_prime));</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime[i])&#123;</span><br><span class="line">            prime[cnt++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= n; j += i)  is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sieve</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt ;++i)&#123;</span><br><span class="line">        cout &lt;&lt; prime[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、区间筛法"><a href="#三、区间筛法" class="headerlink" title="三、区间筛法"></a>三、区间筛法</h3><p>​    b以内的合数的最小质因子肯定不超过根号b，如果有根号b以内的素数表的话，我们就可以把埃氏筛法运用到[a,b)上了。也就是说，先分别做好[2,根号b)的表和[a,b)的表，然后从[2,根号b)的表筛得质数的同时，也将其倍数从[a,b)的表划去，最后剩下的就是[a,b)的素数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100001</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> cnt,prime[MAX_N];</span><br><span class="line"><span class="keyword">bool</span> is_prime[MAX_N + <span class="number">1</span>],is_prime_small[MAX_N + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segment_sieve</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i * i &lt; b; ++i)   is_prime_small[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; b - a; ++i) is_prime[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">2</span>; i * i &lt; b; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime_small[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(ll j = <span class="number">2</span> * i; j * j &lt; b; j += i)    is_prime_small[j] = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//(a + i - 1) / i * i 取最接近a的i的倍数，并且j至少是i的两倍，2LL,指的是long long</span></span><br><span class="line">            <span class="keyword">for</span>(ll j = <span class="built_in">max</span>(<span class="number">2LL</span>,(a + i - <span class="number">1</span>) / i) * i; j &lt; b; j += i) is_prime[j - a] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">segment_sieve</span>(<span class="number">50</span>,<span class="number">90</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime[i])</span><br><span class="line">            cout &lt;&lt; <span class="number">50</span> + i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;一、暴力（略）&quot;&gt;&lt;a href=&quot;#一、暴力（略）&quot; class=&quot;headerlink&quot; title=&quot;一、暴力（略）&quot;&gt;&lt;/a&gt;一、暴力（略）&lt;/h3&gt;&lt;h3 id=&quot;二、埃氏筛&quot;&gt;&lt;a href=&quot;#二、埃</summary>
      
    
    
    
    
    <category term="素数筛" scheme="http://wangxu1905.github.io/tags/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    
  </entry>
  
  <entry>
    <title>L2-4 风雪火车站 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/18/7-13%20%E6%8C%91%E8%8B%B9%E6%9E%9C%20(35%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/18/7-13%20%E6%8C%91%E8%8B%B9%E6%9E%9C%20(35%20%E5%88%86)/</id>
    <published>2022-03-18T10:38:53.715Z</published>
    <updated>2022-03-18T10:54:47.875Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>妈妈买了<em>N</em>个苹果，每个苹果都有对应的美味度。为了公平，妈妈规定小红和小明需要轮流从剩余的苹果中选择最左边的苹果或者最右边的苹果吃，小红先选。</p><p>小明和小红想要自己吃到苹果的美味度的总和尽可能大，假如小红和小明足够聪明，每次都用最优的策略选择苹果，现在需要你求出小红吃到苹果的美味度的总和。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行输入一个正整数<em>N</em>(1≤<em>N</em>≤100)</p><p>第二行输入<em>N</em>个正整数,表示从左到右苹果的美味度</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出一个数，表示小红能吃到的苹果的美味度的总和。</p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">0</span> <span class="number">20</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure><p>解释：小红先选择美味度为3的苹果，之后小明选择美味度为9的苹果，小红再选择美味度为20的苹果，小明选择美味度为0的苹果，所以小红在最优策略下选择的苹果的美味度总和为20+3=23</p><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">9</span> <span class="number">5</span> <span class="number">16</span> <span class="number">15</span> <span class="number">10</span> </span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><p><strong>小提示：小红和小明都选择最优的策略，也就是小红和小明都要想方设法让自己获得苹果的美味度最大。由于总的苹果的美味度不变，所以小红的策略就是让小明获得的苹果的最大美味度最小，而小明的策略是让小红获得的苹果的最大美味度最小。</strong></p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    区间dp没学过，但是记忆化递归还是能看懂的。</p><p>​    我们先求一遍前缀和，令dfs(l,r)表示当前选的人在[l,r]区间能选到的最大值。</p><p>​    共有两种决策，选左边的苹果与右边的苹果，也就是转移到[l + 1,r]与[l, r - 1]。</p><p>​    那么就会有dfs(l,r) = sum[r] - sum[l - 1] - min(dfs(l + 1,r),dfs(l,r - 1));</p><p>​    也就是[l,r]区间的美味度总和减去另一个人能获得的最大值的最小值就是当前这个人的最优决策能获得的最大值。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,dp[<span class="number">101</span>][<span class="number">101</span>],sum[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[l][r] != <span class="number">-1</span>)  <span class="keyword">return</span> dp[l][r];</span><br><span class="line">    <span class="keyword">if</span>(l == r)  <span class="keyword">return</span> dp[l][r] = sum[r] - sum[l - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[l][r] = sum[r] - sum[l - <span class="number">1</span>] - <span class="built_in">min</span>(<span class="built_in">dfs</span>(l + <span class="number">1</span>,r),<span class="built_in">dfs</span>(l,r - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; sum[i];</span><br><span class="line">        sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>,n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;妈妈买了&lt;em&gt;N&lt;/em&gt;个苹果，每个苹果都有对应的美味度。为了公平，妈妈规定小红和小明需要轮流从剩余的苹果中选择最左边的苹果或者最右边的苹果吃，小红先选。&lt;/p&gt;
&lt;p&gt;小明和小红想要自己吃到苹果的美味度的总和尽可能大，</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>L2-4 风雪火车站 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/17/L2-4%20%E9%A3%8E%E9%9B%AA%E7%81%AB%E8%BD%A6%E7%AB%99%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/17/L2-4%20%E9%A3%8E%E9%9B%AA%E7%81%AB%E8%BD%A6%E7%AB%99%20(25%20%E5%88%86)/</id>
    <published>2022-03-17T12:23:24.480Z</published>
    <updated>2022-03-18T10:09:04.077Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>B国共有 <em>n</em> 座城市，分别编号为 1,2,…,<em>n</em>。你所在地点的编号是 <em>s</em> ，火车站的编号是 <em>t</em>。</p><p>有 <em>m</em> 条道路连接这些城市，它们的长度分别为 <em>w**i</em>。为了便于绘制地图，B国的道路规划保证每条道路严格地连接两个不同的地点，并且不会有两条道路连接的两个地点相同。 你的走路速度是 1<em>m</em>/<em>s</em>。</p><p>开始时，地点 <em>i</em> 的积雪深度为 <em>h**i</em> 。每秒钟地面上积雪的厚度会增加 <em>q</em> 。每个地点都有一个步行的极限雪深 <em>l**i</em> ，如果到达此地时此地的雪深 ，你会被困在这个点，无法继续前进。</p><p>不考虑起始点和火车站的雪。你需要在<em>g</em>秒内到达火车站，如果能到达火车站，输出最快可以到达火车站的时间，否则输出<code>-1</code>。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第 1 行 6 个整数，空格隔开，分别代表 <em>n</em>,<em>m</em>,<em>s</em>,<em>t</em>,<em>g</em>,<em>q</em> 。</p><p>接下来<em>n</em> 行，每行2 个整数，空格隔开，分别表示这个地点的 <em>h**i</em> 和 <em>l**i</em>。</p><p>接下来<em>m</em> 行，每行 3 个整数，空格隔开，分别表示这条路连接的两个地点<em>u</em>,<em>v</em> 和这条路的长度 <em>w**i</em>。</p><p>对所有的数据1≤<em>n</em>≤105,1≤<em>m</em>≤5×105</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出一个整数，表示最短到达火车站的时间，若无法到达，则输出<code>-1</code></p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">10</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">3</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">5</span> <span class="number">10</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">9</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    王伯成大佬说的，我不知道，说是堆优化能过，专门卡spfa。</p><p>​    菜了，当初还写个计时器记录时间，看到刘哲轩的题解后，才明白过来，dijkstra更新距离的时候，已经算上前面的距离了，所以当前dis[v]的距离就是从开始到现在的经历的时间。</p><p>​    然后就是，优先队列是按pair&lt;ll,ll&gt;的第一个元素进行排序，所以我们可以然距离在前，地点标号在后</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; PII;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ll h, l;</span><br><span class="line">&#125; node[<span class="number">200010</span>];</span><br><span class="line">ll n, m, s, t, g, q, timenum;</span><br><span class="line">vector&lt;PII&gt; mar[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Dijkstra</span><span class="params">(ll s)</span> </span>&#123;</span><br><span class="line">    ll dis[<span class="number">200010</span>];</span><br><span class="line">    <span class="comment">//注意，要定义小根堆，咱也不知道重载运算符为啥不能用</span></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; qu;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    qu.<span class="built_in">push</span>(<span class="built_in">PII</span>(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        PII p = qu.<span class="built_in">top</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        ll u = p.y;</span><br><span class="line">        <span class="comment">//如果积雪厚度超过了极限，则依然不选择</span></span><br><span class="line">        <span class="keyword">if</span>(visited[u] || node[u].h + dis[u] * q &gt;= node[u].l)  <span class="keyword">continue</span>;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; mar[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ll v = mar[u][i].x, w = mar[u][i].y;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                qu.<span class="built_in">push</span>(<span class="built_in">PII</span>(dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[t] &lt;= g)</span><br><span class="line">        cout &lt;&lt; dis[t] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t &gt;&gt; g &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; node[i].h &gt;&gt; node[i].l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        ll u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        mar[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">        mar[v].<span class="built_in">push_back</span>(&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;B国共有 &lt;em&gt;n&lt;/em&gt; 座城市，分别编号为 1,2,…,&lt;em&gt;n&lt;/em&gt;。你所在地点的编号是 &lt;em&gt;s&lt;/em&gt; ，火车站的编号是 &lt;em&gt;t&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;有 &lt;em&gt;m&lt;/em&gt; 条道路连接这些</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>L2-3 加密信息 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/17/L2-3%20%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/17/L2-3%20%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%20(25%20%E5%88%86)/</id>
    <published>2022-03-17T11:24:16.768Z</published>
    <updated>2022-03-17T11:35:16.689Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定一个长度为<em>n</em>(<em>n</em>&lt;=5×105)的加密字符串<em>S</em>,解密方式如下：</p><p>1.初始时字符串<em>T</em>为空.</p><p>2.从头遍历S字符串,令<em>i</em>=1,2,3…,<em>n</em>, 若<em>S</em>的第<em>i</em>个字符是<code>R</code>,那么翻转字符串<em>T</em>，否则将该字符加入字符串<em>T</em>中.</p><p>3.在上述操作结束后，若<em>T</em>串有两个连续的字符相同， 那么就删除这两个字符，直到<em>T</em>串中没有两个相同的连续字符为止.</p><p>那么<em>T</em>串就是最终解密完毕的字符串.</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入一个加密字符串<em>S</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S</span><br></pre></td></tr></table></figure><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出最后解密完毕的字符串<em>T</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T</span><br></pre></td></tr></table></figure><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ozRnonnoe</span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zone</span><br></pre></td></tr></table></figure><p>样例解释：</p><p>● 初始时<em>T</em>为空</p><p>● 将<code>o</code>加入<em>T</em>中， 此时<em>T</em>是<code>o</code></p><p>●将<code>z</code>加入<em>T</em>中， 此时<em>T</em>是<code>oz</code></p><p>●翻转<em>T</em>,此时<em>T</em>是<code>zo</code></p><p>●将<code>n</code>加入<em>T</em>中， 此时<em>T</em>是<code>zon</code></p><p>●将<code>o</code>加入<em>T</em>中， 此时<em>T</em>是<code>zono</code></p><p>●将<code>n</code>加入<em>T</em>中， 此时<em>T</em>是<code>zonon</code></p><p>●将<code>n</code>加入<em>T</em>中， 此时<em>T</em>是<code>zononn</code></p><p>●将<code>o</code>加入<em>T</em>中， 此时<em>T</em>是<code>zononno</code></p><p>●将<code>e</code>加入<em>T</em>中， 此时<em>T</em>是<code>zononnoe</code></p><p>●把<em>T</em>中的<code>nn</code>删除，此时<em>T</em>是<code>zonooe</code></p><p>●把<em>T</em>中的<code>oo</code>删除，此时<em>T</em>是<code>zone</code></p><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hellospaceRhellospace</span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><p>此时所有字符都被删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    原本是打算维护两个字符串进行前插和后插，遍历到’R’时，两个字符串进行交换，暴力循环删除重复字符，超时了…….</p><p>​    感谢超漂亮的柳洋学姐，通过双端队列进行模拟，通过标记变量，维护一个双端队列就可以了。然后在插入的时候进行判断删除就可以了，最后直接输出（我感觉我的那个改改其实可能也行，但时间复杂度肯定比学姐的高）</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h5 id="1-学姐的"><a href="#1-学姐的" class="headerlink" title="1.学姐的"></a>1.学姐的</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string t,s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    deque &lt;<span class="keyword">char</span>&gt; de;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">length</span>();i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">            f = (<span class="number">1</span> - f);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!de.<span class="built_in">empty</span>() &amp;&amp; de.<span class="built_in">back</span>() == s[i])&#123;</span><br><span class="line">                    de.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    de.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!de.<span class="built_in">empty</span>() &amp;&amp; de.<span class="built_in">front</span>() == s[i])&#123;</span><br><span class="line">                    de.<span class="built_in">pop_front</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    de.<span class="built_in">push_front</span>(s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!de.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cout &lt;&lt; de.<span class="built_in">back</span>();</span><br><span class="line">            de.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!de.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cout &lt;&lt; de.<span class="built_in">front</span>();</span><br><span class="line">            de.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-我的（未改）"><a href="#2-我的（未改）" class="headerlink" title="2.我的（未改）"></a>2.我的（未改）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s,t = <span class="string">&quot;&quot;</span>,tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != <span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">            t += s[i];</span><br><span class="line">            tmp = s[i] + tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">swap</span>(t,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string res = t;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i] != res[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                ans += res[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定一个长度为&lt;em&gt;n&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;&amp;lt;=5×105)的加密字符串&lt;em&gt;S&lt;/em&gt;,解密方式如下：&lt;/p&gt;
&lt;p&gt;1.初始时字符串&lt;em&gt;T&lt;/em&gt;为空.&lt;/p&gt;
&lt;p&gt;2.从头遍历S字符串,令</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>C++ 结构体运算符重载</title>
    <link href="http://wangxu1905.github.io/2022/03/16/C++%20%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>http://wangxu1905.github.io/2022/03/16/C++%20%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</id>
    <published>2022-03-16T13:09:20.459Z</published>
    <updated>2022-03-19T02:16:20.127Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="一、map重载"><a href="#一、map重载" class="headerlink" title="一、map重载"></a>一、map重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;Node,<span class="keyword">int</span>&gt; book;</span><br><span class="line">    book[Node&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;] = <span class="number">1</span>;</span><br><span class="line">    book[Node&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>&#125;] = <span class="number">1</span>;</span><br><span class="line">    book[Node&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = book.<span class="built_in">begin</span>(); it != book.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">        Node node = it -&gt; first;</span><br><span class="line">        cout &lt;&lt; node.x &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; node.y &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; node.z &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map是按键进行自动排序，但是当用结构体当键时，就无法知道怎么排序，所以我们要进行运算符重载，重新定义Node的大小，以达到排序。</p><p><strong>重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。</strong></p><h3 id="二、优先队列重载"><a href="#二、优先队列重载" class="headerlink" title="二、优先队列重载"></a>二、优先队列重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Node &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;Node,vector&lt;Node&gt;,greater&lt;Node&gt;&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(Node&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    qu.<span class="built_in">push</span>(Node&#123;<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    qu.<span class="built_in">push</span>(Node&#123;<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        Node t = qu.<span class="built_in">top</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; t.x &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; t.y &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; t.z &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    less&lt;&gt;，重载&lt;号，greater重载&gt;号</p><p>​    return x &gt; b.x; 这个和sort是反着的，这个是按递增排序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;一、map重载&quot;&gt;&lt;a href=&quot;#一、map重载&quot; class=&quot;headerlink&quot; title=&quot;一、map重载&quot;&gt;&lt;/a&gt;一、map重载&lt;/h3&gt;&lt;figure class=&quot;highlight c++</summary>
      
    
    
    
    
    <category term="C++" scheme="http://wangxu1905.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>P6145 [USACO20FEB]Timeline G</title>
    <link href="http://wangxu1905.github.io/2022/03/13/P6145%20[USACO20FEB]Timeline%20G/"/>
    <id>http://wangxu1905.github.io/2022/03/13/P6145%20[USACO20FEB]Timeline%20G/</id>
    <published>2022-03-13T10:01:08.861Z</published>
    <updated>2022-03-13T10:13:44.977Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Bessie 在过去的 M天内参加了 N 次挤奶。但她已经忘了她每次挤奶是在哪个时候了。</p><p>对于第 i次挤奶，Bessie 记得它不早于第 S_i天进行。另外，她还有 C条记忆，每条记忆形如一个三元组 (a,b,x)，含义是第 b<em>b</em> 次挤奶在第 a<em>a</em> 次挤奶结束至少 x天后进行。</p><p>现在请你帮 Bessie 算出在满足所有条件的前提下，每次挤奶的最早日期。</p><p>保证 Bessie 的记忆没有错误，这意味着一定存在一种合法的方案，使得：</p><ul><li>第 i<em>i</em> 次挤奶不早于第 S_i 天进行，且不晚于第 M 天进行；</li><li>所有的记忆都得到满足；</li></ul><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行三个整数 N,M,C。保证 1≤<em>N</em>,<em>C</em>≤105，2≤<em>M</em>≤109。</p><p>接下来一行包含 N 个整数 S<em>1,<em>S</em>2,…,<em>Sn，保证 ∀1≤</em>i</em>≤<em>n</em>，都满足1≤<em>Si</em>≤<em>M</em>。</p><p>下面 C<em>C</em> 行每行三个整数 a,b,x，描述一条记忆。保证a<em>!=<em>b，且 1≤</em>x</em>≤<em>M</em>。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 N 行，每行一个整数，第 i 行的数表示第 i 次挤奶的最早日期。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">10</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><ul><li>测试点 2∼4 满足 <em>N</em>,<em>C</em>≤103。</li><li>测试点 5∼10 没有特殊限制。</li></ul><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    因为求最早时间，跑最长路</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, fail;</span><br><span class="line">    <span class="built_in">edge</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _fail) &#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">        fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, k, len, head[maxn], dis[maxn], in[maxn];</span><br><span class="line"><span class="keyword">bool</span> visited[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[len] = <span class="built_in">edge</span>(v, w, head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(s);</span><br><span class="line">    in[s] = <span class="number">1</span>;</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        visited[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].fail) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &lt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">                    qu.<span class="built_in">push</span>(v);</span><br><span class="line">                    in[v]++;</span><br><span class="line">                    visited[v] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">int</span> a, b, x;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,i,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; x;</span><br><span class="line">        <span class="built_in">add</span>(a,b,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cout &lt;&lt; dis[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Bessie 在过去的 M天内参加了 N 次挤奶。但她已经忘了她每次挤奶是</summary>
      
    
    
    
    
    <category term="差分约束" scheme="http://wangxu1905.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
    <category term="spfa" scheme="http://wangxu1905.github.io/tags/spfa/"/>
    
  </entry>
  
  <entry>
    <title>P1250 种树</title>
    <link href="http://wangxu1905.github.io/2022/03/13/P1250%20%E7%A7%8D%E6%A0%91/"/>
    <id>http://wangxu1905.github.io/2022/03/13/P1250%20%E7%A7%8D%E6%A0%91/</id>
    <published>2022-03-13T09:50:35.667Z</published>
    <updated>2022-03-15T12:31:02.156Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>一条街的一边有几座房子，因为环保原因居民想要在路边种些树。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>路边的地区被分割成块，并被编号成 1,2,…,<em>n</em>。每个部分为一个单位尺寸大小并最多可种一棵树。</p><p>每个居民都想在门前种些树，并指定了三个号码 b，e，t。这三个数表示该居民想在地区 b 和 e之间（包括 b 和 e）种至少 t棵树。</p><p>居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行是一个整数，代表区域的个数 n。</p><p>输入的第二行是一个整数，代表房子个数 h。</p><p>第 3 到第 (h + 2) 行，每行三个整数，第 (i + 2) 行的整数依次为 b_i, e_i, t_i，代表第 i 个居民想在 b_i 和 e_i之间种至少 t_i 棵树。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数，代表最少的树木个数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">8</span> <span class="number">9</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 100% 的数据，保证：</p><ul><li>1≤<em>n</em>≤3×104，1≤<em>h</em>≤5×103。</li><li>1≤<em>bi</em>≤<em>ei</em>≤<em>n</em>，1 1≤<em>ti</em>≤<em>ei</em>−<em>bi</em>+1。</li></ul><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    为了加入超级源点后，得到是否有解，为什么不再跑一遍源点？</p><p>​    因为跑的是最长路，我们加入的边都是正权。加入边权为-1的点，也不影响，因为是为了当正权边更新距离后，通过负权边更新前面的结点</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100001</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, fail;</span><br><span class="line">    <span class="built_in">edge</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _fail) &#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">        fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, k, len, head[maxn], dis[maxn], in[maxn];</span><br><span class="line"><span class="keyword">bool</span> visited[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[len] = <span class="built_in">edge</span>(v, w, head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(s);</span><br><span class="line">    in[s] = <span class="number">1</span>;</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        visited[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].fail) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &lt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">                    qu.<span class="built_in">push</span>(v);</span><br><span class="line">                    in[v]++;</span><br><span class="line">                    visited[v] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i + <span class="number">1</span>,i,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i,i + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(u - <span class="number">1</span>,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; dis[n] &lt;&lt; endl;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; ve[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> n, m,k, dis[maxn], cnt[maxn];</span><br><span class="line"><span class="keyword">bool</span> visited[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">    dis[s] = <span class="number">0</span>, visited[s] = <span class="number">1</span>, cnt[s] = <span class="number">1</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        visited[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = ve[u][i].x, w = ve[u][i].y;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &lt; dis[u] + w) &#123;</span><br><span class="line">                cnt[v]++;</span><br><span class="line">                <span class="keyword">if</span>(cnt[v] &gt;= n + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">                    qu.<span class="built_in">push</span>(v);</span><br><span class="line">                    visited[v] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        ve[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        ve[i].<span class="built_in">push_back</span>(&#123;i + <span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        ve[i + <span class="number">1</span>].<span class="built_in">push_back</span>(&#123;i,<span class="number">-1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        ve[u - <span class="number">1</span>].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; dis[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目背景&quot;&gt;&lt;a href=&quot;#题目背景&quot; class=&quot;headerlink&quot; title=&quot;题目背景&quot;&gt;&lt;/a&gt;题目背景&lt;/h2&gt;&lt;p&gt;一条街的一边有几座房子，因为环保原因居民想要在路边种些树。&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    
    <category term="差分约束" scheme="http://wangxu1905.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
    <category term="spfa" scheme="http://wangxu1905.github.io/tags/spfa/"/>
    
  </entry>
  
  <entry>
    <title>P1993 小 K 的农场</title>
    <link href="http://wangxu1905.github.io/2022/03/13/P1993%20%E5%B0%8F%20K%20%E7%9A%84%E5%86%9C%E5%9C%BA/"/>
    <id>http://wangxu1905.github.io/2022/03/13/P1993%20%E5%B0%8F%20K%20%E7%9A%84%E5%86%9C%E5%9C%BA/</id>
    <published>2022-03-13T09:42:30.249Z</published>
    <updated>2022-03-13T09:49:36.932Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小 K 在 MC 里面建立很多很多的农场，总共 n 个，以至于他自己都忘记了每个农场中种植作物的具体数量了，他只记得一些含糊的信息（共 m个），以下列三种形式描述：</p><ul><li>农场 a 比农场 b 至少多种植了 c 个单位的作物；</li><li>农场 a 比农场 b 至多多种植了 c 个单位的作物；</li><li>农场 a 与农场 b 种植的作物数一样多。</li></ul><p>但是，由于小 K 的记忆有些偏差，所以他想要知道存不存在一种情况，使得农场的种植作物数量与他记忆中的所有信息吻合。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包括两个整数 n 和 m，分别表示农场数目和小 K 记忆中的信息数目。</p><p>接下来 m<em>m</em> 行：</p><ul><li>如果每行的第一个数是 1，接下来有三个整数 a,b,c，表示农场 a比农场 b至少多种植了 c 个单位的作物；</li><li>如果每行的第一个数是 2，接下来有三个整数 a,b,c，表示农场 a 比农场 b 至多多种植了 c个单位的作物;</li><li>如果每行的第一个数是 3，接下来有两个整数 a,b，表示农场 a 种植的的数量和 b 一样多。</li></ul><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果存在某种情况与小 K 的记忆吻合，输出 <code>Yes</code>，否则输出 <code>No</code>。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>对于100% 的数据，保证1≤<em>n</em>,<em>m</em>,<em>a</em>,<em>b</em>,<em>c</em>≤5×103。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    这道题不等式的形式有点多，不过不输出数量，只输出Yes或者No,也算是即复杂又简单。</p><p>​    我们选择跑最长路（最短路也行）</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, fail;</span><br><span class="line">    <span class="built_in">edge</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _fail) &#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">        fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, k, len, head[maxn], dis[maxn], in[maxn];</span><br><span class="line"><span class="keyword">bool</span> visited[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[len] = <span class="built_in">edge</span>(v, w, head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(s);</span><br><span class="line">    in[s] = <span class="number">1</span>;</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        visited[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].fail) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &lt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">                    qu.<span class="built_in">push</span>(v);</span><br><span class="line">                    in[v]++;</span><br><span class="line">                    visited[v] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(in[v] &gt; n + <span class="number">1</span>)   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">int</span> op,u, v, w;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            <span class="built_in">add</span>(v,u,w);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            <span class="built_in">add</span>(u,v,-w);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            <span class="built_in">add</span>(u,v,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(v,u,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>(<span class="number">0</span>)) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;小 K 在 MC 里面建立很多很多的农场，总共 n 个，以至于他自己都忘记</summary>
      
    
    
    
    
    <category term="差分约束" scheme="http://wangxu1905.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
    <category term="spfa" scheme="http://wangxu1905.github.io/tags/spfa/"/>
    
  </entry>
  
  <entry>
    <title>P1260 工程规划</title>
    <link href="http://wangxu1905.github.io/2022/03/13/P1260%20%E5%B7%A5%E7%A8%8B%E8%A7%84%E5%88%92/"/>
    <id>http://wangxu1905.github.io/2022/03/13/P1260%20%E5%B7%A5%E7%A8%8B%E8%A7%84%E5%88%92/</id>
    <published>2022-03-13T09:29:56.855Z</published>
    <updated>2022-03-13T09:42:11.758Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>造一幢大楼是一项艰巨的工程，它是由n个子任务构成的，给它们分别编号1，2，…，n(5≤n≤1000)。由于对一些任务的起始条件有着严格的限制，所以每个任务的起始时间T1，T2，…，Tn并不是很容易确定的(但这些起始时间都是非负整数，因为它们必须在整个工程开始后启动)。例如：挖掘完成后，紧接着就要打地基；但是混凝土浇筑完成后，却要等待一段时间再去掉模板。</p><p>这种要求就可以用M(5≤m≤5000)个不等式表示，不等式形如Ti-Tj≤b代表i和j的起始时间必须满足的条件。每个不等式的右边都是一个常数b，这些常数可能不相同，但是它们都在区间(-100，100)内。</p><p>你的任务就是写一个程序，给定像上面那样的不等式，找出一种可能的起始时间序列T1，T2，…，Tn，或者判断问题无解。对于有解的情况，要使最早进行的那个任务和整个工程的起始时间相同，也就是说，T1，T2，…，Tn中至少有一个为0。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是用空格隔开的两个正整数n和m，下面的m行每行有三个用空格隔开的整数i，j，b对应着不等式Ti-Tj≤b。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果有可行的方案，那么输出N行，每行都有一个非负整数且至少有一个为0，按顺序表示每个任务的起始时间。如果没有可行的方案，就输出信息“NO SOLUTION”。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">-1</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">-1</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">-1</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">-3</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输入 #2</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">-3</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">-1</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">-1</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">-5</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #2</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NO SOLUTION</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>由@zhouyonglong提供SPJ</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    感觉没啥，直接板子题，连个改变不等式都没有</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, fail;</span><br><span class="line">    <span class="built_in">edge</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _fail) &#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">        fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, k, len, head[maxn], dis[maxn], in[maxn];</span><br><span class="line"><span class="keyword">bool</span> visited[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[len] = <span class="built_in">edge</span>(v, w, head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(s);</span><br><span class="line">    in[s] = <span class="number">1</span>;</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        visited[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].fail) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &lt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">                    qu.<span class="built_in">push</span>(v);</span><br><span class="line">                    in[v]++;</span><br><span class="line">                    visited[v] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(in[v] &gt; n + <span class="number">1</span>)   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(u,v,-w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            cout &lt;&lt; dis[i] &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO SOLUTION&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;造一幢大楼是一项艰巨的工程，它是由n个子任务构成的，给它们分别编号1，2，</summary>
      
    
    
    
    
    <category term="差分约束" scheme="http://wangxu1905.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
    <category term="spfa" scheme="http://wangxu1905.github.io/tags/spfa/"/>
    
  </entry>
  
  <entry>
    <title>P4878 [USACO05DEC]Layout G</title>
    <link href="http://wangxu1905.github.io/2022/03/13/P4878%20[USACO05DEC]Layout%20G/"/>
    <id>http://wangxu1905.github.io/2022/03/13/P4878%20[USACO05DEC]Layout%20G/</id>
    <published>2022-03-13T09:04:19.343Z</published>
    <updated>2022-03-15T11:53:01.200Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>14组数据，前10组为原数据，后4组为hack数据</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Like everyone else, cows like to stand close to their friends when queuing for feed. FJ has N (2 &lt;= N &lt;= 1,000) cows numbered 1..N standing along a straight line waiting for feed. The cows are standing in the same order as they are numbered, and since they can be rather pushy, it is possible that two or more cows can line up at exactly the same location (that is, if we think of each cow as being located at some coordinate on a number line, then it is possible for two or more cows to share the same coordinate).</p><p>Some cows like each other and want to be within a certain distance of each other in line. Some really dislike each other and want to be separated by at least a certain distance. A list of ML (1 &lt;= ML &lt;= 10,000) constraints describes which cows like each other and the maximum distance by which they may be separated; a subsequent list of MD constraints (1 &lt;= MD &lt;= 10,000) tells which cows dislike each other and the minimum distance by which they must be separated.</p><p>Your job is to compute, if possible, the maximum possible distance between cow 1 and cow N that satisfies the distance constraints.</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Line 1: Three space-separated integers: N, ML, and MD.</p><p>Lines 2..ML+1: Each line contains three space-separated positive integers: A, B, and D, with 1 &lt;= A &lt; B &lt;= N. Cows A and B must be at most D (1 &lt;= D &lt;= 1,000,000) apart.</p><p>Lines ML+2..ML+MD+1: Each line contains three space-separated positive integers: A, B, and D, with 1 &lt;= A &lt; B &lt;= N. Cows A and B must be at least D (1 &lt;= D &lt;= 1,000,000) apart.</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>Line 1: A single integer. If no line-up is possible, output -1. If cows 1 and N can be arbitrarily far apart, output -2. Otherwise output the greatest possible distance between cows 1 and N.</p><h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p>正如其他物种一样，奶牛们也喜欢在排队打饭时与它们的朋友挨在一起。FJ 有编号为 N1…<em>N</em> 的 N 头奶牛(2≤<em>N</em>≤1000)。开始时，奶牛们按照编号顺序来排队。奶牛们很笨拙，因此可能有多头奶牛在同一位置上。</p><p>有些奶牛是好基友，它们希望彼此之间的距离小于等于某个数。有些奶牛是情敌，它们希望彼此之间的距离大于等于某个数。</p><p>给出 M_L 对好基友的编号，以及它们希望彼此之间的距离小于等于多少；又给出 M_D 对情敌的编号，以及它们希望彼此之间的距离大于等于多少 (1≤ML, MD≤104)。</p><p>请计算：如果满足上述所有条件，1 号奶牛和 N 号奶牛之间的距离最大为多少。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行：三个整数 N, M_L, M_D，用空格分隔。</p><p>第 2… M_L+1 行：每行三个整数 A, B, D，用空格分隔，表示 A号奶牛与 B 号奶牛之间的距离须 ≤<em>D</em>。保证 1≤<em>A</em>&lt;<em>B</em>≤<em>N</em>, 1≤<em>D</em>≤106.</p><p>第 M_L+2…M_L+M_D+1 行：每行三个整数 A, B, D，用空格分隔，表示 A 号奶牛与 B号奶牛之间的距离须 ≥<em>D</em>。保证 1≤<em>A</em>&lt;<em>B</em>≤<em>N</em>, 1≤<em>D</em>≤106.</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行，一个整数。如果没有合法方案，输出 <code>-1</code>. 如果有合法方案，但 1 号奶牛可以与 N 号奶牛相距无穷远，输出 <code>-2</code>. 否则，输出 1号奶牛与 N 号奶牛间的最大距离。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">10</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">20</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>Explanation of the sample:</p><p>There are 4 cows. Cows #1 and #3 must be no more than 10 units apart, cows #2 and #4 must be no more than 20 units apart, and cows #2 and #3 dislike each other and must be no fewer than 3 units apart.</p><p>The best layout, in terms of coordinates on a number line, is to put cow #1 at 0, cow #2 at 7, cow #3 at 10, and cow #4 at 27.</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    原本很不理解,为什么要跑超级源点后还要跑源点。</p><p>​    画了画图理解了，就是超级源点连向各个点的是权为0的边，这么一来所有的点的距离都更新成0，剩下的点出队时，只能是边权为负值的才能起作用，边权为正值的边根本更新不了距离。</p><p>​    还有为什么不用点1单独跑一遍呢，因为点1不一定和其他点连边，自己可能是个孤立点，所以要建立超级源点跑。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, fail;</span><br><span class="line">    <span class="built_in">edge</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _fail) &#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">        fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, k, dis[maxn], in[maxn], head[maxn], len;</span><br><span class="line"><span class="keyword">bool</span> visited[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//head[u]值存储的是以u为起点的出边的编号</span></span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[len] = <span class="built_in">edge</span>(v, w, head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    in[s] = <span class="number">1</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        visited[u] = <span class="literal">false</span>;</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].fail) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">                    qu.<span class="built_in">push</span>(v);</span><br><span class="line">                    visited[v] = <span class="literal">true</span>;</span><br><span class="line">                    ++in[v];</span><br><span class="line">                    <span class="keyword">if</span>(in[v] &gt; n + <span class="number">1</span>)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n] &gt; <span class="number">1e6</span>)  <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(v, u, -w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="built_in">add</span>(i + <span class="number">1</span>, i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">spfa</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag &lt;= <span class="number">-1</span>)  cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="built_in">spfa</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; ve[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, k, dis[maxn], cnt[maxn];</span><br><span class="line"><span class="keyword">bool</span> visited[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">    dis[s] = <span class="number">0</span>, visited[s] = <span class="number">1</span>, cnt[s] = <span class="number">1</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        visited[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = ve[u][i].x, w = ve[u][i].y;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                cnt[v]++;</span><br><span class="line">                <span class="keyword">if</span>(cnt[v] &gt;= n + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">                    qu.<span class="built_in">push</span>(v);</span><br><span class="line">                    visited[v] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ve[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        ve[i + <span class="number">1</span>].<span class="built_in">push_back</span>(&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        ve[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        ve[v].<span class="built_in">push_back</span>(&#123;u, -w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">spfa</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dis[n] &gt; <span class="number">1e6</span>)    cout &lt;&lt; <span class="string">&quot;-2&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>    cout &lt;&lt; dis[n] &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目背景&quot;&gt;&lt;a href=&quot;#题目背景&quot; class=&quot;headerlink&quot; title=&quot;题目背景&quot;&gt;&lt;/a&gt;题目背景&lt;/h2&gt;&lt;p&gt;14组数据，前10组为原数据，后4组为hack数据&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    
    <category term="差分约束" scheme="http://wangxu1905.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
    <category term="spfa" scheme="http://wangxu1905.github.io/tags/spfa/"/>
    
  </entry>
  
  <entry>
    <title>P5960 【模板】差分约束算法</title>
    <link href="http://wangxu1905.github.io/2022/03/12/P5960%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%AE%97%E6%B3%95/"/>
    <id>http://wangxu1905.github.io/2022/03/12/P5960%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%AE%97%E6%B3%95/</id>
    <published>2022-03-12T11:31:04.976Z</published>
    <updated>2022-03-12T12:06:53.612Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一组包含 m 个不等式，有 n个未知数的形如：</p><p>$ \left{\begin{array}{l}<br>x_{c_{1}}-x_{c_{1}^{\prime}} \leq y_{1} \<br>x_{c_{2}}-x_{c_{2}^{\prime}} \leq y_{2} \<br>\cdots \<br>x_{c_{m}}-x_{c_{m}^{\prime}} \leq y_{m}<br>\end{array}\right.$</p><p>的不等式组，求任意一组满足这个不等式组的解。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为两个正整数 n,m，代表未知数的数量和不等式的数量。</p><p>接下来 m 行，每行包含三个整数 c,c’,y代表一个不等式 $ x_{c}-x_{c^{\prime}} \leq y$</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行n个数，表示 x<em>1,<em>x</em>2⋯</em>xn的一组可行解，如果有多组解，请输出任意一组，无解请输出 <code>NO</code>。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">-2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p><strong>样例解释</strong></p><p>$ \left{\begin{array}{l}<br>x_{1}-x_{2} \leq 3 \<br>x_{2}-x_{3} \leq-2 \<br>x_{1}-x_{3} \leq 1<br>\end{array}\right.$</p><p>一种可行的方法是 x_1 = 5, x_2 = 3, x_3 = 5<em>x</em>1=5,<em>x</em>2=3,<em>x</em>3=5。</p><p>$ \left{\begin{array}{l}<br>5-3=2 \leq 3 \<br>3-5=-2 \leq-2 \<br>5-5=0 \leq 1<br>\end{array}\right.$</p><p><strong>数据范围</strong></p><p>对于 100 的数据，$ 1 \leq n, m \leq 5 \times 10^{3},-10^{4} \leq y \leq 10^{4}, 1 \leq c, c^{\prime} \leq n, c \neq c^{\prime}$。</p><p><strong>评分策略</strong></p><p>你的答案符合该不等式组即可得分，请确保你的答案中的数据在 <code>int</code> 范围内。</p><p>如果并没有答案，而你的程序给出了答案，SPJ 会给出 <code>There is no answer, but you gave it</code>，结果为 WA；<br>如果并没有答案，而你的程序输出了 <code>NO</code>，SPJ 会给出 <code>No answer</code>，结果为 AC；<br>如果存在答案，而你的答案错误，SPJ 会给出 <code>Wrong answer</code>，结果为 WA；<br>如果存在答案，且你的答案正确，SPJ 会给出 <code>The answer is correct</code>，结果为 AC。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    解析太长，不写了，请先上B站搜索差分约束学习。</p><p>​    简单的说，就是把差分约束系统换成最短路或者最长路问题，显然不等式的解释不唯一的。</p><p>​    两种转化形成了两种不同的连边方法</p><ol><li><p>连边后求最短路</p><p>将xj - xi &lt;= k变形为 xj &lt;= xi + k,即从i到j连一条边权为k的边。加入超级源点后求最短路，得到xi &lt;= 0的最大解,存在负环则无解</p></li><li><p>连边后求最长路</p><p>将xj - xi &lt;= k变形为xj &gt;= xi + k,即从j到i连一条边权为-k的边。加入超级源点后求最短路，得到xi &gt;= 0的最大解，存在正环则无解</p></li></ol><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><ol><li>Bellman-Ford</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125; e[<span class="number">5050</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, dis[<span class="number">5050</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        cin &gt;&gt; e[i].v &gt;&gt; e[i].u &gt;&gt; e[i].w;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每个距离进行n-1次松弛操作,如果第n次还能进行松弛,则存在负环，无解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[e[j].u] + e[j].w &lt; dis[e[j].v]) &#123;</span><br><span class="line">                dis[e[j].v] = dis[e[j].u] + e[j].w;</span><br><span class="line">                <span class="keyword">if</span>(i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>SPFA算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w,fail;</span><br><span class="line">    <span class="built_in">edge</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> _v,<span class="keyword">int</span> _w,<span class="keyword">int</span> _fail)&#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">        fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,dis[maxn],in[maxn],head[maxn],len;</span><br><span class="line"><span class="keyword">bool</span> visited[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//head[u]值存储的是以u为起点的出边的编号</span></span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[len] = <span class="built_in">edge</span>(v,w,head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="literal">false</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    in[s] = <span class="number">1</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        visited[u] = <span class="literal">false</span>;</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].fail)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v,w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &lt; dis[u] + w)&#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">                    qu.<span class="built_in">push</span>(v);</span><br><span class="line">                    visited[v] = <span class="literal">true</span>;</span><br><span class="line">                    ++in[v];</span><br><span class="line">                    <span class="keyword">if</span>(in[v] &gt; n + <span class="number">1</span>)   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(u,v,-w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入超级源点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>(<span class="number">0</span>)) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)</span><br><span class="line">            cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给出一组包含 m 个不等式，有 n个未知数的形如：&lt;/p&gt;
&lt;p&gt;$ \l</summary>
      
    
    
    
    
    <category term="差分约束" scheme="http://wangxu1905.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
  </entry>
  
  <entry>
    <title>P4378 [USACO18OPEN]Out of Sorts S</title>
    <link href="http://wangxu1905.github.io/2022/03/11/P1221%20%E6%9C%80%E5%A4%9A%E5%9B%A0%E5%AD%90%E6%95%B0/"/>
    <id>http://wangxu1905.github.io/2022/03/11/P1221%20%E6%9C%80%E5%A4%9A%E5%9B%A0%E5%AD%90%E6%95%B0/</id>
    <published>2022-03-11T11:49:06.566Z</published>
    <updated>2022-03-11T12:27:59.382Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>数学家们喜欢各种类型的有奇怪特性的数。例如，他们认为 945945 是一个有趣的数，因为它是第一个所有约数之和大于本身的奇数。</p><p>为了帮助他们寻找有趣的数，你将写一个程序扫描一定范围内的数，并确定在此范围内约数个数最多的那个数。不幸的是，这个数和给定的范围的都比较大，用简单的方法寻找可能需要较多的运行时间。所以请确定你的算法能在几秒内完成最大范围内的扫描。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>只有一行，给出扫描的范围，由下界 L和上界 U确定。满足 2≤<em>L</em>≤<em>U</em>≤10^9。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于给定的范围，输出该范围内约数个数 D<em>D</em> 最多的数 P<em>P</em>。若有多个，则输出最小的那个。请输出 <code>Between L and U，P has a maximum of D divisors.</code>，其中 L,U,P,D 的含义同前面所述。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Between <span class="number">1000</span> <span class="keyword">and</span> <span class="number">2000</span>, <span class="number">1680</span> has a maximum of <span class="number">40</span> divisors.</span><br></pre></td></tr></table></figure><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    首先根据每个合数都能写成几个质数相乘的形式，所以任何数都可以写成</p><p>$ A=x_{1}^{p 1} \times x_{2}^{p 2} \times x_{3}^{p 3} \ldots \times x_{n}^{p n}$</p><p>然后根据乘法定理，其约数个数为(p1 + 1) * (p2 + 1) * (p3 + 1)….*(pn + 1)</p><p>首先我们可以先用欧拉筛法产生素数，然后通过dfs对情况进行枚举，如果数值在范围内就进行check</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll N = <span class="number">110</span>;</span><br><span class="line">ll L,R,k,ans,res;</span><br><span class="line">ll primes[N],st[N],c[N];</span><br><span class="line"><span class="comment">//欧拉筛法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetPrimes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">2</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])  primes[k++] = i;</span><br><span class="line">        <span class="keyword">for</span>(ll j = <span class="number">0</span>; primes[j] * i &lt; N; ++j)&#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>)  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(ll num)</span></span>&#123;</span><br><span class="line">    ll cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        cnt *= (c[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; res)&#123;</span><br><span class="line">        res = cnt;</span><br><span class="line">        ans = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == res)  ans = <span class="built_in">min</span>(num,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll num,ll sta)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &gt; R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(num &gt;= L &amp;&amp; num &lt;= R)    <span class="built_in">check</span>(num);</span><br><span class="line">    <span class="keyword">for</span>(ll i = sta;i &lt; k; ++i)&#123;</span><br><span class="line">        ++c[i];</span><br><span class="line">        <span class="built_in">dfs</span>(num * primes[i],i);</span><br><span class="line">        --c[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; L &gt;&gt; R;</span><br><span class="line">    <span class="built_in">GetPrimes</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Between %lld and %lld, %lld has a maximum of %lld divisors.\n&quot;</span>,L,R,ans,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;数学家们喜欢各种类型的有奇怪特性的数。例如，他们认为 945945 是一个</summary>
      
    
    
    
    
    <category term="树状数组" scheme="http://wangxu1905.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>7-13 拯救007（升级版） (30 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/11/7-13%20%E6%8B%AF%E6%95%91007%EF%BC%88%E5%8D%87%E7%BA%A7%E7%89%88%EF%BC%89%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/11/7-13%20%E6%8B%AF%E6%95%91007%EF%BC%88%E5%8D%87%E7%BA%A7%E7%89%88%EF%BC%89%20(30%20%E5%88%86)/</id>
    <published>2022-03-11T11:34:48.856Z</published>
    <updated>2022-03-11T11:43:41.940Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>在老电影“007之生死关头”（Live and Let Die）中有一个情节，007被毒贩抓到一个鳄鱼池中心的小岛上，他用了一种极为大胆的方法逃脱 —— 直接踩着池子里一系列鳄鱼的大脑袋跳上岸去！（据说当年替身演员被最后一条鳄鱼咬住了脚，幸好穿的是特别加厚的靴子才逃过一劫。）</p><p>设鳄鱼池是长宽为100米的方形，中心坐标为 (0, 0)，且东北角坐标为 (50, 50)。池心岛是以 (0, 0) 为圆心、直径15米的圆。给定池中分布的鳄鱼的坐标、以及007一次能跳跃的最大距离，你需要给他指一条最短的逃生路径 —— 所谓“最短”是指007要跳跃的步数最少。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>首先第一行给出两个正整数：鳄鱼数量 <em>N</em>（≤100）和007一次能跳跃的最大距离 <em>D</em>。随后 <em>N</em> 行，每行给出一条鳄鱼的 (<em>x</em>,<em>y</em>) 坐标。注意：不会有两条鳄鱼待在同一个点上。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如果007有可能逃脱，首先在第一行输出007需要跳跃的最少步数，然后从第二行起，每行给出从池心岛到岸边每一步要跳到的鳄鱼的坐标 (<em>x</em>,<em>y</em>)。如果没可能逃脱，就在第一行输出 0 作为跳跃步数。如果最短路径不唯一，则输出第一跳最近的那个解，题目保证这样的解是唯一的。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span> <span class="number">15</span></span><br><span class="line"><span class="number">10</span> <span class="number">-21</span></span><br><span class="line"><span class="number">10</span> <span class="number">21</span></span><br><span class="line"><span class="number">-40</span> <span class="number">10</span></span><br><span class="line"><span class="number">30</span> <span class="number">-50</span></span><br><span class="line"><span class="number">20</span> <span class="number">40</span></span><br><span class="line"><span class="number">35</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">-10</span></span><br><span class="line"><span class="number">-25</span> <span class="number">22</span></span><br><span class="line"><span class="number">40</span> <span class="number">-40</span></span><br><span class="line"><span class="number">-30</span> <span class="number">30</span></span><br><span class="line"><span class="number">-10</span> <span class="number">22</span></span><br><span class="line"><span class="number">0</span> <span class="number">11</span></span><br><span class="line"><span class="number">25</span> <span class="number">21</span></span><br><span class="line"><span class="number">25</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">35</span></span><br><span class="line"><span class="number">-30</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">11</span></span><br><span class="line"><span class="number">10</span> <span class="number">21</span></span><br><span class="line"><span class="number">10</span> <span class="number">35</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="number">-12</span> <span class="number">12</span></span><br><span class="line"><span class="number">12</span> <span class="number">12</span></span><br><span class="line"><span class="number">-12</span> <span class="number">-12</span></span><br><span class="line"><span class="number">12</span> <span class="number">-12</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    这题真难。</p><p>​    首先用结构体，存储鳄鱼的坐标，因为要考虑第一跳和打印路径，所以还要记录距离和前驱结点。</p><p>​    1.开局就要判断是否能否不踩鳄鱼直接能跳到岸边。跳不到的话，开始苦逼思考。</p><p>​    2.读取鳄鱼的坐标，计算距离，如果能第一跳跳到，则加入数组，并记录下标</p><p>​    3.然后数组按照距离进行排序，循环进行bfs搜索</p><p>​    4.进行bfs搜索时，因为要考虑跳的次数，所以要记录搜索到了几层</p><p>​    5.如果当前bfs能找到路径，和过去找到的路径进行比较，进行更新，注意别respath.clear()我发现太慢，还是直接respath = path直接新开数组，然后直接赋值快。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,flag, res = INT_MAX, pos;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, pre = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">double</span> dis;</span><br><span class="line">&#125; node[<span class="number">101</span>];</span><br><span class="line">vector&lt;Node&gt; respath;</span><br><span class="line"><span class="keyword">int</span> visited[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pair&lt;Node, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;Node, <span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.first.dis &lt; b.first.dis;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(<span class="keyword">int</span> s,vector&lt;Node&gt; &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">PrintPath</span>(node[s].pre,path);</span><br><span class="line">    path.<span class="built_in">push_back</span>(node[s]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">-1</span>, level = <span class="number">1</span>,f = <span class="number">0</span>;</span><br><span class="line">    visited[s] = <span class="number">1</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; !f) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = qu.<span class="built_in">size</span>();</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">while</span>(num--) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = qu.<span class="built_in">front</span>();</span><br><span class="line">            last = t;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">50</span> - <span class="built_in">abs</span>(node[t].x) &lt;= d || <span class="number">50</span> - <span class="built_in">abs</span>(node[t].y) &lt;= d) &#123;</span><br><span class="line">                f = flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[i] &amp;&amp; <span class="built_in">pow</span>(node[t].x - node[i].x, <span class="number">2</span>) + <span class="built_in">pow</span>(node[t].y - node[i].y, <span class="number">2</span>) &lt;= <span class="built_in">pow</span>(d, <span class="number">2</span>)) &#123;</span><br><span class="line">                    node[i].pre = t;</span><br><span class="line">                    visited[i] = <span class="number">1</span>;</span><br><span class="line">                    qu.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f &amp;&amp; level &lt; res) &#123;</span><br><span class="line">        res = level;</span><br><span class="line">        vector&lt;Node&gt; path;</span><br><span class="line">        <span class="built_in">PrintPath</span>(last,path);</span><br><span class="line">        respath = path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">if</span>(d &gt;= <span class="number">42.5</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;pair&lt;Node, <span class="keyword">double</span>&gt;&gt; ve;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; node[i].x &gt;&gt; node[i].y;</span><br><span class="line">        node[i].dis = <span class="built_in">pow</span>(node[i].x, <span class="number">2</span>) + <span class="built_in">pow</span>(node[i].y, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(node[i].dis &lt;= <span class="built_in">pow</span>(<span class="number">7.5</span> + d, <span class="number">2</span>))</span><br><span class="line">            ve.<span class="built_in">push_back</span>(&#123;node[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ve.<span class="built_in">begin</span>(), ve.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)  node[j].pre = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">        <span class="built_in">bfs</span>(ve[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)   cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; respath.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            cout &lt;&lt; respath[i].x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; respath[i].y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;在老电影“007之生死关头”（Live and Let Die）中有一个情节，007被毒贩抓到一个鳄鱼池中心的小岛上，他用了一种极为大胆的方法逃脱 —— 直接踩着池子里一系列鳄鱼的大脑袋跳上岸去！（据说当年替身演员被最后一条</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-12 连续因子 (20 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/11/7-12%20%E8%BF%9E%E7%BB%AD%E5%9B%A0%E5%AD%90%20(20%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/11/7-12%20%E8%BF%9E%E7%BB%AD%E5%9B%A0%E5%AD%90%20(20%20%E5%88%86)/</id>
    <published>2022-03-11T10:47:23.126Z</published>
    <updated>2022-03-11T11:33:49.330Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>一个正整数 <em>N</em> 的因子中可能存在若干连续的数字。例如 630 可以分解为 3×5×6×7，其中 5、6、7 就是 3 个连续的数字。给定任一正整数 <em>N</em>，要求编写程序求出最长连续因子的个数，并输出最小的连续因子序列。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个正整数 <em>N</em>（1&lt;<em>N</em>&lt;2^31）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在第 1 行输出最长连续因子的个数；然后在第 2 行中按 <code>因子1*因子2*……*因子k</code> 的格式输出最小的连续因子序列，其中因子按递增顺序输出，1 不算在内。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">630</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5*6*7</span><br></pre></td></tr></table></figure><p><strong>鸣谢用户 漏穿雪 补充数据！</strong></p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    一开始想着dfs和剪枝（最后感觉也没啥必要），是我菜了，有一个测试点过不去，还是搞传统做法吧。</p><p>​    要先判断是否是质数（不判断的话，后面直接分解因子会超时）。</p><p>​    然后进行暴力分解，枚举。(没啥好说的)</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,res = <span class="number">0</span>,start = <span class="number">0</span>,flag = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">sqrt</span>(n); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = n,len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k % j == <span class="number">0</span>)&#123;</span><br><span class="line">                k /= j;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(res &lt; len)&#123;</span><br><span class="line">                    res = len;</span><br><span class="line">                    start = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i)   cout &lt;&lt; <span class="string">&quot;*&quot;</span>;</span><br><span class="line">        cout &lt;&lt; start + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;一个正整数 &lt;em&gt;N&lt;/em&gt; 的因子中可能存在若干连续的数字。例如 630 可以分解为 3×5×6×7，其中 5、6、7 就是 3 个连续的数字。给定任一正整数 &lt;em&gt;N&lt;/em&gt;，要求编写程序求出最长连续因子的个数，</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-11 回文子串 (10 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/11/7-11%20%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%20(10%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/11/7-11%20%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%20(10%20%E5%88%86)/</id>
    <published>2022-03-11T10:40:34.394Z</published>
    <updated>2022-03-11T10:47:05.463Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，输出所有长度至少为2的回文子串。 </span><br><span class="line">回文子串即从左往右输出和从右往左输出结果是一样的字符串，比如：abba，cccdeedccc都是回文字符串。</span><br></pre></td></tr></table></figure><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个字符串，由字母或数字组成。长度500以内。</span><br></pre></td></tr></table></figure><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出所有的回文子串，每个子串一行。</span><br><span class="line">子串长度小的优先输出，若长度相等，则出现位置靠左的优先输出。</span><br></pre></td></tr></table></figure><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123321125775165561</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">77</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">2332</span></span><br><span class="line"><span class="number">2112</span></span><br><span class="line"><span class="number">5775</span></span><br><span class="line"><span class="number">6556</span></span><br><span class="line"><span class="number">123321</span></span><br><span class="line"><span class="number">165561</span></span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p>该题目选自OpenJudge网站，在线网址：<a href="http://noi.openjudge.cn/ch0107/34/">http://noi.openjudge.cn/ch0107/34/</a></p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    和[7-6 最长对称子串 (25 分) | Moon (wangxu1905.github.io)](<a href="https://wangxu1905.github.io/2022/01/03/7-6">https://wangxu1905.github.io/2022/01/03/7-6</a> 最长对称子串 (25 分)/index.html)不同的是，这道题只要是回文就要输出（不在意长度），而且要按长度和先后顺序输出，所以采用结构体存储结果，最后进行排序。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">&#125;;</span><br><span class="line">string s;</span><br><span class="line">vector&lt;Node&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.str.<span class="built_in">size</span>() != b.str.<span class="built_in">size</span>())    <span class="keyword">return</span> a.str.<span class="built_in">size</span>() &lt; b.str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> a.pos &lt; b.pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Judge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = l,high = r;</span><br><span class="line">    <span class="keyword">if</span>(s[low] != s[high])   <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &gt;= <span class="number">0</span> &amp;&amp; high &lt; s.<span class="built_in">size</span>() &amp;&amp; s[low] == s[high])&#123;</span><br><span class="line">        <span class="comment">//只要长度超过1就存进结果集</span></span><br><span class="line">        <span class="keyword">if</span>(high - low + <span class="number">1</span> &gt;= <span class="number">2</span>)</span><br><span class="line">            res.<span class="built_in">push_back</span>(Node&#123;s.<span class="built_in">substr</span>(low,high - low + <span class="number">1</span>),l&#125;);</span><br><span class="line">        low--;high++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="built_in">Judge</span>(i,i);</span><br><span class="line">        <span class="built_in">Judge</span>(i,i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(Node &amp;node : res)</span><br><span class="line">        cout &lt;&lt; node.str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;任务描述&quot;&gt;&lt;a href=&quot;#任务描述&quot; class=&quot;headerlink&quot; title=&quot;任务描述&quot;&gt;&lt;/a&gt;任务描述&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;tab</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-10 单身狗 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/11/7-10%20%E5%8D%95%E8%BA%AB%E7%8B%97%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/11/7-10%20%E5%8D%95%E8%BA%AB%E7%8B%97%20(25%20%E5%88%86)/</id>
    <published>2022-03-11T10:32:13.226Z</published>
    <updated>2022-03-11T10:39:55.779Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>“单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 N（≤50000），是已知夫妻/伴侣的对数；随后 N 行，每行给出一对夫妻/伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤10000），为参加派对的总人数；随后一行给出这 M 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">11111</span> <span class="number">22222</span></span><br><span class="line"><span class="number">33333</span> <span class="number">44444</span></span><br><span class="line"><span class="number">55555</span> <span class="number">66666</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">55555</span> <span class="number">44444</span> <span class="number">10000</span> <span class="number">88888</span> <span class="number">22222</span> <span class="number">11111</span> <span class="number">23333</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10000</span> <span class="number">23333</span> <span class="number">44444</span> <span class="number">55555</span> <span class="number">88888</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    这题很简单，只不过有个坑需要避。就是不是单身狗的人，也有可能他（她）的另一半没有在派对里，此时他（她）也是落单客人。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    map&lt;string,string&gt; m;</span><br><span class="line">    vector&lt;string&gt; ve,res;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        string a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        m[a] = b;</span><br><span class="line">        m[b] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        string a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        ve.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ve.<span class="built_in">begin</span>(),ve.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">       <span class="comment">//如果有对象并且对象还在派对名单里</span></span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">count</span>(ve[i]) &amp;&amp; *<span class="built_in">lower_bound</span>(ve.<span class="built_in">begin</span>(),ve.<span class="built_in">end</span>(),m[ve[i]]) == m[ve[i]])    <span class="keyword">continue</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(ve[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i)   cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;“单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。&lt;/p&gt;
&lt;h3 id=&quot;输入格式：&quot;&gt;&lt;a href=&quot;#输入格式：&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-5 冰岛人 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/10/7-5%20%E5%86%B0%E5%B2%9B%E4%BA%BA%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/10/7-5%20%E5%86%B0%E5%B2%9B%E4%BA%BA%20(25%20%E5%88%86)/</id>
    <published>2022-03-10T12:48:31.727Z</published>
    <updated>2022-03-10T13:29:43.451Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>2018年世界杯，冰岛队因1:1平了强大的阿根廷队而一战成名。好事者发现冰岛人的名字后面似乎都有个“松”（son），于是有网友科普如下：</p><p><img src="https://images.ptausercontent.com/73226e55-2588-4d45-b049-a6e72de90872.JPG" alt="iceland.JPG"></p><p>冰岛人沿用的是维京人古老的父系姓制，孩子的姓等于父亲的名加后缀，如果是儿子就加 sson，女儿则加 sdottir。因为冰岛人口较少，为避免近亲繁衍，本地人交往前先用个 App 查一下两人祖宗若干代有无联系。本题就请你实现这个 App 的功能。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先在第一行给出一个正整数 <em>N</em>（1&lt;<em>N</em>≤105），为当地人口数。随后 <em>N</em> 行，每行给出一个人名，格式为：<code>名 姓（带性别后缀）</code>，两个字符串均由不超过 20 个小写的英文字母组成。维京人后裔是可以通过姓的后缀判断其性别的，其他人则是在姓的后面加 <code>m</code> 表示男性、<code>f</code> 表示女性。题目保证给出的每个维京家族的起源人都是男性。</p><p>随后一行给出正整数 <em>M</em>，为查询数量。随后 <em>M</em> 行，每行给出一对人名，格式为：<code>名1 姓1 名2 姓2</code>。注意：这里的<code>姓</code>是不带后缀的。四个字符串均由不超过 20 个小写的英文字母组成。</p><p>题目保证不存在两个人是同名的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每一个查询，根据结果在一行内显示以下信息：</p><ul><li>若两人为异性，且五代以内无公共祖先，则输出 <code>Yes</code>；</li><li>若两人为异性，但五代以内（不包括第五代）有公共祖先，则输出 <code>No</code>；</li><li>若两人为同性，则输出 <code>Whatever</code>；</li><li>若有一人不在名单内，则输出 <code>NA</code>。</li></ul><p>所谓“五代以内无公共祖先”是指两人的公共祖先（如果存在的话）必须比任何一方的曾祖父辈分高。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span></span><br><span class="line">chris smithm</span><br><span class="line">adam smithm</span><br><span class="line">bob adamsson</span><br><span class="line">jack chrissson</span><br><span class="line">bill chrissson</span><br><span class="line">mike jacksson</span><br><span class="line">steve billsson</span><br><span class="line">tim mikesson</span><br><span class="line">april mikesdottir</span><br><span class="line">eric stevesson</span><br><span class="line">tracy timsdottir</span><br><span class="line">james ericsson</span><br><span class="line">patrick jacksson</span><br><span class="line">robin patricksson</span><br><span class="line">will robinsson</span><br><span class="line"><span class="number">6</span></span><br><span class="line">tracy tim james eric</span><br><span class="line">will robin tracy tim</span><br><span class="line">april mike steve bill</span><br><span class="line">bob adam eric steve</span><br><span class="line">tracy tim tracy tim</span><br><span class="line">x man april mikes</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br><span class="line">Whatever</span><br><span class="line">Whatever</span><br><span class="line">NA</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    我们可以根据名字的后缀，来确定性别，我们用map存储姓名和性别（0为女，1为男）。因为性别的后缀对于我们来说没用，可以直接不存后缀。注意，姓名我们只在意维京人的。</p><p>​    然后进行检查判断，找不到或者同性很好判断就不说了。</p><p>​    我采用的是dfs，把两个人所有的祖先都存起来，然后，进行两层循环比较，如果出现相同的祖先，并且是至少一个人的五代内的祖先，则输出No，否则输出Yes</p><p>​    </p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;string,<span class="keyword">int</span>&gt; PII;</span><br><span class="line">map&lt;string,PII&gt; book;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string s,vector&lt;string&gt; &amp;ve)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(book.<span class="built_in">count</span>(s))&#123;</span><br><span class="line">        ve.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="built_in">dfs</span>(book[s].x,ve);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        string a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">int</span> pos = (<span class="keyword">int</span>)b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(b[pos] == <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">            book[a] = &#123;b.<span class="built_in">substr</span>(<span class="number">0</span>,b.<span class="built_in">size</span>() - <span class="number">7</span>),<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b[pos] == <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">            book[a] = &#123;<span class="string">&quot;&quot;</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b[pos] == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">            book[a] = &#123;b.<span class="built_in">substr</span>(<span class="number">0</span>,b.<span class="built_in">size</span>() - <span class="number">4</span>),<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b[pos] == <span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">            book[a] = &#123;<span class="string">&quot;&quot;</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            book[a] = &#123;<span class="string">&quot;&quot;</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        string a,b,s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; s &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(book.<span class="built_in">count</span>(a) == <span class="number">0</span> || book.<span class="built_in">count</span>(b) == <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NA&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(book[a].y == book[b].y)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Whatever&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            vector&lt;string&gt; ve1,ve2;</span><br><span class="line">            <span class="built_in">dfs</span>(a,ve1);</span><br><span class="line">            <span class="built_in">dfs</span>(b,ve2);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve1.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag)  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ve2.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt;= <span class="number">4</span> &amp;&amp; j &gt;= <span class="number">4</span>)  <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//注意是和4比较，第一代是本人</span></span><br><span class="line">                    <span class="keyword">if</span>(ve1[i] == ve2[j] &amp;&amp; (i &lt; <span class="number">4</span> || j &lt; <span class="number">4</span>))&#123;</span><br><span class="line">                        flag = <span class="number">0</span>;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;2018年世界杯，冰岛队因1:1平了强大的阿根廷队而一战成名。好事者发现冰岛人的名字后面似乎都有个“松”（son），于是有网友科普如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.ptausercont</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
</feed>
