<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moon</title>
  
  
  <link href="http://wangxu1905.github.io/atom.xml" rel="self"/>
  
  <link href="http://wangxu1905.github.io/"/>
  <updated>2022-01-05T13:08:55.311Z</updated>
  <id>http://wangxu1905.github.io/</id>
  
  <author>
    <name>Moon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>提高程序效率的位运算</title>
    <link href="http://wangxu1905.github.io/2022/01/05/%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E6%95%88%E7%8E%87%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://wangxu1905.github.io/2022/01/05/%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E6%95%88%E7%8E%87%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2022-01-05T13:02:43.822Z</published>
    <updated>2022-01-05T13:08:55.311Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><ul><li>如果树的父亲结点为n,则左孩子结点为n &lt;&lt; 1,右孩子为 n &lt;&lt; 1 | 1;</li><li>二分查找mid = (left + right) &gt;&gt; 1;</li><li>还有自己写scanf函数读取整数值来提高运行效率（tql）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;ul&gt;
&lt;li&gt;如果树的父亲结点为n,则左孩子结点为n &amp;lt;&amp;lt; 1,右孩子为 n &amp;lt;&amp;lt; 1 | 1;&lt;/li&gt;
&lt;li&gt;二分查找mid = (left + right) &amp;gt;&amp;gt; 1;&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="位运算" scheme="http://wangxu1905.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>P3373 【模板】线段树 2</title>
    <link href="http://wangxu1905.github.io/2022/01/05/P3373%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%202/"/>
    <id>http://wangxu1905.github.io/2022/01/05/P3373%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%202/</id>
    <published>2022-01-05T12:45:25.154Z</published>
    <updated>2022-01-05T13:00:52.075Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面三种操作：</p><ul><li>将某区间每一个数乘上 x</li><li>将某区间每一个数加上 x</li><li>求出某区间每一个数的和</li></ul><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含三个整数 n*,<em>m</em>,*p，分别表示该数列数字的个数、操作的总个数和模数。</p><p>第二行包含 n个用空格分隔的整数，其中第 i个数字表示数列第 i项的初始值。</p><p>接下来 m 行每行包含若干个整数，表示一个操作，具体如下：</p><p>操作 11： 格式：<code>1 x y k</code> 含义：将区间 [x,y][<em>x</em>,<em>y</em>] 内每个数乘上 k</p><p>操作 22： 格式：<code>2 x y k</code> 含义：将区间 [x,y][<em>x</em>,<em>y</em>] 内每个数加上 k</p><p>操作 33： 格式：<code>3 x y</code> 含义：输出区间 [x,y][<em>x</em>,<em>y</em>] 内每个数的和对 p 取模所得的结果</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 3 的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">38</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>【数据范围】</p><p>对于 30% 的数据：n<em>≤8，m</em>≤10<br>对于 70% 的数据：n≤10^3，m≤10^4<br>对于 100% 的数据：n≤10^5，m≤10^5</p><p>除样例外，p = 571373</p><p>（数据已经过加强^_^）</p><p>样例说明：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/2255.png" alt="img"></p><p>故输出应为 17、2（40 mod 38=2 ）</p><h2 id="锹黑板："><a href="#锹黑板：" class="headerlink" title="锹黑板："></a><strong>锹黑板：</strong></h2><p>首先我们回忆一下线段树１的加法标记<strong>他其实是打在父亲节点上的标记儿子加多少的</strong>，打完标记的同时父亲的sum其实已经加上了add * len</p><p>那我们回到这道题我们发现题目要求在加数的同时<strong>还要区间乘</strong></p><p>比如现在有3个数1,2,3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">1</span>~<span class="number">3</span>(<span class="number">1</span>)</span><br><span class="line">         /     \</span><br><span class="line">    <span class="number">1</span>~<span class="number">2</span>(<span class="number">2</span>)      <span class="number">3</span>(<span class="number">3</span>)</span><br><span class="line">   /      \</span><br><span class="line"><span class="number">1</span>(<span class="number">4</span>)      <span class="number">2</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>我们先给1~3加上2</strong>,画个小小小小的图，<strong>节点后面的括号代表节点下标</strong></p><p>所以</p><p>t[1].add += 2;</p><p>t[1].sum+=( (3 - 1) + 1) * 2;</p><p><strong>我们再给1~3乘上3</strong></p><p>所以</p><p>t[1].mu *= 3;</p><p><strong>我们再给1~3加上4，那是不是先加再乘</strong></p><p>t[1].add += 4;</p><p>obviously我们发现不能先加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">操作<span class="number">2</span>之后的式子是:</span><br><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>)*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>)*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>)*<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>如果直接加:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">式子是:</span><br><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>+<span class="number">4</span>)*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>+<span class="number">4</span>)*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>+<span class="number">4</span>)*<span class="number">3</span>;</span><br><span class="line">   =(a[<span class="number">1</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>*<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>我们发现这和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>+(a[<span class="number">2</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>+(a[<span class="number">3</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>并不等价</p><p>而要等价必须这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>+<span class="number">4</span>/<span class="number">3</span>)*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>+<span class="number">4</span>/<span class="number">3</span>)*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>+<span class="number">4</span>/<span class="number">3</span>)*<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><strong>我们发现这样就成了实数运算了,还有可能除成无限小数</strong></p><p>而先乘后加:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=(a[<span class="number">1</span>]*<span class="number">3</span>+<span class="number">2</span>*<span class="number">3</span>+<span class="number">4</span>)+(a[<span class="number">2</span>]*<span class="number">3</span>+<span class="number">2</span>*<span class="number">3</span>+<span class="number">4</span>)+(a[<span class="number">3</span>]*<span class="number">3</span>+<span class="number">2</span>*<span class="number">3</span>+<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"><span class="keyword">int</span> a[maxn + <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre,add,mul;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn + <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;t[p].r = r;</span><br><span class="line">    t[p].add = <span class="number">0</span>;t[p].mul = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        t[p].pre = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> , l , mid);</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">    t[p].pre = (t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 根据先乘后加的优先度，儿子的值 = 此刻儿子的值*爸爸乘法的lazytag +儿子的区间长度*爸爸加法的lazytag */</span></span><br><span class="line">    t[p * <span class="number">2</span>].pre = (t[p * <span class="number">2</span>].pre * t[p].mul + t[p].add * (t[p * <span class="number">2</span>].r - t[p * <span class="number">2</span>].l + <span class="number">1</span>)) % mod;</span><br><span class="line">    t[p * <span class="number">2</span> + <span class="number">1</span>].pre = (t[p * <span class="number">2</span> + <span class="number">1</span>].pre * t[p].mul + t[p].add * (t[p * <span class="number">2</span> + <span class="number">1</span>].r - t[p * <span class="number">2</span> + <span class="number">1</span>].l + <span class="number">1</span>)) % mod;</span><br><span class="line">    <span class="comment">//维护lazytag</span></span><br><span class="line">    t[p * <span class="number">2</span>].mul = (t[p * <span class="number">2</span>].mul * t[p].mul) % mod;</span><br><span class="line">    t[p * <span class="number">2</span> + <span class="number">1</span>].mul = (t[p * <span class="number">2</span> + <span class="number">1</span>].mul * t[p].mul) % mod;</span><br><span class="line">    t[p * <span class="number">2</span>].add = (t[p * <span class="number">2</span>].add * t[p].mul + t[p].add) % mod;</span><br><span class="line">    t[p * <span class="number">2</span> + <span class="number">1</span>].add = (t[p * <span class="number">2</span> + <span class="number">1</span>].add * t[p].mul + t[p].add) % mod;</span><br><span class="line">    <span class="comment">//父节点的lazytag初始哈</span></span><br><span class="line">    t[p].mul = <span class="number">1</span>;</span><br><span class="line">    t[p].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="comment">//被覆盖的话</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre = (t[p].pre * z) % mod;</span><br><span class="line">        t[p].mul = (t[p].mul * z) % mod;</span><br><span class="line">        t[p].add = (t[p].add * z) % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有被覆盖，则下传lazytag</span></span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change1</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change1</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    t[p].pre = (t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加法，和乘法同理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change2</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre = (t[p].pre + (<span class="keyword">long</span> <span class="keyword">long</span>)z * (t[p].r - t[p].l + <span class="number">1</span>)) % mod;</span><br><span class="line">        t[p].add = (t[p].add + z) % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change2</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change2</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    t[p].pre = (t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)  <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    ans += <span class="built_in">ask</span>(p * <span class="number">2</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       ans += <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> q,x,y,k;</span><br><span class="line">        cin &gt;&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            <span class="built_in">change1</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(q == <span class="number">2</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            <span class="built_in">change2</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">ask</span>(<span class="number">1</span>,x,y) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如题，已知一个数列，你需要进行下面三种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将</summary>
      
    
    
    
    
    <category term="线段树" scheme="http://wangxu1905.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>P3372 【模板】线段树 1</title>
    <link href="http://wangxu1905.github.io/2022/01/05/P3372%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%201/"/>
    <id>http://wangxu1905.github.io/2022/01/05/P3372%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%201/</id>
    <published>2022-01-05T11:55:30.887Z</published>
    <updated>2022-01-05T12:45:12.170Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li>将某区间每一个数加上 k。</li><li>求出某区间每一个数的和。</li></ol><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 n, m，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 n个用空格分隔的整数，其中第 i 个数字表示数列第 i项的初始值。</p><p>接下来 m 行每行包含 3或 4 个整数，表示一个操作，具体如下：</p><ol><li><code>1 x y k</code>：将区间 [x, y][<em>x</em>,<em>y</em>] 内每个数加上 k。</li><li><code>2 x y</code>：输出区间 [x, y][<em>x</em>,<em>y</em>] 内每个数的和。</li></ol><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 2 的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>对于 30% 的数据：n≤8，m≤10。<br>对于 70% 的数据：n≤10^3，m≤10^4。<br>对于 100% 的数据：1≤<em>n</em>,<em>m</em>≤10^5。</p><p>保证任意时刻数列中任意元素的和在 [−2^63,2^63) 内。</p><p><strong>【样例解释】</strong></p><p><img src="https://cdn.luogu.com.cn/upload/pic/2251.png" alt="img"></p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    看题干就知道线段树，线段树可以维护区间加，区间查找等操作，其余还有区间乘，区间最大值，甚至最大子段和等操作。</p><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h4 id="1-线段树的存储"><a href="#1-线段树的存储" class="headerlink" title="1.线段树的存储"></a>1.线段树的存储</h4><p>采用结构体存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn + <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre,add;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn + <span class="number">2</span>];</span><br></pre></td></tr></table></figure><h4 id="2-建树"><a href="#2-建树" class="headerlink" title="2.建树"></a>2.建树</h4><p>所谓建树，就是把数组a[1 - n]放到线段树中</p><p>在线段树中，对于一个区间(编号为p),它的左儿子为2 * p,右儿子为2 * p + 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;t[p].r = r; <span class="comment">//存储该节点维护的区间范围</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;<span class="comment">//如果区间只有一个数，则直接赋值</span></span><br><span class="line">        t[p].pre = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则维护的值等于左儿子加右儿子</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> , l , mid);</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-懒标记"><a href="#3-懒标记" class="headerlink" title="3.懒标记"></a>3.懒标记</h4><p>​    懒标记的精髓就是打标计和下传操作，由于要做的操作是区间加一个数，所以不妨在区间进行修改时为该区间打上一个标记，就不必再修改它的儿子所维护的区间，等到要是用该节结点儿子维护的值，再将懒标记下放即可，可以省下很多时间，对于每次区间修改和查询，将懒标记下传，可以节省很多时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add)&#123; <span class="comment">//如果懒标记不为0，就将其下传，修改左右儿子维护的值</span></span><br><span class="line">        t[p * <span class="number">2</span>].pre += t[p].add * (t[p * <span class="number">2</span>].r - t[p * <span class="number">2</span>].l + <span class="number">1</span>);</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].pre += t[p].add * (t[p * <span class="number">2</span> + <span class="number">1</span>].r - t[p * <span class="number">2</span> + <span class="number">1</span>].l + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//为该结点的左右儿子打上标记</span></span><br><span class="line">        t[p * <span class="number">2</span>].add += t[p].add;</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].add += t[p].add;</span><br><span class="line">        <span class="comment">//下传之后将该结点的懒标记清0</span></span><br><span class="line">        t[p].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-区间修改"><a href="#4-区间修改" class="headerlink" title="4.区间修改"></a>4.区间修改</h4><p>​    考虑到将一个区间加上一个数，我们可以从根结点不断向下查找，当发现我们要修改的区间覆盖了当前结点时，我们就把这个区间修改，并打上懒标记（由于懒标记的存在，我们就不必再修改它的儿子结点），否则下传懒标记，继续向下找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123; <span class="comment">//被覆盖的话，就对其进行修改</span></span><br><span class="line">        t[p].pre += (<span class="keyword">long</span> <span class="keyword">long</span>)z * (t[p].r - t[p].l + <span class="number">1</span>);</span><br><span class="line">        t[p].add += z;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*如果发现没有被覆盖，那么继续向下找，考虑儿子所维护的区间可能因为懒标记的存在而没有修改，因此懒标记下放*/</span></span><br><span class="line">    <span class="built_in">spread</span>(p); </span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果要修改的区间覆盖了左儿子，就修改左儿子，右儿子同理</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    <span class="comment">//最终维护的值等于左儿子值加右儿子值</span></span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-区间查询"><a href="#5-区间查询" class="headerlink" title="5.区间查询"></a>5.区间查询</h4><p>​    考虑询问一个区间的和，依旧是从根结点向下查找，当发现结点被覆盖时，就返回维护的值，否则下传懒标记，查询左右儿子，累加答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果被覆盖，就返回维护的值</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)  <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    <span class="comment">//下传懒标记，并查询左右儿子</span></span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    ans += <span class="built_in">ask</span>(p * <span class="number">2</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       ans += <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn + <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre,add;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn + <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        t[p].pre = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> , l , mid);</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add)&#123;</span><br><span class="line">        t[p * <span class="number">2</span>].pre += t[p].add * (t[p * <span class="number">2</span>].r - t[p * <span class="number">2</span>].l + <span class="number">1</span>);</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].pre += t[p].add * (t[p * <span class="number">2</span> + <span class="number">1</span>].r - t[p * <span class="number">2</span> + <span class="number">1</span>].l + <span class="number">1</span>);</span><br><span class="line">        t[p * <span class="number">2</span>].add += t[p].add;</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].add += t[p].add;</span><br><span class="line">        t[p].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre += (<span class="keyword">long</span> <span class="keyword">long</span>)z * (t[p].r - t[p].l + <span class="number">1</span>);</span><br><span class="line">        t[p].add += z;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)  <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    ans += <span class="built_in">ask</span>(p * <span class="number">2</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       ans += <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> q,x,y,z;</span><br><span class="line">        cin &gt;&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">ask</span>(<span class="number">1</span>,x,y) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如题，已知一个数列，你需要进行下面两种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将</summary>
      
    
    
    
    
    <category term="线段树" scheme="http://wangxu1905.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>42. 接雨水</title>
    <link href="http://wangxu1905.github.io/2022/01/05/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>http://wangxu1905.github.io/2022/01/05/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/</id>
    <published>2022-01-05T02:26:06.613Z</published>
    <updated>2022-01-05T03:58:13.940Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><blockquote><p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：height = [4,2,0,3,2,5]<br>输出：9</p></blockquote><p><strong>提示：</strong></p><ul><li>n == height.length</li><li>1 &lt;= n &lt;= 2 * 104</li><li>0 &lt;= height[i] &lt;= 105</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a><strong>方法一：动态规划</strong></h3><p>​    根据木桶原理，左右两个柱子，最后能存多少雨水，取决于最短的板子，所以可以从左到右遍历一遍，求得从左到该位置的最长的板子，从右到左遍历，求得从右到该位置的最长的板子。</p><p>​    计算完左右最长的板子后，然后再遍历一遍，该柱子能否存储雨水，取决于左右最长柱子中的最短柱子和该柱子的差。</p><p><img src="https://assets.leetcode-cn.com/solution-static/42/1.png"></p><h4 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>,<span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        left[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        right[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            left[i] = <span class="built_in">max</span>(left[i - <span class="number">1</span>],height[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            right[i] = <span class="built_in">max</span>(right[i + <span class="number">1</span>],height[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            ans += <span class="built_in">min</span>(left[i],right[i]) - height[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)，计算left，right和雨水量需要遍历三次</li><li>空间复杂度：O(n)，创建两个长度为n的数组存储left和right</li></ul><h3 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a><strong>方法二：单调栈</strong></h3><p>​    维护一个单调栈，单调栈存储的是下标，满足从栈底到栈顶的下标对应的数组 height 中的元素递减。</p><p>​    从左到右遍历数组，如果栈内至少有两个元素，记栈顶元素为 top，top 的下面一个元素是 left，则一定有 height[left] ≥ height[top]。如果 height[i]&gt;height[top]，则得到一个可以接雨水的区域，该区域的宽度是i−left−1，高度是 min(height[left],height[i])−height[top]，根据宽度和高度即可计算得到该区域能接的雨水量。</p><p>​    为了得到 left，需要将 top 出栈。在对top 计算能接的雨水量之后，left 变成新的 top，重复上述操作，直到栈变为空，或者栈顶下标对应的height 中的元素大于或等于height[i]。</p><h4 id="实现代码：-1"><a href="#实现代码：-1" class="headerlink" title="实现代码："></a>实现代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,n = height.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="keyword">int</span> top = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">int</span> curWidth = i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> curHeight = <span class="built_in">min</span>(height[left],height[i]) - height[top];</span><br><span class="line">                ans += curHeight * curWidth;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)，其中 n 是数组height 的长度。从 0 到 n−1 的每个下标最多只会入栈和出栈各一次。</li><li>空间复杂度：O(n)，主要取决于栈空间</li></ul><h3 id="方法三：双指针"><a href="#方法三：双指针" class="headerlink" title="方法三：双指针"></a><strong>方法三：双指针</strong></h3><p>​    和动态规划一样，只不过用双指针代替求左右最长板子的两个数组。</p><p>​    维护两个指针left和right，以及两个变量leftMax和rightMax,在移动过程中更新leftMax和rightMax。</p><p>​    当两个指针没有相遇时，进行如下操作：</p><ul><li>使用height[left]和height[right]的值更新leftMax和rightMax</li><li>如果height[left] &lt; height[right]，则必有leftMax &lt; rightMax，下标left能接的雨水量等于leftMax - height[left]，然后left向右移动一位</li><li>如果height[left] &gt;= height[right]，则必有leftMax &gt;= rightMax，下标right能接的雨水量等于rightMax - height[right]，然后right向左移动一位</li></ul><p>当两个指针相遇时，即可得到能接的雨水总量。</p><h4 id="实现代码：-2"><a href="#实现代码：-2" class="headerlink" title="实现代码："></a>实现代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,left = <span class="number">0</span>,right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>,rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            leftMax = <span class="built_in">max</span>(leftMax,height[left]);</span><br><span class="line">            rightMax = <span class="built_in">max</span>(rightMax,height[right]);</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                ans += leftMax - height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += rightMax - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(n)，其中 n 是数组height 的长度。两个指针的移动总次数不超过 n。</p></li><li><p>空间复杂度：O(1)，只需要使用常数的额外空间。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 个非负整数表示每个宽度为 &lt;code&gt;1&lt;/code&gt; 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="双指针" scheme="http://wangxu1905.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="动态规划" scheme="http://wangxu1905.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="单调栈" scheme="http://wangxu1905.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>P3368 【模板】树状数组 2</title>
    <link href="http://wangxu1905.github.io/2022/01/04/P3368%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%202/"/>
    <id>http://wangxu1905.github.io/2022/01/04/P3368%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%202/</id>
    <published>2022-01-04T09:56:28.308Z</published>
    <updated>2022-01-04T10:11:58.455Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li>将某区间每一个数数加上 x；</li><li>求出某一个数的值。</li></ol><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 N、M，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 N个用空格分隔的整数，其中第 i个数字表示数列第 i项的初始值。</p><p>接下来 M行每行包含 2 或 4个整数，表示一个操作，具体如下：</p><p>操作 1： 格式：<code>1 x y k</code> 含义：将区间 [x,y][<em>x</em>,<em>y</em>] 内每个数加上 k；</p><p>操作 2： 格式：<code>2 x</code> 含义：输出第 x个数的值。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 2的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><h4 id="样例-1-解释："><a href="#样例-1-解释：" class="headerlink" title="样例 1 解释："></a>样例 1 解释：</h4><p><img src="https://cdn.luogu.com.cn/upload/pic/2258.png" alt="img"></p><p>故输出结果为 6、10。</p><hr><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 30% 的数据：N≤8,M≤10;</p><p>对于 70% 的数据：N≤ 10000,M≤10000;</p><p>对于 100%的数据：1 ≤ N, M≤ 500000，1 ≤ x, y ≤n，保证任意时刻序列中任意元素的绝对值都不大于 2^30。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, m, tree[<span class="number">500100</span>], input[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k &amp; -k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">        tree[x] += k;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">        ans += tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; input[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y, z;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="built_in">add</span>(x, z);</span><br><span class="line">            <span class="built_in">add</span>(y + <span class="number">1</span>, -z);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; input[x] + <span class="built_in">search</span>(x) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如题，已知一个数列，你需要进行下面两种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将</summary>
      
    
    
    
    
    <category term="树状数组" scheme="http://wangxu1905.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>P3374 【模板】树状数组 1</title>
    <link href="http://wangxu1905.github.io/2022/01/04/P3374%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%201/"/>
    <id>http://wangxu1905.github.io/2022/01/04/P3374%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%201/</id>
    <published>2022-01-04T09:51:30.230Z</published>
    <updated>2022-01-04T09:56:15.584Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面两种操作：</p><ul><li>将某一个数加上 x</li><li>求出某区间每一个数的和</li></ul><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数 n,m，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 n个用空格分隔的整数，其中第 i 个数字表示数列第 i项的初始值。</p><p>接下来 m行每行包含 3个整数，表示一个操作，具体如下：</p><ul><li><code>1 x k</code> 含义：将第 x个数加上 k</li><li><code>2 x y</code> 含义：输出区间 [x,y][<em>x</em>,<em>y</em>] 内每个数的和</li></ul><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 2的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>【数据范围】</p><p>对于 30%30% 的数据，1 ≤ n ≤ 8，1≤ m ≤ 10；<br>对于 70%70% 的数据，1≤ n,m ≤ 10^4；<br>对于 100%100% 的数据，1≤ n,m ≤ 5×10^5。</p><p>样例说明：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/2256.png" alt="img"></p><p>故输出结果14、16</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,tree[<span class="number">2000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k &amp; -k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n)&#123;</span><br><span class="line">        tree[x] += k;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        ans += tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">add</span>(i,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">add</span>(b,c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">2</span>)</span><br><span class="line">            cout &lt;&lt; <span class="built_in">sum</span>(c) - <span class="built_in">sum</span>(b - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如题，已知一个数列，你需要进行下面两种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将某</summary>
      
    
    
    
    
    <category term="树状数组" scheme="http://wangxu1905.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>P2880 [USACO07JAN]Balanced Lineup G</title>
    <link href="http://wangxu1905.github.io/2022/01/04/P2880%20[USACO07JAN]Balanced%20Lineup%20G/"/>
    <id>http://wangxu1905.github.io/2022/01/04/P2880%20[USACO07JAN]Balanced%20Lineup%20G/</id>
    <published>2022-01-04T09:47:03.190Z</published>
    <updated>2022-01-04T09:51:07.791Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>For the daily milking, Farmer John’s N cows (1 ≤ N ≤ 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height.</p><p>Farmer John has made a list of Q (1 ≤ Q ≤ 180,000) potential groups of cows and their heights (1 ≤ height ≤ 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group.</p><p>每天,农夫 John 的 n(1\le n\le 5\times 10^4)<em>n</em>(1≤<em>n</em>≤5×104) 头牛总是按同一序列排队。</p><p>有一天, John 决定让一些牛们玩一场飞盘比赛。他准备找一群在队列中位置连续的牛来进行比赛。但是为了避免水平悬殊，牛的身高不应该相差太大。John 准备了 q(1\le q\le 1.8\times10^5)<em>q</em>(1≤<em>q</em>≤1.8×105) 个可能的牛的选择和所有牛的身高 h_i(1\le h_i\le 10^6,1\le i\le n)<em>h**i</em>(1≤<em>h**i</em>≤106,1≤<em>i</em>≤<em>n</em>)。他想知道每一组里面最高和最低的牛的身高差。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Line 1: Two space-separated integers, N and Q.</p><p>Lines 2..N+1: Line i+1 contains a single integer that is the height of cow i</p><p>Lines N+2..N+Q+1: Two integers A and B (1 ≤ A ≤ B ≤ N), representing the range of cows from A to B inclusive.</p><p>第一行两个数 n,q。</p><p>接下来 n行，每行一个数 h_i。</p><p>再接下来 q行，每行两个整数 a 和 b，表示询问第 a头牛到第 b头牛里的最高和最低的牛的身高差。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>Lines 1..Q: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range.</p><p>输出共 q行，对于每一组询问，输出每一组中最高和最低的牛的身高差。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>​    因为涉及到区间最值查询，可以用ST表实现（现在还没看懂），先贴上代码再说</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//lxy数组用于求最大值，hrb数组用于求最小值</span></span><br><span class="line"><span class="keyword">int</span> n,m,lxy[<span class="number">180010</span>][<span class="number">22</span>],hrb[<span class="number">180010</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ST</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="built_in">log2</span>(r - l + <span class="number">1</span>),x,y;</span><br><span class="line">    x = <span class="built_in">max</span>(lxy[l][s],lxy[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]);    <span class="comment">//区间最大</span></span><br><span class="line">    y = <span class="built_in">min</span>(hrb[l][s],hrb[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]);  <span class="comment">//区间最小</span></span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; lxy[i][<span class="number">0</span>];</span><br><span class="line">        hrb[i][<span class="number">0</span>] = lxy[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">21</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k + (<span class="number">1</span> &lt;&lt; i) &lt;= n + <span class="number">1</span>; ++k)&#123;</span><br><span class="line">            lxy[k][i] = <span class="built_in">max</span>(lxy[k][i - <span class="number">1</span>],lxy[k + (<span class="number">1</span> &lt;&lt;(i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">            hrb[k][i] = <span class="built_in">min</span>(hrb[k][i - <span class="number">1</span>],hrb[k + (<span class="number">1</span> &lt;&lt;(i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">ST</span>(l,r) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;For the daily milking, Farmer John’s N</summary>
      
    
    
    
    
    <category term="ST表" scheme="http://wangxu1905.github.io/tags/ST%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>7-9 重排链表 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/03/7-9%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/03/7-9%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%20(25%20%E5%88%86)/</id>
    <published>2022-01-03T13:26:35.327Z</published>
    <updated>2022-01-03T13:32:36.298Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定一个单链表 <em>L</em>1→<em>L</em>2→⋯→<em>L**n</em>−1→<em>L**n</em>，请编写程序将链表重新排列为 <em>L**n</em>→<em>L</em>1→<em>L**n</em>−1→<em>L</em>2→⋯。例如：给定<em>L</em>为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数<em>N</em> (≤105)。结点的地址是5位非负整数，NULL地址用−1表示。</p><p>接下来有<em>N</em>行，每行格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中<code>Address</code>是结点地址；<code>Data</code>是该结点保存的数据，为不超过105的正整数；<code>Next</code>是下一结点的地址。题目保证给出的链表上至少有两个结点。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00100</span> <span class="number">6</span></span><br><span class="line"><span class="number">00000</span> <span class="number">4</span> <span class="number">99999</span></span><br><span class="line"><span class="number">00100</span> <span class="number">1</span> <span class="number">12309</span></span><br><span class="line"><span class="number">68237</span> <span class="number">6</span> <span class="number">-1</span></span><br><span class="line"><span class="number">33218</span> <span class="number">3</span> <span class="number">00000</span></span><br><span class="line"><span class="number">99999</span> <span class="number">5</span> <span class="number">68237</span></span><br><span class="line"><span class="number">12309</span> <span class="number">2</span> <span class="number">33218</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">68237</span> <span class="number">6</span> <span class="number">00100</span></span><br><span class="line"><span class="number">00100</span> <span class="number">1</span> <span class="number">99999</span></span><br><span class="line"><span class="number">99999</span> <span class="number">5</span> <span class="number">12309</span></span><br><span class="line"><span class="number">12309</span> <span class="number">2</span> <span class="number">00000</span></span><br><span class="line"><span class="number">00000</span> <span class="number">4</span> <span class="number">33218</span></span><br><span class="line"><span class="number">33218</span> <span class="number">3</span> <span class="number">-1</span>结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> node_data[<span class="number">100001</span>],node_next[<span class="number">100001</span>];</span><br><span class="line">    <span class="keyword">int</span> head,n;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    cin &gt;&gt; head &gt;&gt; n;</span><br><span class="line">    <span class="comment">//初始化静态链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        node_data[a] = b;</span><br><span class="line">        node_next[a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历一遍链表，将各个结点的地址进行记录</span></span><br><span class="line">    <span class="keyword">int</span> h = head;</span><br><span class="line">    <span class="keyword">while</span>(h != <span class="number">-1</span>)&#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(h);</span><br><span class="line">        h = node_next[h];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是一个坑，对应一个测试点，因为会出现有多个结点为next都为-1，即不在该链表上的结点，所以要重新算一下长度</span></span><br><span class="line">    <span class="keyword">int</span> num = v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">address</span><span class="params">(num)</span></span>;</span><br><span class="line">    <span class="comment">//按题目要求，对链表结点进行重新排序</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>,high = num - <span class="number">1</span>,k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        address[k++] = v[high--];</span><br><span class="line">        address[k++] = v[low++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low == high) address[k] = v[low];</span><br><span class="line">    <span class="comment">//输出即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> add = address[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,add,node_data[add],address[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1\n&quot;</span>,address[num - <span class="number">1</span>],node_data[address[num - <span class="number">1</span>]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定一个单链表 &lt;em&gt;L&lt;/em&gt;1→&lt;em&gt;L&lt;/em&gt;2→⋯→&lt;em&gt;L**n&lt;/em&gt;−1→&lt;em&gt;L**n&lt;/em&gt;，请编写程序将链表重新排列为 &lt;em&gt;L**n&lt;/em&gt;→&lt;em&gt;L&lt;/em&gt;1→&lt;em&gt;L**n</summary>
      
    
    
    
    
    <category term="静态链表" scheme="http://wangxu1905.github.io/tags/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>7-6 最长对称子串 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/03/7-6%20%E6%9C%80%E9%95%BF%E5%AF%B9%E7%A7%B0%E5%AD%90%E4%B8%B2%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/03/7-6%20%E6%9C%80%E9%95%BF%E5%AF%B9%E7%A7%B0%E5%AD%90%E4%B8%B2%20(25%20%E5%88%86)/</id>
    <published>2022-01-03T12:28:33.225Z</published>
    <updated>2022-01-03T13:23:16.290Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定<code>Is PAT&amp;TAP symmetric?</code>，最长对称子串为<code>s PAT&amp;TAP s</code>，于是你应该输出11。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出长度不超过1000的非空字符串。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出最长对称子串的长度。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Is PAT&amp;TAP symmetric?</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>​    采用中心扩散法，主要是Manacher 算法一看就很复杂，不想学，中心扩散法的基本原理就是以每个元素作为中心，向左右两边扩散，如果无法继续扩散，此时和最大长度比较。</p><p>​    而字符串元素的个数分为奇数和偶数</p><ul><li>奇数：由中间一个字符作为中心进行扩散，对称轴为中间这个字符</li><li>偶数：由中间两个字符作为中心进行扩散，对称轴夹在两个字符中间</li></ul><p>力扣相关题：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5.最长回文子串</a></p><p>力扣视频链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/">最长回文子串</a></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(low &gt;= <span class="number">0</span> &amp;&amp; high &lt; s.<span class="built_in">size</span>() &amp;&amp; s[low] == s[high])&#123;</span><br><span class="line">        low--;</span><br><span class="line">        high++;</span><br><span class="line">    &#125;</span><br><span class="line">    maxlen = <span class="built_in">max</span>(maxlen,high - low - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="built_in">Judge</span>(i,i);</span><br><span class="line">        <span class="built_in">Judge</span>(i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxlen &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定&lt;code&gt;Is PAT&amp;amp;TAP symmetric?&lt;/code&gt;，最长对称子串为&lt;code&gt;s PAT&amp;amp;TAP s&lt;/code&gt;，于是你应该输出</summary>
      
    
    
    
    
    <category term="字符串" scheme="http://wangxu1905.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>C++ STL vector的find实现</title>
    <link href="http://wangxu1905.github.io/2022/01/03/C++%20STL%20vector%E7%9A%84find%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wangxu1905.github.io/2022/01/03/C++%20STL%20vector%E7%9A%84find%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-01-03T12:25:28.555Z</published>
    <updated>2022-01-03T12:27:54.456Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>不同于map（map有find方法），vector本身是没有find这一方法，其find是依靠algorithm来实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">        ve.<span class="built_in">push_back</span>(i);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(ve.<span class="built_in">begin</span>(), ve.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != ve.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;can not find&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;不同于map（map有find方法），vector本身是没有find这一方法，其find是依靠algorithm来实现的。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    
    <category term="C++函数" scheme="http://wangxu1905.github.io/tags/C-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++ sync_with_stdio和cin.tie(0),cout.tie(0)</title>
    <link href="http://wangxu1905.github.io/2022/01/03/C++%20sync_with_stdio%E5%92%8Ccin.tie(0),cout.tie(0)/"/>
    <id>http://wangxu1905.github.io/2022/01/03/C++%20sync_with_stdio%E5%92%8Ccin.tie(0),cout.tie(0)/</id>
    <published>2022-01-03T12:13:33.014Z</published>
    <updated>2022-01-03T12:19:56.699Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="1-ios-sync-with-stdio-false-的作用"><a href="#1-ios-sync-with-stdio-false-的作用" class="headerlink" title="1.ios::sync_with_stdio(false)的作用"></a>1.ios::sync_with_stdio(false)的作用</h3><p><strong>如果要关闭同步流ios::sync_with_stdio(false)来提高cin输入速度，就不能与getchar()混用，但是getchar()可以换成cin.get()！</strong></p><p>  作用是取消缓冲区同步，例如printf(),scanf()是C函数，而cin,cout是C++函数，这些函数需要用到各自的缓冲区，为了防止各自的缓冲区错位，C++默认将C函数和C++函数的缓冲区同步。 它的原理是使本该同步的输入输出流分开，就是让C的输入输出流和C++的输入输出流分开。</p><p>​        如果在此时用getchar(),读取的指挥室C语言的缓冲区，而不影响C++的缓冲区。所以应该采用cin.get()（效果等同于getchar(),但读取的是C++的缓冲区）</p><h3 id="2-tie"><a href="#2-tie" class="headerlink" title="2.tie"></a>2.tie</h3><p>tie是将两个<a href="https://so.csdn.net/so/search?q=stream">stream</a>绑定的函数，空参数的话返回当前的输出流指针。<br>在默认的情况下cin绑定的是cout，每次执行 &lt;&lt; 操作符的时候都要调用flush，这样会增加IO负担。可以通过tie(0)（0表示NULL）来解除cin与cout的绑定，进一步加快执行效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="3-ACM应用"><a href="#3-ACM应用" class="headerlink" title="3.ACM应用"></a>3.ACM应用</h3><p>在ACM里，经常出现数据集超大造成 cin TLE的情况。这时候大部分人认为这是cin的效率不及scanf的错，甚至还上升到C语言和C++语言的执行效率层面的无聊争论。其实像上文所说，这只是C++为了兼容而采取的保守措施。我们可以在IO之前将stdio解除绑定，这样做了之后要注意不要同时混用cout和printf之类。</p><p>在默认的情况下cin绑定的是cout，每次执行 &lt;&lt; 操作符的时候都要调用flush，这样会增加IO负担。可以通过tie(0)（0表示NULL）来解除cin与cout的绑定，进一步加快执行效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;1-ios-sync-with-stdio-false-的作用&quot;&gt;&lt;a href=&quot;#1-ios-sync-with-stdio-false-的作用&quot; class=&quot;headerlink&quot; title=&quot;1.ios</summary>
      
    
    
    
    
    <category term="C++函数" scheme="http://wangxu1905.github.io/tags/C-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++ 字符串补0,setw和setfill</title>
    <link href="http://wangxu1905.github.io/2022/01/03/C++%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A50,setw%E5%92%8Csetfill/"/>
    <id>http://wangxu1905.github.io/2022/01/03/C++%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A50,setw%E5%92%8Csetfill/</id>
    <published>2022-01-03T12:00:35.239Z</published>
    <updated>2022-01-03T12:05:19.975Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>为了实现字符串补0，所以使用set和setfill</p><ul><li>setw(5) ：设置字符串宽度，这里设置5字符</li><li>setfill(‘0’) ：设置填充字符，这里设置填充 0</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; s &lt;&lt; endl;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出： 00123</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;为了实现字符串补0，所以使用set和setfill&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;setw(5) ：设置字符串宽度，这里设置5字符&lt;/li&gt;
&lt;li&gt;setfill(‘0’) ：设置填充字符，这里设置填充 0&lt;/li&gt;
&lt;/ul</summary>
      
    
    
    
    
    <category term="C++函数" scheme="http://wangxu1905.github.io/tags/C-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>P1204 [USACO1.2]挤牛奶Milking Cows</title>
    <link href="http://wangxu1905.github.io/2022/01/02/P1204%20[USACO1.2]%E6%8C%A4%E7%89%9B%E5%A5%B6Milking%20Cows/"/>
    <id>http://wangxu1905.github.io/2022/01/02/P1204%20[USACO1.2]%E6%8C%A4%E7%89%9B%E5%A5%B6Milking%20Cows/</id>
    <published>2022-01-02T14:31:10.728Z</published>
    <updated>2022-01-02T14:46:58.824Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>三个农民每天清晨 5 点起床，然后去牛棚给三头牛挤奶。</p><p>第一个农民在 300 秒 (从 5 点开始计时) 给他的牛挤奶，一直到 1000 秒。第二个农民在 700 秒开始，在 1200 秒结束。第三个农民在 1500 秒开始，2100 秒结束。</p><p>期间最长的至少有一个农民在挤奶的连续时间为 900 秒 (从 300 秒到 1200秒)，而最长的无人挤奶的连续时间(从挤奶开始一直到挤奶结束)为 300 秒 (从 1200 秒到 1500 秒)。</p><hr><p>你的任务是编一个程序，读入一个有 n个农民挤 n 头牛的工作时间列表，计算以下两点(均以秒为单位):</p><p>最长至少有一人在挤奶的时间段。</p><p>最长的无人挤奶的时间段。（从有人挤奶开始算起）</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个正整数 n</p><p>接下来 n 行，每行两个非负整数 l,r,表示一个农民的开始时刻与结束时刻。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，两个整数，即题目所要求的两个答案。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">300</span> <span class="number">1000</span></span><br><span class="line"><span class="number">700</span> <span class="number">1200</span></span><br><span class="line"><span class="number">1500</span> <span class="number">2100</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">900</span> <span class="number">300</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>【数据范围】<br>对于 100% 的数据，1&lt;= n &lt;= 5000,0 &lt;= l &lt;= r &lt;=10e6</p><h2 id="算法思路（贪心）"><a href="#算法思路（贪心）" class="headerlink" title="算法思路（贪心）"></a>算法思路（贪心）</h2><p>​    如果将读入的区间视作线段，则题意转变为<strong>求至少有一条线段覆盖的最大区间和没有线段覆盖的区间</strong>。</p><p>​    假设读入数据如下： <img src="https://cdn.luogu.com.cn/upload/pic/46260.png" alt="fig"></p><p>首先按照4条线段的起点位置排序（具体原因后面解释）。将begin设置为第一条线段的起点，将end设置为第一条线段的终点。</p><p>然后从第二条线段开始判断。如果该线段的起点小于end，则说明这两条线段有重合部分，将end更新为max{end,该线段的终点位置}。如果该线段的起点大于end，则说明该线段及以后的线段再也不会与前面的线段产生任何重合部分（这也就是排序的作用），那么可以更新ans1和ans2的值：ans1更新为max{ans1,end-begin},ans2更新为max{ans2,该线段的起点位置-end}。具体参见图中第4条线段，ans1被更新为1200-0，ans2被更新为1400-1200。</p><p>程序已经基本成型，但要注意在输出答案前更新一遍ans1的值，这是为了避免所有线段均有重合部分而无法判断的情况。另外，ans1和ans2要初始化为0。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> begin,end;</span><br><span class="line">&#125;m[<span class="number">5001</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.begin &lt; b.begin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        cin &gt;&gt; m[i].begin &gt;&gt; m[i].end;</span><br><span class="line">    <span class="built_in">sort</span>(m + <span class="number">1</span>,m + N + <span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> begin = m[<span class="number">1</span>].begin,end = m[<span class="number">1</span>].end;</span><br><span class="line">    <span class="keyword">int</span> ans1 = <span class="number">0</span>,ans2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m[i].begin &lt;= end)&#123;</span><br><span class="line">            end = <span class="built_in">max</span>(end,m[i].end);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans1 = <span class="built_in">max</span>(ans1,end - begin);</span><br><span class="line">            ans2 = <span class="built_in">max</span>(ans2,m[i].begin - end);</span><br><span class="line">            begin = m[i].begin;</span><br><span class="line">            end = m[i].end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans1=<span class="built_in">max</span>(ans1,end-begin);</span><br><span class="line">    cout &lt;&lt; ans1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;三个农民每天清晨 5 点起床，然后去牛棚给三头牛挤奶。&lt;/p&gt;
&lt;p&gt;第一个</summary>
      
    
    
    
    
    <category term="贪心" scheme="http://wangxu1905.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>825. 适龄的朋友</title>
    <link href="http://wangxu1905.github.io/2021/12/27/825.%20%E9%80%82%E9%BE%84%E7%9A%84%E6%9C%8B%E5%8F%8B/"/>
    <id>http://wangxu1905.github.io/2021/12/27/825.%20%E9%80%82%E9%BE%84%E7%9A%84%E6%9C%8B%E5%8F%8B/</id>
    <published>2021-12-27T01:29:20.989Z</published>
    <updated>2022-01-02T14:42:51.313Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。</p><p>如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：</p><ul><li><p>age[y] &lt;= 0.5 * age[x] + 7</p></li><li><p>age[y] &gt; age[x]</p></li><li><p>age[y] &gt; 100 &amp;&amp; age[x] &lt; 100</p></li></ul><p>否则，x 将会向 y 发送一条好友请求。</p><p>注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。</p><p>返回在该社交媒体网站上产生的好友请求总数。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：ages = [16,16]<br>输出：2<br>解释：2 人互发好友请求。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：ages = [16,16]<br>输出：2<br>解释：2 人互发好友请求。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：ages = [20,30,100,110,120]<br>输出：3<br>解释：产生的好友请求为 110 -&gt; 100 ，120 -&gt; 110 ，120 -&gt; 100 。</p></blockquote><p><strong>提示：</strong></p><ul><li>n == ages.length</li><li>1 &lt;= n &lt;= 2 * 104</li><li>1 &lt;= ages[i] &lt;= 120</li></ul><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numFriendRequests</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; ages)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">121</span>)</span></span>;</span><br><span class="line">        <span class="comment">//计数排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> &amp;age: ages)</span><br><span class="line">            ++cnt[age];</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">pre</span><span class="params">(<span class="number">121</span>)</span></span>;</span><br><span class="line">        <span class="comment">//前缀和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">120</span>; ++i)</span><br><span class="line">            pre[i] = pre[i - <span class="number">1</span>] + cnt[i];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">15</span>; i &lt;= <span class="number">120</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> bound = <span class="number">0.5</span> * i + <span class="number">8</span>;</span><br><span class="line">                res += cnt[i] * (pre[i] - pre[bound - <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n + C)，其中 C 是用户年龄的范围，本题中 C = 120。计数排序需要 O(n) 的时间，计算前缀和以及统计答案需要 O(C)的时间。</p></li><li><p>空间复杂度：O(C)，即为计数排序以及前缀和数组需要使用的空间。</p></li></ul><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/solution/gua-ling-de-peng-you-by-leetcode-solutio-v7yk/">https://leetcode-cn.com/problems/friends-of-appropriate-ages/solution/gua-ling-de-peng-you-by-leetcode-solutio-v7yk/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。&lt;/p&gt;
&lt;p&gt;如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：&lt;/p&gt;
&lt;u</summary>
      
    
    
    
    
    <category term="力扣" scheme="http://wangxu1905.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="计数排序" scheme="http://wangxu1905.github.io/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
    <category term="前缀和" scheme="http://wangxu1905.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>7-3 顺序存储的二叉树的最近的公共祖先问题 (20 分)</title>
    <link href="http://wangxu1905.github.io/2021/11/05/7-3%20%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98%20(20%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/11/05/7-3%20%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98%20(20%20%E5%88%86)/</id>
    <published>2021-11-05T13:34:30.147Z</published>
    <updated>2021-11-05T13:36:32.436Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>设顺序存储的二叉树中有编号为<em>i</em>和<em>j</em>的两个结点，请设计算法求出它们最近的公共祖先结点的编号和值。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出正整数<em>n</em>（≤1000），即顺序存储的最大容量；第2行给出<em>n</em>个非负整数，其间以空格分隔。其中0代表二叉树中的空结点（如果第1个结点为0，则代表一棵空树）；第3行给出一对结点编号<em>i</em>和<em>j</em>。</p><p>题目保证输入正确对应一棵二叉树，且1≤<em>i</em>,<em>j</em>≤<em>n</em>。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>如果<em>i</em>或<em>j</em>对应的是空结点，则输出<code>ERROR: T[x] is NULL</code>，其中<code>x</code>是<em>i</em>或<em>j</em>中先发现错误的那个编号；否则在一行中输出编号为<em>i</em>和<em>j</em>的两个结点最近的公共祖先结点的编号和值，其间以1个空格分隔。</p><h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">1</span> <span class="number">10</span> <span class="number">0</span> <span class="number">7</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">9</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">11</span> <span class="number">4</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">9</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">12</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: T[<span class="number">12</span>] is <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> tree[N + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tree));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ; ++i)</span><br><span class="line">        cin &gt;&gt; tree[i];</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[a] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: T[%d] is NULL&quot;</span>,a);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[b] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: T[%d] is NULL&quot;</span>,b);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a == b)&#123;</span><br><span class="line">            cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; tree[a] &lt;&lt; endl;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//让序号大的找父亲</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt; b)   a /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span>        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;设顺序存储的二叉树中有编号为&lt;em&gt;i&lt;/em&gt;和&lt;em&gt;j&lt;/em&gt;的两个结点，请设计算法求出它们最近的公共祖先结点的编号和值。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;heade</summary>
      
    
    
    
    
    <category term="周练习" scheme="http://wangxu1905.github.io/tags/%E5%91%A8%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>08-图9 关键活动 (30 分)</title>
    <link href="http://wangxu1905.github.io/2021/11/03/08-%E5%9B%BE9%20%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/11/03/08-%E5%9B%BE9%20%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8%20(30%20%E5%88%86)/</id>
    <published>2021-11-03T13:33:48.744Z</published>
    <updated>2021-11-03T13:36:57.545Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。</p><p>比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和C程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如C程序设计和数据结构两门课，必须先学习前者。</p><p>但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务A依赖于子任务B，子任务B依赖于子任务C，子任务C又依赖于子任务A”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。</p><p>任务调度问题中，如果还给出了完成每个子任务需要的时间，则我们可以算出完成整个工程需要的最短时间。在这些子任务中，有些任务即使推迟几天完成，也不会影响全局的工期；但是有些任务必须准时完成，否则整个项目的工期就要因此延误，这种任务就叫“关键活动”。</p><p>请编写程序判定一个给定的工程项目的任务调度是否可行；如果该调度方案可行，则计算完成整个工程项目需要的最短时间，并输出所有的关键活动。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出两个正整数<em>N</em>(≤100)和<em>M</em>，其中<em>N</em>是任务交接点（即衔接相互依赖的两个子任务的节点，例如：若任务2要在任务1完成后才开始，则两任务之间必有一个交接点）的数量。交接点按1<del><em>N</em>编号，<em>M</em>是子任务的数量，依次编号为1</del><em>M</em>。随后<em>M</em>行，每行给出了3个正整数，分别是该任务开始和完成涉及的交接点编号以及该任务所需的时间，整数间用空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>如果任务调度不可行，则输出0；否则第1行输出完成整个工程项目需要的时间，第2行开始输出所有关键活动，每个关键活动占一行，按格式“V-&gt;W”输出，其中V和W为该任务开始和完成涉及的交接点编号。关键活动输出的顺序规则是：任务开始的交接点编号小者优先，起点编号相同时，与输入时任务的顺序相反。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">2</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line"><span class="number">2</span>-&gt;<span class="number">4</span></span><br><span class="line"><span class="number">4</span>-&gt;<span class="number">6</span></span><br><span class="line"><span class="number">6</span>-&gt;<span class="number">7</span>结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M,ECT;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> Indegree[<span class="number">101</span>],Outdegree[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> ETime[<span class="number">101</span>],LTime[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Late</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    <span class="comment">//出度为0的入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ;++i)&#123;</span><br><span class="line">        LTime[i] = ECT;</span><br><span class="line">        <span class="keyword">if</span>(Outdegree[i] == <span class="number">0</span>)  qu.<span class="built_in">push</span>(i); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mar[i][t] != F)&#123;</span><br><span class="line">                <span class="comment">//如果邻接点的最晚时间大于当前结点的最晚时间减去边的活动所需时间，则更新最晚时间</span></span><br><span class="line">                <span class="keyword">if</span>(--Outdegree[i] == <span class="number">0</span>)    qu.<span class="built_in">push</span>(i);</span><br><span class="line">                <span class="keyword">if</span>(LTime[t] - mar[i][t] &lt; LTime[i])</span><br><span class="line">                    LTime[i] = LTime[t] - mar[i][t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TopSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ;++i)</span><br><span class="line">        <span class="keyword">if</span>(Indegree[i] == <span class="number">0</span>)  qu.<span class="built_in">push</span>(i); </span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mar[t][i] != F)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--Indegree[i] == <span class="number">0</span>)    qu.<span class="built_in">push</span>(i);</span><br><span class="line">                <span class="keyword">if</span>(ETime[t] + mar[t][i] &gt; ETime[i])</span><br><span class="line">                    ETime[i] = ETime[t] + mar[t][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt != N)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ECT = *<span class="built_in">max_element</span>(ETime + <span class="number">1</span>,ETime + <span class="number">1</span> + N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">fill</span>(mar[<span class="number">0</span>],mar[<span class="number">0</span>] + <span class="number">101</span> * <span class="number">101</span>,F);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        mar[a][b] = c;</span><br><span class="line">        Indegree[b]++;</span><br><span class="line">        Outdegree[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">TopSort</span>())&#123;</span><br><span class="line">        cout &lt;&lt; ECT &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Late</span>();</span><br><span class="line">        <span class="comment">//因为起点编号相同时，与输入时任务的顺序相反，则j从N开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = N; j &gt;= <span class="number">1</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mar[i][j] != F &amp;&amp; ETime[i] + mar[i][j] == LTime[j])</span><br><span class="line">                    cout &lt;&lt; i &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。&lt;/p&gt;
&lt;p&gt;比如完成一个专业的所有课程学习和毕业</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>08-图8 How Long Does It Take (25 分)</title>
    <link href="http://wangxu1905.github.io/2021/11/03/08-%E5%9B%BE8%20How%20Long%20Does%20It%20Take%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/11/03/08-%E5%9B%BE8%20How%20Long%20Does%20It%20Take%20(25%20%E5%88%86)/</id>
    <published>2021-11-03T12:57:53.051Z</published>
    <updated>2021-11-03T13:12:01.336Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>Given the relations of all the activities of a project, you are supposed to find the earliest completion time of the project.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing two positive integers <em>N</em> (≤100), the number of activity check points (hence it is assumed that the check points are numbered from 0 to <em>N</em>−1), and <em>M</em>, the number of activities. Then <em>M</em> lines follow, each gives the description of an activity. For the <code>i</code>-th activity, three non-negative numbers are given: <code>S[i]</code>, <code>E[i]</code>, and <code>L[i]</code>, where <code>S[i]</code> is the index of the starting check point, <code>E[i]</code> of the ending check point, and <code>L[i]</code> the lasting time of the activity. The numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, if the scheduling is possible, print in a line its earliest completion time; or simply output “Impossible”.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> <span class="number">12</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">9</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">7</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span> <span class="number">8</span> <span class="number">2</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span> <span class="number">4</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> degree[<span class="number">101</span>],dis[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>,lasttime = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    <span class="comment">//把入度为0的结点入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ;++i)</span><br><span class="line">        <span class="keyword">if</span>(degree[i] == <span class="number">0</span>)  qu.<span class="built_in">push</span>(i); </span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="comment">//计算该点到下一个结点的所需要的时间，如果更大则更新</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mar[t][i] != F)&#123;</span><br><span class="line">                <span class="comment">//删除结点后，邻接点的入度-1，更新lasttime</span></span><br><span class="line">                <span class="keyword">if</span>(--degree[i] == <span class="number">0</span>)    qu.<span class="built_in">push</span>(i);</span><br><span class="line">                dis[i] = <span class="built_in">max</span>(dis[t] + mar[t][i],dis[i]);</span><br><span class="line">                lasttime = <span class="built_in">max</span>(lasttime,dis[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == N)    cout &lt;&lt; lasttime &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>            cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">fill</span>(mar[<span class="number">0</span>],mar[<span class="number">0</span>] + <span class="number">101</span> * <span class="number">101</span>,F);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        mar[a][b] = c;</span><br><span class="line">        degree[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TopSort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;Given the relations of all the activities of a project, you are supposed to find the earliest completion time of</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>08-图7 公路村村通 (30 分)</title>
    <link href="http://wangxu1905.github.io/2021/11/03/08-%E5%9B%BE7%20%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/11/03/08-%E5%9B%BE7%20%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A%20(30%20%E5%88%86)/</id>
    <published>2021-11-03T12:49:11.513Z</published>
    <updated>2021-11-03T12:57:10.282Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入数据包括城镇数目正整数<em>N</em>（≤1000）和候选道路数目<em>M</em>（≤3<em>N</em>）；随后的<em>M</em>行对应<em>M</em>条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到<em>N</em>编号。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">3</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 9999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> visited[N + <span class="number">1</span>],dis[N + <span class="number">1</span>],sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ;++i)</span><br><span class="line">        dis[i] = mar[s][i];</span><br><span class="line">    visited[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">-1</span>,cnt = F;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N ;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dis[j] &lt; cnt)&#123;</span><br><span class="line">                pos = j;</span><br><span class="line">                cnt = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">-1</span>)&#123;</span><br><span class="line">            flag = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += dis[pos];</span><br><span class="line">        visited[pos] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果到j的距离大于从集合中新加的点到j的距离，则更新路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N ; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dis[j] &gt; mar[pos][j])&#123;</span><br><span class="line">                dis[j] = mar[pos][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N ; ++j)</span><br><span class="line">            mar[i][j] = F;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ; ++i)</span><br><span class="line">        mar[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        mar[a][b] = mar[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">prime</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>07-图6 旅游规划 (25 分)</title>
    <link href="http://wangxu1905.github.io/2021/11/03/07-%E5%9B%BE6%20%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/11/03/07-%E5%9B%BE6%20%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92%20(25%20%E5%88%86)/</id>
    <published>2021-11-03T12:38:17.516Z</published>
    <updated>2021-11-03T12:48:44.032Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入数据的第1行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0~(<em>N</em>−1)；<em>M</em>是高速公路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。随后的<em>M</em>行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">20</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">30</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">4</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">20</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">20</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">40</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 9999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M,S,D;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> price[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[N],visited[N],pay[N];</span><br><span class="line">    <span class="comment">//初始化距离数组和价格数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; ++i)&#123;</span><br><span class="line">        dis[i] = mar[S][i];</span><br><span class="line">        pay[i] = price[S][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    visited[S] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">-1</span>,cnt = F;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; N ; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dis[j] &lt; cnt)&#123;</span><br><span class="line">                pos = j;</span><br><span class="line">                cnt = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">-1</span>)   <span class="keyword">break</span>;</span><br><span class="line">        visited[pos] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j])&#123;</span><br><span class="line">                <span class="comment">//如果距离能更短，直接更新距离和价格，如果距离相同，则比较价格，价格更小则更新价格</span></span><br><span class="line">                <span class="keyword">if</span>(dis[j] &gt; dis[pos] + mar[pos][j])&#123;</span><br><span class="line">                    dis[j] = dis[pos] + mar[pos][j];</span><br><span class="line">                    pay[j] = pay[pos] + price[pos][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dis[j] ==  dis[pos] + mar[pos][j] &amp;&amp; pay[j] &gt; pay[pos] + price[pos][j])</span><br><span class="line">                    pay[j] = pay[pos] + price[pos][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dis[D] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pay[D] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; D;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; N ; ++j)</span><br><span class="line">            mar[i][j] = price[i][j] = F;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; ++i)</span><br><span class="line">        mar[i][i] = price[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        mar[a][b] = mar[b][a] = c;</span><br><span class="line">        price[a][b] = price[b][a] = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>07-图5 Saving James Bond - Hard Version (30 分)</title>
    <link href="http://wangxu1905.github.io/2021/11/03/07-%E5%9B%BE5%20Saving%20James%20Bond%20-%20Hard%20Version%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/11/03/07-%E5%9B%BE5%20Saving%20James%20Bond%20-%20Hard%20Version%20(30%20%E5%88%86)/</id>
    <published>2021-11-03T12:26:27.953Z</published>
    <updated>2021-11-03T12:37:51.788Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).</p><p>Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him a shortest path to reach one of the banks. The length of a path is the number of jumps that James has to make.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing two positive integers <em>N</em> (≤100), the number of crocodiles, and <em>D</em>, the maximum distance that James could jump. Then <em>N</em> lines follow, each containing the (<em>x</em>,<em>y</em>) location of a crocodile. Note that no two crocodiles are staying at the same position.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, if James can escape, output in one line the minimum number of jumps he must make. Then starting from the next line, output the position (<em>x</em>,<em>y</em>) of each crocodile on the path, each pair in one line, from the island to the bank. If it is impossible for James to escape that way, simply give him 0 as the number of jumps. If there are many shortest paths, just output the one with the minimum first jump, which is guaranteed to be unique.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span> <span class="number">15</span></span><br><span class="line"><span class="number">10</span> <span class="number">-21</span></span><br><span class="line"><span class="number">10</span> <span class="number">21</span></span><br><span class="line"><span class="number">-40</span> <span class="number">10</span></span><br><span class="line"><span class="number">30</span> <span class="number">-50</span></span><br><span class="line"><span class="number">20</span> <span class="number">40</span></span><br><span class="line"><span class="number">35</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">-10</span></span><br><span class="line"><span class="number">-25</span> <span class="number">22</span></span><br><span class="line"><span class="number">40</span> <span class="number">-40</span></span><br><span class="line"><span class="number">-30</span> <span class="number">30</span></span><br><span class="line"><span class="number">-10</span> <span class="number">22</span></span><br><span class="line"><span class="number">0</span> <span class="number">11</span></span><br><span class="line"><span class="number">25</span> <span class="number">21</span></span><br><span class="line"><span class="number">25</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">35</span></span><br><span class="line"><span class="number">-30</span> <span class="number">10</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">11</span></span><br><span class="line"><span class="number">10</span> <span class="number">21</span></span><br><span class="line"><span class="number">10</span> <span class="number">35</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="number">-12</span> <span class="number">12</span></span><br><span class="line"><span class="number">12</span> <span class="number">12</span></span><br><span class="line"><span class="number">-12</span> <span class="number">-12</span></span><br><span class="line"><span class="number">12</span> <span class="number">-12</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> N,D,answer;</span><br><span class="line">Node cro[<span class="number">102</span>];</span><br><span class="line"><span class="keyword">int</span> visited[<span class="number">102</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.d &lt; b.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstJump</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1.0</span> * cro[pos].d &lt;= <span class="built_in">pow</span>(D + <span class="number">15.0</span> / <span class="number">2</span>,<span class="number">2.0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Jump</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pow</span>(cro[cur].x - cro[next].x,<span class="number">2.0</span>) + <span class="built_in">pow</span>(cro[cur].y - cro[next].y,<span class="number">2.0</span>) &lt;= D * D)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsSafe</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cro[pos].x-D&lt;=<span class="number">-50</span>||cro[pos].y-D&lt;=<span class="number">-50</span>||cro[pos].x+D&gt;=<span class="number">50</span>||cro[pos].y+D&gt;=<span class="number">50</span>)</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printpath</span><span class="params">(<span class="keyword">int</span> answer)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(answer == <span class="number">-1</span>)    <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printpath</span>(cro[answer].pre);</span><br><span class="line">    cout &lt;&lt; cro[answer].x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; cro[answer].y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    answer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">1</span>,last = <span class="number">-1</span>,tail = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="comment">//将第一跳就能跳到的结点入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">FirstJump</span>(i))&#123;</span><br><span class="line">            qu.<span class="built_in">push</span>(i);</span><br><span class="line">            last = i;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果能第一跳能到的最远的结点能直接到岸边，则直接输出1</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsSafe</span>(last))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参考六度空间，通过tail和last记录层数</span></span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; <span class="built_in">Jump</span>(pos,i))&#123;</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                qu.<span class="built_in">push</span>(i);</span><br><span class="line">                tail = i;</span><br><span class="line">                cro[i].pre = pos;</span><br><span class="line">                answer = <span class="built_in">IsSafe</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(answer) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(answer)  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos == last)&#123;</span><br><span class="line">            ++step;</span><br><span class="line">            last = tail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//首先如果能顺利到岸，当前节点需要加上自身所在的一层以及最后跳到岸边的一次</span></span><br><span class="line">    <span class="keyword">if</span>(answer)&#123;</span><br><span class="line">        cout &lt;&lt; step + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">printpath</span>(answer);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; D;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; cro[i].x &gt;&gt; cro[i].y;</span><br><span class="line">        cro[i].d = cro[i].x * cro[i].x + cro[i].y * cro[i].y;</span><br><span class="line">        cro[i].pre = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对距离进行排序，先从距离最近的跳</span></span><br><span class="line">    <span class="built_in">sort</span>(cro + <span class="number">1</span>,cro + N + <span class="number">1</span>,cmp);</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most fa</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
</feed>
