<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moon</title>
  
  
  <link href="http://wangxu1905.github.io/atom.xml" rel="self"/>
  
  <link href="http://wangxu1905.github.io/"/>
  <updated>2022-01-17T03:14:36.784Z</updated>
  <id>http://wangxu1905.github.io/</id>
  
  <author>
    <name>Moon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【2022寒假萌新训练-3】7-7 点赞狂魔</title>
    <link href="http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-7%20%E7%82%B9%E8%B5%9E%E7%8B%82%E9%AD%94/"/>
    <id>http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-7%20%E7%82%B9%E8%B5%9E%E7%8B%82%E9%AD%94/</id>
    <published>2022-01-17T03:12:17.000Z</published>
    <updated>2022-01-17T03:14:36.784Z</updated>
    
    <content type="html"><![CDATA[<p>微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。然而有这么一种人，他们会通过给自己看到的一切内容点赞来狂刷存在感，这种人就被称为“点赞狂魔”。他们点赞的标签非常分散，无法体现出明显的特性。本题就要求你写个程序，通过统计每个人点赞的不同标签的数量，找出前3名点赞狂魔。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤100），是待统计的用户数。随后<em>N</em>行，每行列出一位用户的点赞标签。格式为“<code>Name</code> <em>K</em> <em>F</em><del>1</del>⋯<em>F</em><del>K</del><em>”，其中<code>Name</code>是不超过8个英文小写字母的非空用户名，1≤</em>K<em>≤1000，</em>F*<del>i</del><em>（</em>i*=1,⋯,<em>K</em>）是特性标签的编号，我们将所有特性标签从 1 到 10^7^ 编号。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>统计每个人点赞的不同标签的数量，找出数量最大的前3名，在一行中顺序输出他们的用户名,其间以1个空格分隔,且行末不得有多余空格。如果有并列，则输出标签出现次数平均值最小的那个，题目保证这样的用户没有并列。若不足3人，则用<code>-</code>补齐缺失，例如<code>mike jenny -</code>就表示只有2人。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">bob 11 101 102 103 104 105 106 107 108 108 107 107</span><br><span class="line">peter 8 1 2 3 4 3 2 5 1</span><br><span class="line">chris 12 1 2 3 4 5 6 7 8 9 1 2 3</span><br><span class="line">john 10 8 7 6 5 4 3 2 1 7 5</span><br><span class="line">jack 9 6 7 8 9 10 11 12 13 14</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jack chris john</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    根据题意，要名字，不同标签的数量以及标签出现次数平均值，存储的元素挺多，可以采用结构体。</p><ul><li>名字直接读取</li><li>不同标签的数量可以利用set不存储重复元素的特性得到</li><li>标签出现的平均次数可以等价于，如果存在并列，则他们不同标签的数量num一定是相同的，平均次数为k / num,此时谁的k值小，谁的平均次数就小,所以只需要比较k值就好</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="comment">//num为不同标签的数量，cnt记录总次数，其实就是k</span></span><br><span class="line">    <span class="keyword">int</span> num, cnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.num != b.num)</span><br><span class="line">        <span class="keyword">return</span> a.num &gt; b.num;</span><br><span class="line">    <span class="keyword">return</span> a.cnt &lt; b.cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    Node node[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; node[i].name;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="comment">//利用set不存储重复元素的特性得到不同标签的数量</span></span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            s.<span class="built_in">insert</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        node[i].num = s.<span class="built_in">size</span>();</span><br><span class="line">        node[i].cnt = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(node, node + n, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n) cout &lt;&lt; node[i].name;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。然而有这么一种人，他们会通过给自己看到的一切内容点赞来狂刷存在感，这种人就被称为“点赞狂魔”。他们点赞的标签非常分散，无法体现出明显的特</summary>
      
    
    
    
    <category term="2022寒假萌新程序设计训练" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/"/>
    
    <category term="2022寒假萌新训练-3" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3/"/>
    
    
    <category term="STL,sort" scheme="http://wangxu1905.github.io/tags/STL-sort/"/>
    
  </entry>
  
  <entry>
    <title>【2022寒假萌新训练-3】7-6 树种统计</title>
    <link href="http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-6%20%E6%A0%91%E7%A7%8D%E7%BB%9F%E8%AE%A1/"/>
    <id>http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-6%20%E6%A0%91%E7%A7%8D%E7%BB%9F%E8%AE%A1/</id>
    <published>2022-01-17T02:55:11.000Z</published>
    <updated>2022-01-17T03:08:25.341Z</updated>
    
    <content type="html"><![CDATA[<p>随着卫星成像技术的应用，自然资源研究机构可以识别每一棵树的种类。请编写程序帮助研究人员统计每种树的数量，计算每种树占总数的百分比。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入首先给出正整数N（≤10^5^），随后N行，每行给出卫星观测到的一棵树的种类名称。种类名称由不超过30个英文字母和空格组成（大小写不区分）。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按字典序递增输出各种树的种类名称及其所占总数的百分比，其间以空格分隔，保留小数点后4位。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">29</span><br><span class="line">Red Alder</span><br><span class="line">Ash</span><br><span class="line">Aspen</span><br><span class="line">Basswood</span><br><span class="line">Ash</span><br><span class="line">Beech</span><br><span class="line">Yellow Birch</span><br><span class="line">Ash</span><br><span class="line">Cherry</span><br><span class="line">Cottonwood</span><br><span class="line">Ash</span><br><span class="line">Cypress</span><br><span class="line">Red Elm</span><br><span class="line">Gum</span><br><span class="line">Hackberry</span><br><span class="line">White Oak</span><br><span class="line">Hickory</span><br><span class="line">Pecan</span><br><span class="line">Hard Maple</span><br><span class="line">White Oak</span><br><span class="line">Soft Maple</span><br><span class="line">Red Oak</span><br><span class="line">Red Oak</span><br><span class="line">White Oak</span><br><span class="line">Poplan</span><br><span class="line">Sassafras</span><br><span class="line">Sycamore</span><br><span class="line">Black Walnut</span><br><span class="line">Willow</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Ash 13.7931%</span><br><span class="line">Aspen 3.4483%</span><br><span class="line">Basswood 3.4483%</span><br><span class="line">Beech 3.4483%</span><br><span class="line">Black Walnut 3.4483%</span><br><span class="line">Cherry 3.4483%</span><br><span class="line">Cottonwood 3.4483%</span><br><span class="line">Cypress 3.4483%</span><br><span class="line">Gum 3.4483%</span><br><span class="line">Hackberry 3.4483%</span><br><span class="line">Hard Maple 3.4483%</span><br><span class="line">Hickory 3.4483%</span><br><span class="line">Pecan 3.4483%</span><br><span class="line">Poplan 3.4483%</span><br><span class="line">Red Alder 3.4483%</span><br><span class="line">Red Elm 3.4483%</span><br><span class="line">Red Oak 6.8966%</span><br><span class="line">Sassafras 3.4483%</span><br><span class="line">Soft Maple 3.4483%</span><br><span class="line">Sycamore 3.4483%</span><br><span class="line">White Oak 10.3448%</span><br><span class="line">Willow 3.4483%</span><br><span class="line">Yellow Birch 3.4483%</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    根据题意，统计树的种类和它的占比，采用map存储，根据map的自动排序，string直接是按照字典序进行排序，我们只需要遍历输出即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    map&lt;string, <span class="keyword">int</span>&gt; book;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="built_in">getline</span>(cin, str);</span><br><span class="line">        book[str]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = book.<span class="built_in">begin</span>(); it != book.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %.4f%%\n&quot;</span>, it -&gt; first.<span class="built_in">c_str</span>(), (<span class="keyword">float</span>)it -&gt; second / n * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;随着卫星成像技术的应用，自然资源研究机构可以识别每一棵树的种类。请编写程序帮助研究人员统计每种树的数量，计算每种树占总数的百分比。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式:&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="2022寒假萌新程序设计训练" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/"/>
    
    <category term="2022寒假萌新训练-3" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3/"/>
    
    
    <category term="map容器" scheme="http://wangxu1905.github.io/tags/map%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【2022寒假萌新训练-3】7-5 点赞</title>
    <link href="http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-5%20%E7%82%B9%E8%B5%9E/"/>
    <id>http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-5%20%E7%82%B9%E8%B5%9E/</id>
    <published>2022-01-17T02:36:40.000Z</published>
    <updated>2022-01-17T03:07:43.888Z</updated>
    
    <content type="html"><![CDATA[<p>微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。本题就要求你写个程序，通过统计一个人点赞的纪录，分析这个人的特性。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤1000），是该用户点赞的博文数量。随后<em>N</em>行，每行给出一篇被其点赞的博文的特性描述，格式为“<em>K</em> <em>F</em><del>1</del>⋯<em>F</em><del>K</del><em>”，其中1≤</em>K<em>≤10，</em>F*<del>i</del>（<em>i</em>=1,⋯,*K）是特性标签的编号，我们将所有特性标签从1到1000编号。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>统计所有被点赞的博文中最常出现的那个特性标签，在一行中输出它的编号和出现次数，数字间隔1个空格。如果有并列，则输出编号最大的那个。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3 889 233 2</span><br><span class="line">5 100 3 233 2 73</span><br><span class="line">4 3 73 889 2</span><br><span class="line">2 233 123</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">233 3</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    和7-4 天梯赛的善良的一样，需要记录两个值，一个值为特征描述值，一个值为出现的次数，可以采用map存储。</p><p>​    最后输出出现次数最大的特征值中编号最大的，可以采用map反向遍历（从大的特征值开始遍历），max1记录特征值，max2记录出现的次数，只要找到比max2大的，就更新max1和max2，最后输出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k, t;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            m[t]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//max1记录特征值，max2记录出现的次数</span></span><br><span class="line">    <span class="keyword">int</span> max1 = <span class="number">0</span>, max2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m.<span class="built_in">rbegin</span>(); it != m.<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(it -&gt; second &gt; max2) &#123;</span><br><span class="line">            max1 = it -&gt; first;</span><br><span class="line">            max2 = it -&gt; second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; max1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; max2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。本题就要求你写个程序，通过统计一个人点赞的纪录，分析这个人的特性。&lt;/p&gt;
&lt;h3 id=&quot;输入格式：&quot;&gt;&lt;a href=&quot;#输入格式：</summary>
      
    
    
    
    <category term="2022寒假萌新程序设计训练" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/"/>
    
    <category term="2022寒假萌新训练-3" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3/"/>
    
    
    <category term="map容器" scheme="http://wangxu1905.github.io/tags/map%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【2022寒假萌新训练-3】7-4 天梯赛的善良</title>
    <link href="http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-4%20%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%9A%84%E5%96%84%E8%89%AF/"/>
    <id>http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-4%20%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%9A%84%E5%96%84%E8%89%AF/</id>
    <published>2022-01-17T02:26:25.000Z</published>
    <updated>2022-01-17T03:06:15.752Z</updated>
    
    <content type="html"><![CDATA[<p>天梯赛是个善良的比赛。善良的命题组希望将题目难度控制在一个范围内，使得每个参赛的学生都有能做出来的题目，并且最厉害的学生也要非常努力才有可能得到高分。</p><p>于是命题组首先将编程能力划分成了 10^6^ 个等级（太疯狂了，这是假的），然后调查了每个参赛学生的编程能力。现在请你写个程序找出所有参赛学生的最小和最大能力值，给命题组作为出题的参考。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出一个正整数 <em>N</em>（≤2×10^4^），即参赛学生的总数。随后一行给出 <em>N</em> 个不超过 10^6^ 的正整数，是参赛学生的能力值。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>第一行输出所有参赛学生的最小能力值，以及具有这个能力值的学生人数。第二行输出所有参赛学生的最大能力值，以及具有这个能力值的学生人数。同行数字间以 1 个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">86 75 233 888 666 75 886 888 75 666</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">75 3</span><br><span class="line">888 2</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    根据题意，要找出最小和最大能力值已经相应的人数，要记录的是能力值和人数，可以采用map存储，利用map的自动排序，map的第一个元素就是最小能力值和人数，最后一个元素就是最大能力值和人数。</p><p>​    rbegin()返回的是一个反向迭代器，指向的是map的最后一个元素。</p><p>​    不采用end()是因为end()返回的是map最后一个元素<strong>之后</strong>的地址。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        m[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">begin</span>() -&gt; first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m.<span class="built_in">begin</span>() -&gt; second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">rbegin</span>() -&gt; first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m.<span class="built_in">rbegin</span>() -&gt; second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;天梯赛是个善良的比赛。善良的命题组希望将题目难度控制在一个范围内，使得每个参赛的学生都有能做出来的题目，并且最厉害的学生也要非常努力才有可能得到高分。&lt;/p&gt;
&lt;p&gt;于是命题组首先将编程能力划分成了 10^6^ 个等级（太疯狂了，这是假的），然后调查了每个参赛学生的编程能力</summary>
      
    
    
    
    <category term="2022寒假萌新程序设计训练" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/"/>
    
    <category term="2022寒假萌新训练-3" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3/"/>
    
    
    <category term="map容器" scheme="http://wangxu1905.github.io/tags/map%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【2022寒假萌新训练-3】7-3 素数对猜想</title>
    <link href="http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-3%20%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"/>
    <id>http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-3%20%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/</id>
    <published>2022-01-17T02:11:25.000Z</published>
    <updated>2022-01-17T03:03:26.729Z</updated>
    
    <content type="html"><![CDATA[<p>让我们定义<em>d<del>n</del><em>为：</em>d<del>n</del></em>=<em>p<del>n+1</del><em>−</em>p<del>n</del><em>，其中</em>p<del>i</del><em>是第</em>i</em>个素数。显然有<em>d<del>1</del></em>=1，且对于n&gt;1有*d<del>n</del>*是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p><p>现给定任意正整数<code>N</code>(&lt;10^5^)，请计算不超过<code>N</code>的满足猜想的素数对的个数。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行给出正整数<code>N</code>。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出不超过<code>N</code>的满足猜想的素数对的个数。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    套用判断素数的模板，然后遍历从2~n，判断的是数字i和数字i + 2是否同时为素数即可，同时为素数则ans++</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsPrime</span>(i) &amp;&amp; <span class="built_in">IsPrime</span>(i + <span class="number">2</span>))</span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;让我们定义&lt;em&gt;d&lt;del&gt;n&lt;/del&gt;&lt;em&gt;为：&lt;/em&gt;d&lt;del&gt;n&lt;/del&gt;&lt;/em&gt;=&lt;em&gt;p&lt;del&gt;n+1&lt;/del&gt;&lt;em&gt;−&lt;/em&gt;p&lt;del&gt;n&lt;/del&gt;&lt;em&gt;，其中&lt;/em&gt;p&lt;del&gt;i&lt;/del&gt;&lt;em&gt;是第&lt;/em&gt;i&lt;/em&gt;个</summary>
      
    
    
    
    <category term="2022寒假萌新程序设计训练" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/"/>
    
    <category term="2022寒假萌新训练-3" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3/"/>
    
    
    <category term="素数" scheme="http://wangxu1905.github.io/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【2022寒假萌新训练-3】7-2 判断素数</title>
    <link href="http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-2%20%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0/"/>
    <id>http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-2%20%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0/</id>
    <published>2022-01-17T01:46:25.000Z</published>
    <updated>2022-01-17T02:59:07.202Z</updated>
    
    <content type="html"><![CDATA[<p>本题的目标很简单，就是判断一个给定的正整数是否素数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<code>N</code>（≤ 10），随后<code>N</code>行，每行给出一个小于231的需要判断的正整数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个需要判断的正整数，如果它是素数，则在一行中输出<code>Yes</code>，否则输出<code>No</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">11</span><br><span class="line">111</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    根据判断素数的模板直接套就可以,为了提高运行效率，为了防止i*i超出int范围，可以采用i &lt;= sqrt(n)。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsPrime</span>(t))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本题的目标很简单，就是判断一个给定的正整数是否素数。&lt;/p&gt;
&lt;h3 id=&quot;输入格式：&quot;&gt;&lt;a href=&quot;#输入格式：&quot; class=&quot;headerlink&quot; title=&quot;输入格式：&quot;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;p&gt;输入在第一行给出一个正整数&lt;code&gt;N&lt;/co</summary>
      
    
    
    
    <category term="2022寒假萌新程序设计训练" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/"/>
    
    <category term="2022寒假萌新训练-3" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3/"/>
    
    
    <category term="素数" scheme="http://wangxu1905.github.io/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【2022寒假萌新训练-3】7-1 最大公因数与最小公倍数</title>
    <link href="http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-1%20%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
    <id>http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-1%20%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</id>
    <published>2022-01-17T01:23:26.000Z</published>
    <updated>2022-01-17T02:54:05.612Z</updated>
    
    <content type="html"><![CDATA[<p>求两个正整数 <em>a</em>,<em>b</em> 的最大公因数与最小公倍数。</p><p>两个数的最大公因数指的是 <em>a</em>,<em>b</em> 共有的约数中最大的一个。</p><p>两个数的最小公倍数指的是 <em>a</em>,<em>b</em> 共有的倍数中最小的一个。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>在一行中给出两个数字 <em>a</em>,<em>b</em>  (1&lt;=<em>a</em>,<em>b</em>&lt;=1,000,000,000)</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中以空格分隔输出 <em>a</em>,<em>b</em> 的最大公因数与最小公倍数。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 9</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 18</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    根据欧几里德算法或者C++的函数库求出a和b的最大公因数.</p><p>​    最小公倍数则是a*b除以它们的最大公倍数,为了防止a * b计算时由于结果过大而溢出，所以可以先让a除以最大公倍数再乘b</p><p>​    欧几里德算法：设a,b均为正整数，a,b的最大公约数等于b,a%b的最大公约数即Gcd(a,b) = Gcd(b,a % b)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">Gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a % b == <span class="number">0</span> ? b : <span class="built_in">Gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, <span class="built_in">Gcd</span>(a, b), a / <span class="built_in">Gcd</span>(a, b) * b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a, b, gcd;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    gcd = __gcd(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, gcd, a / gcd * b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;求两个正整数 &lt;em&gt;a&lt;/em&gt;,&lt;em&gt;b&lt;/em&gt; 的最大公因数与最小公倍数。&lt;/p&gt;
&lt;p&gt;两个数的最大公因数指的是 &lt;em&gt;a&lt;/em&gt;,&lt;em&gt;b&lt;/em&gt; 共有的约数中最大的一个。&lt;/p&gt;
&lt;p&gt;两个数的最小公倍数指的是 &lt;em&gt;a&lt;/em&gt;,&lt;em&gt;b&lt;/e</summary>
      
    
    
    
    <category term="2022寒假萌新程序设计训练" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/"/>
    
    <category term="2022寒假萌新训练-3" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3/"/>
    
    
    <category term="欧几里德算法" scheme="http://wangxu1905.github.io/tags/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>7-9 完全二叉树的层序遍历 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/14/7-9%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/14/7-9%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20(25%20%E5%88%86)/</id>
    <published>2022-01-14T13:31:42.773Z</published>
    <updated>2022-01-14T13:33:21.737Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是<strong>完美二叉树</strong>。对于深度为 <em>D</em> 的，有 <em>N</em> 个结点的二叉树，若其结点对应于相同深度完美二叉树的层序遍历的前 <em>N</em> 个结点，这样的树就是<strong>完全二叉树</strong>。</p><p>给定一棵完全二叉树的后序遍历，请你给出这棵树的层序遍历结果。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出正整数 <em>N</em>（≤30），即树中结点个数。第二行给出后序遍历序列，为 <em>N</em> 个不超过 100 的正整数。同一行中所有数字都以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出该树的层序遍历序列。所有数字都以 1 个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">91</span> <span class="number">71</span> <span class="number">2</span> <span class="number">34</span> <span class="number">10</span> <span class="number">15</span> <span class="number">55</span> <span class="number">18</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span> <span class="number">34</span> <span class="number">55</span> <span class="number">71</span> <span class="number">2</span> <span class="number">10</span> <span class="number">15</span> <span class="number">91</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    用数组存树，然后根据后序遍历类推出后序建树</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,tree[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">BuildTree</span>(pos * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">BuildTree</span>(pos * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    tree[pos] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">BuildTree</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; tree[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; tree[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是&lt;strong&gt;完美二叉树&lt;/strong&gt;。对于深度为 &lt;em&gt;D&lt;/em&gt; 的，有 &lt;em&gt;N&lt;/em&gt; 个结点的二叉树，若其结点对应于相同深度完美二叉树的层</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-8 公路村村通 (30 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/14/7-8%20%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/14/7-8%20%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A%20(30%20%E5%88%86)/</id>
    <published>2022-01-14T02:57:11.189Z</published>
    <updated>2022-01-14T03:08:41.691Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入数据包括城镇数目正整数<em>N</em>（≤1000）和候选道路数目<em>M</em>（≤3<em>N</em>）；随后的<em>M</em>行对应<em>M</em>条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到<em>N</em>编号。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    最小生成树的两种方法：Prime算法和Kruskal算法。Prime算法写的挺多的了，就不说了。主要是Kruskal算法。</p><p>​    Kruskal算法主要是先按权重最小到大排序，依次选最小的，但不能出现环，如何判断是否是环就成了关键问题。</p><p>​    判断是环的方法就可以等价于新加入的边的两个点是否在同一个集合上，如果在，则会形成环，所以使用并查集。</p><p>​    如果不在同一个集合上，则两个点的集合合并，结果加上该边的权重，如果最后公路都能通，则最后只有一个集合，集合的结点数为n,所以只要要判断加入了几次边就可以了</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Prime</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,mar[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prime</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[n + <span class="number">1</span>],visited[n + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;,res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        dis[i] = mar[s][i];</span><br><span class="line">    visited[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = inf,pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dis[j] &lt; cnt)&#123;</span><br><span class="line">                pos = j;</span><br><span class="line">                cnt = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">-1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += dis[pos];</span><br><span class="line">        visited[pos] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dis[j] &gt; mar[pos][j])</span><br><span class="line">                dis[j] = mar[pos][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(mar,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mar));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        mar[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        mar[a][b] = mar[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Prime</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kruskal算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m,fa[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x)  <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">Find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.z &lt; b.z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    Node node[m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        cin &gt;&gt; node[i].x &gt;&gt; node[i].y &gt;&gt; node[i].z;</span><br><span class="line">    <span class="built_in">sort</span>(node,node + m,cmp);</span><br><span class="line">    <span class="built_in">Init</span>(n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> fx = <span class="built_in">Find</span>(node[i].x),fy = <span class="built_in">Find</span>(node[i].y);</span><br><span class="line">        <span class="keyword">if</span>(fx != fy)&#123;</span><br><span class="line">            ans += node[i].z;</span><br><span class="line">            fa[fx] = fy;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == n)    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>            cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>P1002 [NOIP2002 普及组] 过河卒</title>
    <link href="http://wangxu1905.github.io/2022/01/12/P1002%20[NOIP2002%20%E6%99%AE%E5%8F%8A%E7%BB%84]%20%E8%BF%87%E6%B2%B3%E5%8D%92/"/>
    <id>http://wangxu1905.github.io/2022/01/12/P1002%20[NOIP2002%20%E6%99%AE%E5%8F%8A%E7%BB%84]%20%E8%BF%87%E6%B2%B3%E5%8D%92/</id>
    <published>2022-01-12T14:10:29.449Z</published>
    <updated>2022-01-12T14:17:00.666Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>棋盘上 A 点有一个过河卒，需要走到目标 B 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 C 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。</p><p>棋盘用坐标表示，A 点 (0, 0)、B 点 (n, m)，同样马的位置坐标是需要给出的。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/vg6k477j.png" alt="img"></p><p>现在要求你计算出卒从 A 点能够到达 B 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行四个正整数，分别表示 B 点坐标和马的坐标。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示所有的路径条数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>对于 100% 的数据，1≤n,m≤20，0 ≤ 马的坐标 ≤20。</p><p><strong>【题目来源】</strong></p><p>NOIP 2002 普及组第四题</p><h2 id="算法思路（动态规划）"><a href="#算法思路（动态规划）" class="headerlink" title="算法思路（动态规划）"></a>算法思路（动态规划）</h2><p>​    为了判断方便点，我们可以将左右下标都先+2，然后通过另一个数组确定马能到达的位置（不能走），如果不能走的话dp[j] = 0，如果能走的话，dp[j] += dp[j - 1];</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> bx,by,mx,my;</span><br><span class="line">    cin &gt;&gt; bx &gt;&gt; by &gt;&gt; mx &gt;&gt; my;</span><br><span class="line">    bx +=<span class="number">2</span>;by += <span class="number">2</span>;mx += <span class="number">2</span>;my += <span class="number">2</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    s[mx][my] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">8</span>; ++i)</span><br><span class="line">        s[mx + dx[i]][my + dy[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= bx; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= by; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j])&#123;</span><br><span class="line">                dp[j] = <span class="number">0</span>;<span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] +=  dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[by] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;棋盘上 A 点有一个过河卒，需要走到目标 B 点。卒行走的规则：可以向下、</summary>
      
    
    
    
    
    <category term="dp" scheme="http://wangxu1905.github.io/tags/dp/"/>
    
    <category term="记忆化搜索" scheme="http://wangxu1905.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>P1434 [SHOI2002]滑雪</title>
    <link href="http://wangxu1905.github.io/2022/01/12/P1434%20[SHOI2002]%E6%BB%91%E9%9B%AA/"/>
    <id>http://wangxu1905.github.io/2022/01/12/P1434%20[SHOI2002]%E6%BB%91%E9%9B%AA/</id>
    <published>2022-01-12T13:51:29.798Z</published>
    <updated>2022-01-12T14:10:21.174Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"><span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span>  <span class="number">6</span></span><br><span class="line"><span class="number">15</span>  <span class="number">24</span>  <span class="number">25</span>  <span class="number">20</span>  <span class="number">7</span></span><br><span class="line"><span class="number">14</span>  <span class="number">23</span>  <span class="number">22</span>  <span class="number">21</span>  <span class="number">8</span></span><br><span class="line"><span class="number">13</span>  <span class="number">12</span>  <span class="number">11</span>  <span class="number">10</span>  <span class="number">9</span></span><br></pre></td></tr></table></figure><p>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 24－17－16－1（从 24 开始，在 1 结束）。当然 25－24－23－…－3－2－1 更长。事实上，这是最长的一条。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行为表示区域的二维数组的行数 R 和列数 C。下面是 R 行，每行有 C 个数，代表高度(两个数字之间用 1 个空格间隔)。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出区域中最长滑坡的长度。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">6</span></span><br><span class="line"><span class="number">15</span> <span class="number">24</span> <span class="number">25</span> <span class="number">20</span> <span class="number">7</span></span><br><span class="line"><span class="number">14</span> <span class="number">23</span> <span class="number">22</span> <span class="number">21</span> <span class="number">8</span></span><br><span class="line"><span class="number">13</span> <span class="number">12</span> <span class="number">11</span> <span class="number">10</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>对于 100% 的数据，1≤R,C≤100。</p><h2 id="算法思路（动态规划）"><a href="#算法思路（动态规划）" class="headerlink" title="算法思路（动态规划）"></a>算法思路（动态规划）</h2><p>​    和走迷宫差不多，只不过需要记录过去的状态。初始化s数组都为0，然后进行扫描，起初s[x][y] = 1,然后进行dfs，然后前进的结果+1和自身值取最大。dfs的过程中，如果该位置已经计算过，直接返回计算过的结果。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,ans;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">1001</span>][<span class="number">1001</span>],s[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[x][y]) <span class="keyword">return</span> s[x][y];</span><br><span class="line">    s[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> xx = dx[i] + x,yy = dy[i] + y;</span><br><span class="line">        <span class="keyword">if</span>(xx&gt;<span class="number">0</span>&amp;&amp;yy&gt;<span class="number">0</span>&amp;&amp;xx&lt;=n&amp;&amp;yy&lt;=m&amp;&amp;mar[x][y]&gt;mar[xx][yy])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(xx,yy);</span><br><span class="line">            s[x][y] = <span class="built_in">max</span>(s[x][y],s[xx][yy] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            cin &gt;&gt; mar[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m; ++j)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,<span class="built_in">dfs</span>(i,j));</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度</summary>
      
    
    
    
    
    <category term="dp" scheme="http://wangxu1905.github.io/tags/dp/"/>
    
    <category term="记忆化搜索" scheme="http://wangxu1905.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles</title>
    <link href="http://wangxu1905.github.io/2022/01/12/P1216%20[USACO1.5][IOI1994]%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%20Number%20Triangles/"/>
    <id>http://wangxu1905.github.io/2022/01/12/P1216%20[USACO1.5][IOI1994]%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%20Number%20Triangles/</id>
    <published>2022-01-12T13:48:29.036Z</published>
    <updated>2022-01-12T13:51:05.023Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>观察下面的数字金字塔。</p><p>写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        <span class="number">7</span> </span><br><span class="line">      <span class="number">3</span>   <span class="number">8</span> </span><br><span class="line">    <span class="number">8</span>   <span class="number">1</span>   <span class="number">0</span> </span><br><span class="line">  <span class="number">2</span>   <span class="number">7</span>   <span class="number">4</span>   <span class="number">4</span> </span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>   <span class="number">2</span>   <span class="number">6</span>   <span class="number">5</span> </span><br></pre></td></tr></table></figure><p>在上面的样例中,从 7→3→8→7→5 的路径产生了最大</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一个行一个正整数 r ,表示行的数目。</p><p>后面每行为这个数字金字塔特定行包含的整数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>单独的一行,包含那个可能得到的最大的和。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">5</span> </span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>【数据范围】<br>对于 100% 的数据，1≤r≤1000，所有输入在 [0,100] 范围内。</p><p>题目翻译来自NOCOW。</p><p>USACO Training Section 1.5</p><p>IOI1994 Day1T1</p><h2 id="算法思路（动态规划）"><a href="#算法思路（动态规划）" class="headerlink" title="算法思路（动态规划）"></a>算法思路（动态规划）</h2><p>挺简单的，没啥好说的。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    cin &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            cin &gt;&gt; dp[i][j];</span><br><span class="line">    <span class="comment">//当前状态等于上一个状态中找最大的，再加上自身值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">            dp[i][j] += <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] ,dp[i - <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++i)</span><br><span class="line">        res = <span class="built_in">max</span>(res,dp[r][i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;观察下面的数字金字塔。&lt;/p&gt;
&lt;p&gt;写一个程序来查找从最高点到底部任意处</summary>
      
    
    
    
    
    <category term="dp" scheme="http://wangxu1905.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>7-10 是否完全二叉搜索树 (30 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/12/7-10%20%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/12/7-10%20%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20(30%20%E5%88%86)/</id>
    <published>2022-01-12T13:33:55.613Z</published>
    <updated>2022-01-14T13:29:18.733Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>将一系列给定数字顺序插入一个初始为空的二叉搜索树（定义为左子树键值大，右子树键值小），你需要判断最后的树是否一棵完全二叉树，并且给出其层序遍历的结果。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个不超过20的正整数<code>N</code>；第二行给出<code>N</code>个互不相同的正整数，其间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>将输入的<code>N</code>个正整数顺序插入一个初始为空的二叉搜索树。在第一行中输出结果树的层序遍历结果，数字间以1个空格分隔，行的首尾不得有多余空格。第二行输出<code>YES</code>，如果该树是完全二叉树；否则输出<code>NO</code>。</p><h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">38</span> <span class="number">45</span> <span class="number">42</span> <span class="number">24</span> <span class="number">58</span> <span class="number">30</span> <span class="number">67</span> <span class="number">12</span> <span class="number">51</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">38</span> <span class="number">45</span> <span class="number">24</span> <span class="number">58</span> <span class="number">42</span> <span class="number">30</span> <span class="number">12</span> <span class="number">67</span> <span class="number">51</span></span><br><span class="line">YES</span><br></pre></td></tr></table></figure><h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">38</span> <span class="number">24</span> <span class="number">12</span> <span class="number">45</span> <span class="number">58</span> <span class="number">67</span> <span class="number">42</span> <span class="number">51</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">38</span> <span class="number">45</span> <span class="number">24</span> <span class="number">58</span> <span class="number">42</span> <span class="number">12</span> <span class="number">67</span> <span class="number">51</span></span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    建树的话，操作很简单，不说了。主要是怎么通过层序遍历判断是否是二叉搜索树。</p><p>​    结点的状态：</p><ul><li>空结点</li><li>有左孩子，没右孩子</li><li>没有左孩子，有右孩子</li><li>左右孩子都有</li></ul><p>判断方式</p><ul><li><p>层序遍历的队列中不会出现空结点，所以不讨论</p></li><li><p>有左孩子，没有右孩子，只要之后弹出的结点有孩子，则一定不是完全二    叉树</p></li><li><p>有右孩子，没有左孩子，一定不是完全二叉树</p></li><li><p>左右孩子都有，无法判断，继续将下一个结点出队</p></li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;*Tree;</span><br><span class="line"><span class="keyword">int</span> n,root;</span><br><span class="line"><span class="function">TreeNode* <span class="title">Insert</span><span class="params">(Tree tree,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        TreeNode * node = (TreeNode*)(malloc)(<span class="built_in"><span class="keyword">sizeof</span></span>(TreeNode));</span><br><span class="line">        node -&gt; data = x;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree -&gt; data &lt; x)    tree -&gt; left = <span class="built_in">Insert</span>(tree -&gt; left,x);</span><br><span class="line">    <span class="keyword">else</span>                    tree -&gt; right = <span class="built_in">Insert</span>(tree -&gt; right,x);</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(Tree tree)</span></span>&#123;</span><br><span class="line">    queue&lt;Tree&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(tree);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>,cnt = <span class="number">1</span>,f = <span class="number">0</span>,fl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = qu.<span class="built_in">size</span>(),number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num--)&#123;</span><br><span class="line">            Tree t = qu.<span class="built_in">front</span>();</span><br><span class="line">            cout &lt;&lt; (f ? <span class="string">&quot; &quot;</span> :<span class="string">&quot;&quot;</span>) &lt;&lt; t -&gt; data;</span><br><span class="line">            f = <span class="number">1</span>;</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//有右孩子，没有左孩子，不是完全二叉树</span></span><br><span class="line">            <span class="keyword">if</span>(t -&gt; right &amp;&amp; !t -&gt; left)    flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(t -&gt; left) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fl)  flag = <span class="number">0</span>;</span><br><span class="line">                qu.<span class="built_in">push</span>(t -&gt; left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t -&gt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fl)  flag = <span class="number">0</span>;</span><br><span class="line">                qu.<span class="built_in">push</span>(t -&gt; right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*没有右孩子，开启fl的判断，只有之后出现结点有孩子，则就不是完全二叉树*/</span></span><br><span class="line">            <span class="keyword">if</span>(!t -&gt; right)   fl = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; root;</span><br><span class="line">    Tree tree = (Tree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(TreeNode));</span><br><span class="line">    tree -&gt; data = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">Insert</span>(tree,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LevelOrder</span>(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,tree[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i] == <span class="number">-1</span>)&#123;</span><br><span class="line">        tree[i] = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; tree[i])     <span class="built_in">add</span>(i * <span class="number">2</span>,x);</span><br><span class="line">    <span class="keyword">else</span>                <span class="built_in">add</span>(i * <span class="number">2</span> + <span class="number">1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tree));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">1</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>,pos = <span class="number">0</span>,flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt &lt; n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(tree[pos] == <span class="number">-1</span>)  pos++;</span><br><span class="line">        <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>        flag = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; tree[pos];</span><br><span class="line">        cnt++;pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(pos == n + <span class="number">1</span>)     cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;将一系列给定数字顺序插入一个初始为空的二叉搜索树（定义为左子树键值大，右子树键值小），你需要判断最后的树是否一棵完全二叉树，并且给出其层序遍历的结果。&lt;/p&gt;
&lt;h3 id=&quot;输入格式：&quot;&gt;&lt;a href=&quot;#输入格式：&quot; </summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-4 N个数求和 (20 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/12/7-4%20N%E4%B8%AA%E6%95%B0%E6%B1%82%E5%92%8C%20(20%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/12/7-4%20N%E4%B8%AA%E6%95%B0%E6%B1%82%E5%92%8C%20(20%20%E5%88%86)/</id>
    <published>2022-01-12T13:09:16.557Z</published>
    <updated>2022-01-12T13:32:54.457Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>本题的要求很简单，就是求<code>N</code>个数字的和。麻烦的是，这些数字是以有理数<code>分子/分母</code>的形式给出的，你输出的和也必须是有理数的形式。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数<code>N</code>（≤100）。随后一行按格式<code>a1/b1 a2/b2 ...</code>给出<code>N</code>个有理数。题目保证所有分子和分母都在长整型范围内。另外，负数的符号一定出现在分子前面。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出上述数字和的最简形式 —— 即将结果写成<code>整数部分 分数部分</code>，其中分数部分写成<code>分子/分母</code>，要求分子小于分母，且它们没有公因子。如果结果的整数部分为0，则只输出分数部分。</p><h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span>/<span class="number">5</span> <span class="number">4</span>/<span class="number">15</span> <span class="number">1</span>/<span class="number">30</span> <span class="number">-2</span>/<span class="number">60</span> <span class="number">8</span>/<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span>/<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span>/<span class="number">3</span> <span class="number">2</span>/<span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="输入样例3："><a href="#输入样例3：" class="headerlink" title="输入样例3："></a>输入样例3：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span>/<span class="number">3</span> <span class="number">-1</span>/<span class="number">6</span> <span class="number">1</span>/<span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="输出样例3："><a href="#输出样例3：" class="headerlink" title="输出样例3："></a>输出样例3：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    模拟题，就是慢慢模拟。。。（各种边界条件，还有要开个long long）</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll high[n + <span class="number">1</span>],low[n + <span class="number">1</span>],downlcm = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        ll a,b;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        cin &gt;&gt; high[i] &gt;&gt; c &gt;&gt; low[i];</span><br><span class="line">        <span class="comment">//求分母的最小公倍数</span></span><br><span class="line">        downlcm = downlcm * low[i] / __gcd(downlcm,low[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll highsum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//根据最小公倍数，求通分后分子和</span></span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; n;++i)</span><br><span class="line">        highsum += downlcm / low[i] * high[i];</span><br><span class="line">    <span class="comment">//算出分子和分母的最大公因数</span></span><br><span class="line">    ll gcd = __gcd(<span class="built_in">abs</span>(highsum),<span class="built_in">abs</span>(downlcm));</span><br><span class="line">    <span class="comment">//分子和分母化简</span></span><br><span class="line">    ll up = highsum / gcd,down = downlcm / gcd;</span><br><span class="line">    <span class="comment">//算出整数部分</span></span><br><span class="line">    ll integer = up / down;</span><br><span class="line">    <span class="comment">//分子要减去整数的值</span></span><br><span class="line">    up %= down;</span><br><span class="line">    <span class="keyword">if</span>(up == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,integer);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(integer) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,integer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,up,down);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;本题的要求很简单，就是求&lt;code&gt;N&lt;/code&gt;个数字的和。麻烦的是，这些数字是以有理数&lt;code&gt;分子/分母&lt;/code&gt;的形式给出的，你输出的和也必须是有理数的形式。&lt;/p&gt;
&lt;h3 id=&quot;输入格式：&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-10 关于堆的判断 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/12/7-10%20%E5%85%B3%E4%BA%8E%E5%A0%86%E7%9A%84%E5%88%A4%E6%96%AD%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/12/7-10%20%E5%85%B3%E4%BA%8E%E5%A0%86%E7%9A%84%E5%88%A4%E6%96%AD%20(25%20%E5%88%86)/</id>
    <published>2022-01-12T12:33:56.893Z</published>
    <updated>2022-01-12T12:37:36.293Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>将一系列给定数字顺序插入一个初始为空的小顶堆<code>H[]</code>。随后判断一系列相关命题是否为真。命题分下列几种：</p><ul><li><code>x is the root</code>：<code>x</code>是根结点；</li><li><code>x and y are siblings</code>：<code>x</code>和<code>y</code>是兄弟结点；</li><li><code>x is the parent of y</code>：<code>x</code>是<code>y</code>的父结点；</li><li><code>x is a child of y</code>：<code>x</code>是<code>y</code>的一个子结点。</li></ul><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每组测试第1行包含2个正整数<code>N</code>（≤ 1000）和<code>M</code>（≤ 20），分别是插入元素的个数、以及需要判断的命题数。下一行给出区间[−10000,10000]内的<code>N</code>个要被插入一个初始为空的小顶堆的整数。之后<code>M</code>行，每行给出一个命题。题目保证命题中的结点键值都是存在的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对输入的每个命题，如果其为真，则在一行中输出<code>T</code>，否则输出<code>F</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">46</span> <span class="number">23</span> <span class="number">26</span> <span class="number">24</span> <span class="number">10</span></span><br><span class="line"><span class="number">24</span> is the root</span><br><span class="line"><span class="number">26</span> <span class="keyword">and</span> <span class="number">23</span> are siblings</span><br><span class="line"><span class="number">46</span> is the parent of <span class="number">23</span></span><br><span class="line"><span class="number">23</span> is a child of <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F</span><br><span class="line">T</span><br><span class="line">F</span><br><span class="line">T</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    其实我的思路我感觉也挺好，缺点就是截取数字的时候费点劲，我感觉大佬们秉持着能单个读就单个读的方法，虽然读取的时候代码挺长，但判断很简单。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1002</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> heap[MAXSIZE], heapsize;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    heap[<span class="number">0</span>] = <span class="number">-100001</span>;</span><br><span class="line">    heapsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++heapsize] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = heapsize; heap[i] &lt; heap[i / <span class="number">2</span>]; i /= <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">swap</span>(heap[i], heap[i / <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= heapsize; ++i)</span><br><span class="line">        <span class="keyword">if</span>(heap[i] == x)    <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>)       <span class="keyword">return</span> heap[<span class="number">1</span>] == x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span>)  <span class="keyword">return</span> <span class="built_in">Find</span>(x) / <span class="number">2</span> == <span class="built_in">Find</span>(y) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">3</span>)  <span class="keyword">return</span> <span class="built_in">Find</span>(x) == <span class="built_in">Find</span>(y) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span>                <span class="keyword">return</span> <span class="built_in">Find</span>(x) / <span class="number">2</span> == <span class="built_in">Find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">Insert</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,flag = <span class="number">0</span>;</span><br><span class="line">        string str;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; str;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">&quot;and&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; y &gt;&gt; str &gt;&gt; str;</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; str;</span><br><span class="line">            <span class="keyword">if</span>(str == <span class="string">&quot;a&quot;</span>)&#123;</span><br><span class="line">                cin &gt;&gt; str &gt;&gt; str &gt;&gt; y;</span><br><span class="line">                flag = <span class="number">4</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cin &gt;&gt; str;</span><br><span class="line">                <span class="keyword">if</span>(str == <span class="string">&quot;root&quot;</span>)&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cin &gt;&gt; str &gt;&gt; y;</span><br><span class="line">                    flag = <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(x,y,flag))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;T&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;F&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我自己的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1002</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> heap[MAXSIZE], heapsize;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    heap[<span class="number">0</span>] = <span class="number">-100001</span>;</span><br><span class="line">    heapsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++heapsize] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = heapsize; heap[i] &lt; heap[i / <span class="number">2</span>]; i /= <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">swap</span>(heap[i], heap[i / <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= heapsize; ++i)</span><br><span class="line">        <span class="keyword">if</span>(heap[i] == x)    <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">Insert</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="built_in">getline</span>(cin, s);</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)s.<span class="built_in">find</span>(<span class="string">&quot;root&quot;</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[pos] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                pos++;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">            <span class="keyword">if</span>(heap[<span class="number">1</span>] != num)  flag = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pos1 = <span class="number">0</span>, pos2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[pos1] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                pos1++;</span><br><span class="line">            <span class="keyword">int</span> num1 = <span class="built_in">Find</span>(<span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, pos1)));</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(s[pos1]) &amp;&amp; s[pos1] != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                pos1++;</span><br><span class="line">            pos2 = pos1;</span><br><span class="line">            <span class="keyword">while</span>(pos2 &lt; s.<span class="built_in">size</span>() &amp;&amp; s[pos2] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                pos2++;</span><br><span class="line">            <span class="keyword">int</span> num2 = <span class="built_in">Find</span>(<span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(pos1, pos2 - pos1)));</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">int</span>)s.<span class="built_in">find</span>(<span class="string">&quot;siblings&quot;</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(num1 / <span class="number">2</span> != num2 / <span class="number">2</span> || num1 == num2)</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>((<span class="keyword">int</span>)s.<span class="built_in">find</span>(<span class="string">&quot;parent&quot;</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(num1 != num2 / <span class="number">2</span>)</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(num1 / <span class="number">2</span> != num2)</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;T&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;F&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;将一系列给定数字顺序插入一个初始为空的小顶堆&lt;code&gt;H[]&lt;/code&gt;。随后判断一系列相关命题是否为真。命题分下列几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x is the root&lt;/code&gt;：&lt;code&gt;x&lt;</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-8 后缀式求值 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/12/7-8%20%E5%90%8E%E7%BC%80%E5%BC%8F%E6%B1%82%E5%80%BC%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/12/7-8%20%E5%90%8E%E7%BC%80%E5%BC%8F%E6%B1%82%E5%80%BC%20(25%20%E5%88%86)/</id>
    <published>2022-01-12T12:30:53.999Z</published>
    <updated>2022-01-12T12:38:12.135Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>我们人类习惯于书写“中缀式”，如 <code>3 + 5 * 2</code> ，其值为<code>13</code>。 (p.s. 为什么人类习惯中缀式呢？是因为中缀式比后缀式好用么？）<br>而计算机更加习惯“后缀式”（也叫“逆波兰式”，Reverse Polish Notation）。上述中缀式对应的后缀式是： <code>3 5 2 * +</code><br>现在，请对输入的后缀式进行求值。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>在一行中输入一个后缀式，<code>运算数</code>和<code>运算符</code>之间用空格分隔，运算数长度不超过<code>6</code>位，运算符仅有<code>+ - * /</code> 四种。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出后缀式的值，保留一位小数。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">5.4</span> <span class="number">2.2</span> * +</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14.9</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    不得不说，看大佬们代码，对扩展思路很有帮助，我都是读一整行的字符串，然后遍历，遍历的时候进行判断还挺费劲。</p><p>​    大佬们的这个好，单个单个读，以空格作为分割</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string str;</span><br><span class="line">    stack&lt;<span class="keyword">double</span>&gt; st;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">&quot;*&quot;</span> || str == <span class="string">&quot;/&quot;</span> || str == <span class="string">&quot;+&quot;</span> || str == <span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">double</span> a = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">double</span> b = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(str == <span class="string">&quot;*&quot;</span>)      st.<span class="built_in">push</span>(b * a);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">&quot;/&quot;</span>) st.<span class="built_in">push</span>(b / a);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">&quot;+&quot;</span>) st.<span class="built_in">push</span>(b + a);</span><br><span class="line">            <span class="keyword">else</span>                st.<span class="built_in">push</span>(b - a);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="built_in">stod</span>(str));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n&quot;</span>,st.<span class="built_in">top</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我自己的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    stack&lt;<span class="keyword">double</span>&gt; st1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(s[i]) || (s[i] == <span class="string">&#x27;-&#x27;</span>&amp;&amp;<span class="built_in">isdigit</span>(s[i + <span class="number">1</span>])) || s[i] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            str += s[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            st1.<span class="built_in">push</span>(<span class="number">1.0</span> * <span class="built_in">stod</span>(str));</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span> || s[i] == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">double</span> a = st1.<span class="built_in">top</span>();st1.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">double</span> b = st1.<span class="built_in">top</span>();st1.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(s[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> : st1.<span class="built_in">push</span>(b + a);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> : st1.<span class="built_in">push</span>(b - a);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> : st1.<span class="built_in">push</span>(b * a);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> : st1.<span class="built_in">push</span>(b / a);<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n&quot;</span>,st1.<span class="built_in">top</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;我们人类习惯于书写“中缀式”，如 &lt;code&gt;3 + 5 * 2&lt;/code&gt; ，其值为&lt;code&gt;13&lt;/code&gt;。 (p.s. 为什么人类习惯中缀式呢？是因为中缀式比后缀式好用么？）&lt;br&gt;而计算机更加习惯“后缀式”（</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-7 彩虹瓶 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/12/7-7%20%E5%BD%A9%E8%99%B9%E7%93%B6%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/12/7-7%20%E5%BD%A9%E8%99%B9%E7%93%B6%20(25%20%E5%88%86)/</id>
    <published>2022-01-12T12:28:04.571Z</published>
    <updated>2022-01-12T12:38:46.326Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://images.ptausercontent.com/5612216c-1cbd-4dba-b9da-4f653ad00c7b.JPG" alt="rb.JPG"></p><p>彩虹瓶的制作过程（并不）是这样的：先把一大批空瓶铺放在装填场地上，然后按照一定的顺序将每种颜色的小球均匀撒到这批瓶子里。</p><p>假设彩虹瓶里要按顺序装 N 种颜色的小球（不妨将顺序就编号为 1 到 N）。现在工厂里有每种颜色的小球各一箱，工人需要一箱一箱地将小球从工厂里搬到装填场地。如果搬来的这箱小球正好是可以装填的颜色，就直接拆箱装填；如果不是，就把箱子先码放在一个临时货架上，码放的方法就是一箱一箱堆上去。当一种颜色装填完以后，先看看货架顶端的一箱是不是下一个要装填的颜色，如果是就取下来装填，否则去工厂里再搬一箱过来。</p><p>如果工厂里发货的顺序比较好，工人就可以顺利地完成装填。例如要按顺序装填 7 种颜色，工厂按照 7、6、1、3、2、5、4 这个顺序发货，则工人先拿到 7、6 两种不能装填的颜色，将其按照 7 在下、6 在上的顺序堆在货架上；拿到 1 时可以直接装填；拿到 3 时又得临时码放在 6 号颜色箱上；拿到 2 时可以直接装填；随后从货架顶取下 3 进行装填；然后拿到 5，临时码放到 6 上面；最后取了 4 号颜色直接装填；剩下的工作就是顺序从货架上取下 5、6、7 依次装填。</p><p>但如果工厂按照 3、1、5、4、2、6、7 这个顺序发货，工人就必须要愤怒地折腾货架了，因为装填完 2 号颜色以后，不把货架上的多个箱子搬下来就拿不到 3 号箱，就不可能顺利完成任务。</p><p>另外，货架的容量有限，如果要堆积的货物超过容量，工人也没办法顺利完成任务。例如工厂按照 7、6、5、4、3、2、1 这个顺序发货，如果货架够高，能码放 6 只箱子，那还是可以顺利完工的；但如果货架只能码放 5 只箱子，工人就又要愤怒了……</p><p>本题就请你判断一下，工厂的发货顺序能否让工人顺利完成任务。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先在第一行给出 3 个正整数，分别是彩虹瓶的颜色数量 <em>N</em>（1&lt;<em>N</em>≤103）、临时货架的容量 <em>M</em>（&lt;<em>N</em>）、以及需要判断的发货顺序的数量 <em>K</em>。</p><p>随后 <em>K</em> 行，每行给出 <em>N</em> 个数字，是 1 到<em>N</em> 的一个排列，对应工厂的发货顺序。</p><p>一行中的数字都以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个发货顺序，如果工人可以愉快完工，就在一行中输出 <code>YES</code>；否则输出 <code>NO</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>利用栈模拟仓库，使用now来记录当前空地需要的序号。若当前输入的箱子序号==now，在now++后，需要比对仓库，直至仓库空或者栈顶元素!= now为止。最后若栈空，并且无仓库过存问题，即为“Yes”。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span>(now == x)&#123;</span><br><span class="line">                now++;</span><br><span class="line">                <span class="keyword">while</span>(st.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; st.<span class="built_in">top</span>() == now)&#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();now++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(x);</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">size</span>() &gt; m)</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">size</span>() &gt; <span class="number">0</span> || !flag)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我自己的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>, t, flag = <span class="number">1</span>;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt;  st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                <span class="keyword">if</span>(t == num) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    <span class="keyword">while</span>(st.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; st.<span class="built_in">top</span>() == num) &#123;</span><br><span class="line">                        st.<span class="built_in">pop</span>();</span><br><span class="line">                        num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span>(st.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; st.<span class="built_in">top</span>() == num) &#123;</span><br><span class="line">                        st.<span class="built_in">pop</span>();</span><br><span class="line">                        num++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">size</span>() &gt;= m)  flag = <span class="number">0</span>;</span><br><span class="line">                    st.<span class="built_in">push</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == n + <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ptausercontent.com/5612216c-1cbd-4dba-b9da-4f653ad00c7b.JPG&quot; alt=&quot;rb.JPG&quot;&gt;&lt;/p&gt;
&lt;p&gt;彩虹瓶的制</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>P1802 5 倍经验日</title>
    <link href="http://wangxu1905.github.io/2022/01/11/P1802%205%20%E5%80%8D%E7%BB%8F%E9%AA%8C%E6%97%A5/"/>
    <id>http://wangxu1905.github.io/2022/01/11/P1802%205%20%E5%80%8D%E7%BB%8F%E9%AA%8C%E6%97%A5/</id>
    <published>2022-01-11T14:27:22.310Z</published>
    <updated>2022-01-12T13:47:54.049Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>现在乐斗有活动了！每打一个人可以获得 5 倍经验！absi2011 却无奈的看着那一些比他等级高的好友，想着能否把他们干掉。干掉能拿不少经验的。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在 absi2011 拿出了 x个迷你装药物（嗑药打人可耻…），准备开始与那些人打了。</p><p>由于迷你装药物每个只能用一次，所以 absi2011 要谨慎的使用这些药。悲剧的是，用药量没达到最少打败该人所需的属性药药量，则打这个人必输。例如他用 2 个药去打别人，别人却表明 3 个药才能打过，那么相当于你输了并且这两个属性药浪费了。</p><p>现在有 n个好友，给定失败时可获得的经验、胜利时可获得的经验，打败他至少需要的药量。</p><p>要求求出最大经验 s，输出 5s。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个数，n和 x。</p><p>后面 n行每行三个数，分别表示失败时获得的经验 lose_i，胜利时获得的经验 win_i 和打过要至少使用的药数量use_i。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，最多获得的经验的五倍。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 8</span><br><span class="line">21 52 1</span><br><span class="line">21 70 5</span><br><span class="line">21 48 2</span><br><span class="line">14 38 3</span><br><span class="line">14 36 1</span><br><span class="line">14 36 2</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1060</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p><strong>【Hint】</strong></p><p>五倍经验活动的时候，absi2011 总是吃体力药水而不是这种属性药。</p><p><strong>【数据范围】</strong></p><ul><li>对于 10% 的数据，保证 x=0。</li><li>对于 30% 的数据，保证 0≤n≤10，0≤x≤20。</li><li>对于 60% 的数据，保证 0≤n,x≤100， 10&lt;lose_i,win_i≤100，0≤ use_i≤5。</li><li>对于 100% 的数据，保证 0≤n,x≤10^3，0&lt;lose_i≤ win_i≤10^6，0≤ use_i≤10^3。</li></ul><p><strong>【题目来源】</strong></p><p>fight.pet.qq.com</p><p>absi2011 授权题目</p><h2 id="算法思路（动态规划）"><a href="#算法思路（动态规划）" class="headerlink" title="算法思路（动态规划）"></a>算法思路（动态规划）</h2><p>OI梗：**==十年 OI 一场空，不开 long long 见祖宗。==**</p><p>和背包问题有点区别，就是如果不选当前物品的话，和前一个状态还是有区别。所以状态方程只需要把原本的dp[j] = dp[j],改成dp[j] += v1[i]</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> w[<span class="number">1001</span>],v1[<span class="number">1001</span>],v2[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,x;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n ;++i)&#123;</span><br><span class="line">        cin &gt;&gt; v1[i] &gt;&gt; v2[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j = x; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; w[i])</span><br><span class="line">                dp[j] += v1[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j] +v1[i],dp[j - w[i]] + v2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[x] * <span class="number">5</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目背景&quot;&gt;&lt;a href=&quot;#题目背景&quot; class=&quot;headerlink&quot; title=&quot;题目背景&quot;&gt;&lt;/a&gt;题目背景&lt;/h2&gt;&lt;p&gt;现在乐斗有活动了！每打一个人可以获得 5 倍经验！absi2011 却无奈</summary>
      
    
    
    
    
    <category term="dp" scheme="http://wangxu1905.github.io/tags/dp/"/>
    
    <category term="0-1背包" scheme="http://wangxu1905.github.io/tags/0-1%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>P1616 疯狂的采药</title>
    <link href="http://wangxu1905.github.io/2022/01/10/P1616%20%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF/"/>
    <id>http://wangxu1905.github.io/2022/01/10/P1616%20%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF/</id>
    <published>2022-01-10T03:21:18.747Z</published>
    <updated>2022-01-10T13:08:18.918Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>此题为纪念 LiYuxiang 而生。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是 LiYuxiang，你能完成这个任务吗？</p><p>此题和原题的不同点：</p><ol><li><p>每种草药可以无限制地疯狂采摘。</p></li><li><p>药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！</p></li></ol><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第一行有两个整数，分别代表总共能够用来采药的时间 t<em>t</em> 和代表山洞里的草药的数目 m。</p><p>第 2 到第 (m + 1)行，每行两个整数，第 (i + 1)行的整数 a_i, b_i分别表示采摘第 i 种草药的时间和该草药的价值。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">70</span> <span class="number">3</span></span><br><span class="line"><span class="number">71</span> <span class="number">100</span></span><br><span class="line"><span class="number">69</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">140</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul><li>对于 30% 的数据，保证m≤10^3 。</li><li>对于 100% 的数据，保证 1≤m≤10^4， 1≤t≤10^7，且 1≤m×t≤10^7， 1≤a_i,b_i≤10^4。</li></ul><h2 id="算法思路（动态规划）"><a href="#算法思路（动态规划）" class="headerlink" title="算法思路（动态规划）"></a>算法思路（动态规划）</h2><p>经典完全背包问题</p><p>OI梗：**==十年 OI 一场空，不开 long long 见祖宗。==**</p><p>这题用二维dp数组，开出来太大了（也可以试试滚动数组），所以只能用一维dp</p><p>完全背包问题和0-1背包问题的递推式不同是，完全背包问题它放进物品的时候，是考虑它的同一行，而不是上一行，因为考虑的是同一行，所以遍历的时候可以进行顺序遍历，同时当j &lt; w[i]的时候，d[j]是不会发生改变的，因为装不进去，所以该从w[i]开始遍历</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">10000001</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">10001</span>], v[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t, m;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = w[i]; j &lt;= t; ++j)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j - w[i]] + v[i],dp[j]);</span><br><span class="line">    cout &lt;&lt; dp[t] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目背景&quot;&gt;&lt;a href=&quot;#题目背景&quot; class=&quot;headerlink&quot; title=&quot;题目背景&quot;&gt;&lt;/a&gt;题目背景&lt;/h2&gt;&lt;p&gt;此题为纪念 LiYuxiang 而生。&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;</summary>
      
    
    
    
    
    <category term="dp" scheme="http://wangxu1905.github.io/tags/dp/"/>
    
    <category term="完全背包" scheme="http://wangxu1905.github.io/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>P1048 [NOIP2005 普及组] 采药</title>
    <link href="http://wangxu1905.github.io/2022/01/10/P1048%20[NOIP2005%20%E6%99%AE%E5%8F%8A%E7%BB%84]%20%E9%87%87%E8%8D%AF/"/>
    <id>http://wangxu1905.github.io/2022/01/10/P1048%20[NOIP2005%20%E6%99%AE%E5%8F%8A%E7%BB%84]%20%E9%87%87%E8%8D%AF/</id>
    <published>2022-01-10T02:33:03.506Z</published>
    <updated>2022-01-10T12:56:05.694Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是辰辰，你能完成这个任务吗？</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有 2 个整数 T（1≤T≤1000）和 M（1≤M≤100），用一个空格隔开，T 代表总共能够用来采药的时间，M 代表山洞里的草药的数目。</p><p>接下来的 M 行每行包括两个在 1 到 100 之间（包括 1 和 100）的整数，分别表示采摘某株草药的时间和这株草药的价值。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出在规定的时间内可以采到的草药的最大总价值。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">70 3</span><br><span class="line">71 100</span><br><span class="line">69 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p><strong>【数据范围】</strong></p><ul><li>对于 30% 的数据，M≤10；</li><li>对于全部的数据，M≤100。</li></ul><p><strong>【题目来源】</strong></p><p>NOIP 2005 普及组第三题</p><h2 id="算法思路（动态规划）"><a href="#算法思路（动态规划）" class="headerlink" title="算法思路（动态规划）"></a>算法思路（动态规划）</h2><p>​    经典0-1背包问题</p><h4 id="1-二维dp数组"><a href="#1-二维dp数组" class="headerlink" title="1.二维dp数组"></a>1.二维dp数组</h4><p>dp[i][j]代表前i个物品，容量为j的情况下的能选择的最大价值，</p><p>于是我们有如下递推式：dp[0][j] = 0</p><p><svg xmlns="http://www.w3.org/2000/svg" width="58.472ex" height="5.428ex" viewbox="0 -1449.5 25844.7 2399" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-640-TEX-I-1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/><path id="MJX-640-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/><path id="MJX-640-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-640-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path id="MJX-640-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/><path id="MJX-640-TEX-I-1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/><path id="MJX-640-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-640-TEX-S3-7B" d="M618 -943L612 -949H582L568 -943Q472 -903 411 -841T332 -703Q327 -682 327 -653T325 -350Q324 -28 323 -18Q317 24 301 61T264 124T221 171T179 205T147 225T132 234Q130 238 130 250Q130 255 130 258T131 264T132 267T134 269T139 272T144 275Q207 308 256 367Q310 436 323 519Q324 529 325 851Q326 1124 326 1154T332 1205Q369 1358 566 1443L582 1450H612L618 1444V1429Q618 1413 616 1411L608 1406Q599 1402 585 1393T552 1372T515 1343T479 1305T449 1257T429 1200Q425 1180 425 1152T423 851Q422 579 422 549T416 498Q407 459 388 424T346 364T297 318T250 284T214 264T197 254L188 251L205 242Q290 200 345 138T416 3Q421 -18 421 -48T423 -349Q423 -397 423 -472Q424 -677 428 -694Q429 -697 429 -699Q434 -722 443 -743T465 -782T491 -816T519 -845T548 -868T574 -886T595 -899T610 -908L616 -910Q618 -912 618 -928V-943Z"/><path id="MJX-640-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/><path id="MJX-640-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-640-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-640-TEX-N-3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/><path id="MJX-640-TEX-I-1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/><path id="MJX-640-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path id="MJX-640-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/><path id="MJX-640-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/><path id="MJX-640-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-640-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/><path id="MJX-640-TEX-I-1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/><path id="MJX-640-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-640-TEX-I-1D451"/></g><g data-mml-node="mi" transform="translate(520, 0)"><use xlink:href="#MJX-640-TEX-I-1D45D"/></g><g data-mml-node="mo" transform="translate(1023, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(1301, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(1646, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(1924, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(2202, 0)"><use xlink:href="#MJX-640-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(2614, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(3169.8, 0)"><use xlink:href="#MJX-640-TEX-N-3D"/></g><g data-mml-node="mrow" transform="translate(4225.6, 0)"><g data-mml-node="mo"><use xlink:href="#MJX-640-TEX-S3-7B"/></g><g data-mml-node="mtable" transform="translate(750, 0)"><g data-mml-node="mtr" transform="translate(0, 600)"><g data-mml-node="mtd"><g data-mml-node="mi"><use xlink:href="#MJX-640-TEX-I-1D451"/></g><g data-mml-node="mi" transform="translate(520, 0)"><use xlink:href="#MJX-640-TEX-I-1D45D"/></g><g data-mml-node="mo" transform="translate(1023, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(1301, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(1868.2, 0)"><use xlink:href="#MJX-640-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(2868.4, 0)"><use xlink:href="#MJX-640-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(3368.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(3646.4, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(3924.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(4336.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(4614.4, 0)"><use xlink:href="#MJX-640-TEX-N-2C"/></g><g data-mml-node="mo" transform="translate(5059.1, 0)"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">当</text></g><g data-mml-node="mi" transform="translate(6220.9, 0)"><use xlink:href="#MJX-640-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(6910.7, 0)"><use xlink:href="#MJX-640-TEX-N-3C"/></g><g data-mml-node="mi" transform="translate(7966.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D464"/></g><g data-mml-node="mo" transform="translate(8682.4, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(8960.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(9305.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g></g></g><g data-mml-node="mtr" transform="translate(0, -600)"><g data-mml-node="mtd"><g data-mml-node="mi"><use xlink:href="#MJX-640-TEX-I-1D45A"/></g><g data-mml-node="mi" transform="translate(878, 0)"><use xlink:href="#MJX-640-TEX-I-1D44E"/></g><g data-mml-node="mi" transform="translate(1407, 0)"><use xlink:href="#MJX-640-TEX-I-1D465"/></g><g data-mml-node="mo" transform="translate(1979, 0)"><use xlink:href="#MJX-640-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(2368, 0)"><use xlink:href="#MJX-640-TEX-I-1D451"/></g><g data-mml-node="mi" transform="translate(2888, 0)"><use xlink:href="#MJX-640-TEX-I-1D45D"/></g><g data-mml-node="mo" transform="translate(3391, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(3669, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(4236.2, 0)"><use xlink:href="#MJX-640-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(5236.4, 0)"><use xlink:href="#MJX-640-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(5736.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(6014.4, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(6292.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(6704.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(6982.4, 0)"><use xlink:href="#MJX-640-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(7427.1, 0)"><use xlink:href="#MJX-640-TEX-I-1D451"/></g><g data-mml-node="mi" transform="translate(7947.1, 0)"><use xlink:href="#MJX-640-TEX-I-1D45D"/></g><g data-mml-node="mo" transform="translate(8450.1, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(8728.1, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(9295.3, 0)"><use xlink:href="#MJX-640-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(10295.6, 0)"><use xlink:href="#MJX-640-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(10795.6, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(11073.6, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(11351.6, 0)"><use xlink:href="#MJX-640-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(11985.8, 0)"><use xlink:href="#MJX-640-TEX-N-2212"/></g><g data-mml-node="mi" transform="translate(12986, 0)"><use xlink:href="#MJX-640-TEX-I-1D464"/></g><g data-mml-node="mo" transform="translate(13702, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(13980, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(14325, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(14603, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(15103.2, 0)"><use xlink:href="#MJX-640-TEX-N-2B"/></g><g data-mml-node="mi" transform="translate(16103.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D463"/></g><g data-mml-node="mo" transform="translate(16588.4, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(16866.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(17211.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(17489.4, 0)"><use xlink:href="#MJX-640-TEX-N-29"/></g><g data-mml-node="mo" transform="translate(17878.4, 0)"><use xlink:href="#MJX-640-TEX-N-2C"/></g><g data-mml-node="mo" transform="translate(18323.1, 0)"><use xlink:href="#MJX-640-TEX-N-28"/></g><g data-mml-node="mo" transform="translate(18712.1, 0)"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">其</text><text data-variant="normal" transform="translate(884, 0) matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">他</text></g><g data-mml-node="mo" transform="translate(20480.1, 0)"><use xlink:href="#MJX-640-TEX-N-29"/></g></g></g></g><g data-mml-node="mo" transform="translate(21619.1, 0)"/></g></g></g></svg></p><ul><li>当容量小于w[i]，那么说明放不下第i件物品，则前i种物品的最大价值和前i-1种最大物品价值的情况相同，即dp[i][j] = dp[i-1][j]</li><li>当能装下，则要给第i件物品留下足够的空间，对应前i-1种物品，容量为j-w[i]的最大价值加上v[i]，然后和dp[i-1][j]比较取最大，即                       dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])</li></ul><h4 id="2-一维dp数组"><a href="#2-一维dp数组" class="headerlink" title="2.一维dp数组"></a>2.一维dp数组</h4><p>我们从上面二维数组可以看出，dp[i][j]只与它的上一行dp[i-1]有关，所以可以用改用一维数组，因为当前值和它的上一行有关，所以进行遍历的时候要反向遍历</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">101</span>], v[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t, m;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; w[i])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j - w[i]] + v[i], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m][t] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">101</span>], v[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t, m;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = t;j &gt;= <span class="number">1</span>; --j)</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= w[i])</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j - w[i]] +v[i]);</span><br><span class="line">    cout &lt;&lt; dp[t] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最</summary>
      
    
    
    
    
    <category term="dp" scheme="http://wangxu1905.github.io/tags/dp/"/>
    
    <category term="01背包" scheme="http://wangxu1905.github.io/tags/01%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
</feed>
