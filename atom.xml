<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moon</title>
  
  
  <link href="http://wangxu1905.github.io/atom.xml" rel="self"/>
  
  <link href="http://wangxu1905.github.io/"/>
  <updated>2022-02-02T13:51:37.446Z</updated>
  <id>http://wangxu1905.github.io/</id>
  
  <author>
    <name>Moon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>L3-001 凑零钱 (30 分)</title>
    <link href="http://wangxu1905.github.io/2022/02/02/L3-001%20%E5%87%91%E9%9B%B6%E9%92%B1%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/02/02/L3-001%20%E5%87%91%E9%9B%B6%E9%92%B1%20(30%20%E5%88%86)/</id>
    <published>2022-02-02T13:46:55.884Z</published>
    <updated>2022-02-02T13:51:37.446Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>韩梅梅喜欢满宇宙到处逛街。现在她逛到了一家火星店里，发现这家店有个特别的规矩：你可以用任何星球的硬币付钱，但是绝不找零，当然也不能欠债。韩梅梅手边有 104 枚来自各个星球的硬币，需要请你帮她盘算一下，是否可能精确凑出要付的款额。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出两个正整数：<em>N</em>（≤104）是硬币的总个数，<em>M</em>（≤102）是韩梅梅要付的款额。第二行给出 <em>N</em> 枚硬币的正整数面值。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出硬币的面值 <em>V</em>1≤<em>V</em>2≤⋯≤<em>V**k</em>，满足条件 <em>V</em>1+<em>V</em>2+…+<em>V**k</em>=<em>M</em>。数字间以 1 个空格分隔，行首尾不得有多余空格。若解不唯一，则输出最小序列。若无解，则输出 <code>No Solution</code>。</p><p>注：我们说序列{ <em>A</em>[1],<em>A</em>[2],⋯ }比{ <em>B</em>[1],<em>B</em>[2],⋯ }“小”，是指存在 <em>k</em>≥1 使得 <em>A</em>[<em>i</em>]=<em>B</em>[<em>i</em>] 对所有 <em>i</em>&lt;<em>k</em> 成立，并且 <em>A</em>[<em>k</em>]&lt;<em>B</em>[<em>k</em>]。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No Solution</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    01背包，重量和价值同值。因为要输出从小到大的排列，所以先从大到小按面额进行排序，然后看看小面值弄否把大面值代替，然后choice记录路径</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,flag,val[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10001</span>],choice[<span class="number">10001</span>][<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">    <span class="built_in">sort</span>(val + <span class="number">1</span>, val + <span class="number">1</span> + n ,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= val[i]; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j - val[i]] + val[i] &gt;= dp[j])&#123;</span><br><span class="line">                dp[j] = dp[j - val[i]] + val[i];</span><br><span class="line">                choice[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[m] != m)   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n,j = m; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(choice[i][j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                <span class="keyword">else</span>        flag = <span class="number">1</span>;</span><br><span class="line">                cout &lt;&lt; val[i];</span><br><span class="line">                j -= val[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;韩梅梅喜欢满宇宙到处逛街。现在她逛到了一家火星店里，发现这家店有个特别的规矩：你可以用任何星球的硬币付钱，但是绝不找零，当然也不能欠债。韩梅梅手边有 104 枚来自各个星球的硬币，需要请你帮她盘算一下，是否可能精确凑出要付的</summary>
      
    
    
    
    
    <category term="天梯赛" scheme="http://wangxu1905.github.io/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    
    <category term="01背包" scheme="http://wangxu1905.github.io/tags/01%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>C++ STL set的函数</title>
    <link href="http://wangxu1905.github.io/2022/01/21/C++%20STL%20set%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>http://wangxu1905.github.io/2022/01/21/C++%20STL%20set%E7%9A%84%E5%87%BD%E6%95%B0/</id>
    <published>2022-01-21T14:38:48.999Z</published>
    <updated>2022-01-21T14:53:40.359Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>set lower_bound()返回的是第一个大于等于x的迭代器；</p><p>set upper_bound() 第一个大于x的迭代器；</p><p>如果没找到，返回set.end() （好像是容器的大小）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        s.<span class="built_in">insert</span>(i);</span><br><span class="line">    cout &lt;&lt; *s.<span class="built_in">lower_bound</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">//输出3</span></span><br><span class="line">    cout &lt;&lt; *s.<span class="built_in">upper_bound</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">//输出4</span></span><br><span class="line">    cout &lt;&lt; *s.<span class="built_in">upper_bound</span>(<span class="number">11</span>) &lt;&lt; endl; <span class="comment">//返回s.end(),好像s.end()存的是set容器的大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    然后是multiset，直接使用erase的话，是删除所有和值相等的元素，如果值删除单个元素，需要先通过find返回一个元素的迭代器，通过迭代器删除，这样就只删除一个了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*s.erase(1);</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; s.size() &lt;&lt; endl;*/</span></span><br><span class="line">    s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(<span class="number">1</span>));</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;set lower_bound()返回的是第一个大于等于x的迭代器；&lt;/p&gt;
&lt;p&gt;set upper_bound() 第一个大于x的迭代器；&lt;/p&gt;
&lt;p&gt;如果没找到，返回set.end() （好像是容器的大小）&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="STL" scheme="http://wangxu1905.github.io/tags/STL/"/>
    
    <category term="set" scheme="http://wangxu1905.github.io/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>P1439 【模板】最长公共子序列</title>
    <link href="http://wangxu1905.github.io/2022/01/21/P1439%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://wangxu1905.github.io/2022/01/21/P1439%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2022-01-21T14:15:55.413Z</published>
    <updated>2022-01-21T14:26:58.677Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出 1,2,…,n 的两个排列 P_1 和 P_2 ，求它们的最长公共子序列。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个数 n。</p><p>接下来两行，每行为 n个数，为自然数 1,2,…,n的一个排列。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数，即最长公共子序列的长度。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 </span><br><span class="line">3 2 1 4 5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><ul><li>对于 50% 的数据，n≤10^3；</li><li>对于 100% 的数据，n≤10^5。</li></ul><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    我们可以将第一个串作为标准，用第二串匹配第一个串。</p><p>​    我们可以对第一个串通过map进行离散化，用数字对应它的数组下标，然后将第二个串按照上面的对应方式进行离散化表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> 如果我们把他变成 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">    那么 <span class="number">3</span> - <span class="number">1</span>；<span class="number">2</span> - <span class="number">2</span>；<span class="number">1</span> - <span class="number">3</span>；<span class="number">4</span> - <span class="number">4</span>；<span class="number">5</span>- <span class="number">5</span></span><br><span class="line">第二个串按照上述对应原则</span><br><span class="line">    则由 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> 变成了 <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>​    我们将第一个串进行离散化后，满足了第一个串是上升的，那么加入第二串离散化后满足连续上升的也就是第一个串的排列顺序。</p><p>​    最后问题就变成求一个串的最长不下降序列</p><p>​    一种是数组二分，一种是set二分，set自带二分查找，由于返回的是迭代器，不能修改值，所以只能先删除，后加入新值</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    a.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        m[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        a[i] = m[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">fill</span>(dp + <span class="number">1</span>,dp + n + <span class="number">1</span>,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        *<span class="built_in">lower_bound</span>(dp + <span class="number">1</span>,dp+n + <span class="number">1</span>,a[i]) = a[i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">lower_bound</span>(dp + <span class="number">1</span>,dp + n + <span class="number">1</span>,<span class="number">0x3f3f3f3f</span>) - (dp + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    a.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        m[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        a[i] = m[t];</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = dp.<span class="built_in">lower_bound</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span>(it != dp.<span class="built_in">end</span>())</span><br><span class="line">            dp.<span class="built_in">erase</span>(it);</span><br><span class="line">        dp.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给出 1,2,…,n 的两个排列 P_1 和 P_2 ，求它们的最长公共子</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-15 可怜的复杂度 (30 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/21/7-15%20%E5%8F%AF%E6%80%9C%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/21/7-15%20%E5%8F%AF%E6%80%9C%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%20(30%20%E5%88%86)/</id>
    <published>2022-01-21T02:35:46.037Z</published>
    <updated>2022-01-21T03:01:31.979Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>可怜有一个数组 <em>A</em>，定义它的复杂度 <em>c</em>(<em>A</em>) 等于它本质不同的子区间个数。举例来说，<em>c</em>([1,1,1])=3，因为 [1,1,1] 只有 3 个本质不同的子区间 [1]、[1,1] 和 [1,1,1]；而 <em>c</em>([1,2,1])=5，它包含 5 个本质不同的子区间 [1]、[2]、[1,2]、[2,1]、[1,2,1]。</p><p>可怜打算出一道和复杂度相关的题目。众所周知，引入随机性往往可以让一个简单的题目脱胎换骨。现在，可怜手上有一个长度为 <em>n</em> 的正整数数组 <em>x</em> 和一个正整数 <em>m</em>。接着，可怜会独立地随机产生 <em>n</em> 个 [1,<em>m</em>] 中的随机整数 <em>y**i</em>，并把 <em>x**i</em> 修改为 <em>m<strong>x</strong>i</em>+<em>y**i</em>。</p><p>显然，一共有 <em>N</em>=<em>m**n</em> 种可能的结果数组。现在，可怜想让你求出这 <em>N</em> 个数组的复杂度的和。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行给出一个整数 <em>t</em> (1≤<em>t</em>≤5) 表示数据组数。</p><p>对于每组数据，第一行输入两个整数 <em>n</em> 和 <em>m</em> (1≤<em>n</em>≤100,1≤<em>m</em>≤109)，第二行是 <em>n</em> 个空格隔开的整数表示数组 <em>x</em> 的初始值 (1≤<em>x**i</em>≤109)。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对于每组数据，输出一行一个整数表示答案。答案可能很大，你只需要输出对 998244353 取模后的结果。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">10</span> <span class="number">2</span></span><br><span class="line"><span class="number">80582987</span> <span class="number">187267045</span> <span class="number">80582987</span> <span class="number">187267045</span> <span class="number">80582987</span> <span class="number">187267045</span> <span class="number">80582987</span> <span class="number">187267045</span> <span class="number">80582987</span> <span class="number">187267045</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">44</span></span><br><span class="line"><span class="number">404</span></span><br><span class="line"><span class="number">44616</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    没什么想法，太难了，骗点分就行了。巨佬出的题果然强，同时我也巨菜。</p><p>​    简单点，就是骗m = 1和m = 2的分</p><p>​    就是根据n个数，枚举里面有所有的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当n = <span class="number">3</span>,m = <span class="number">2</span>时</span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">    <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line">    <span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>然后根据这些情况通过next_permutation计算全排列。</p><p>计算一共有多少子区间，采用set的不存储重复元素的特性，按照区间里有1,2,3…n个元素，进行插入，循环一次就把set的容量大小加入到res中</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll t, n, m;</span><br><span class="line">ll arr[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; t; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                cin &gt;&gt; arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= n; ++j) &#123; <span class="comment">//一次几个</span></span><br><span class="line">                set&lt;vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt;  s;</span><br><span class="line">                <span class="keyword">for</span>(ll k = <span class="number">0</span>; k &lt; n; ++k) &#123; <span class="comment">//从哪里开始</span></span><br><span class="line">                    vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; v;</span><br><span class="line">                    <span class="keyword">if</span>(k + j &lt;= n) &#123;</span><br><span class="line">                        <span class="keyword">for</span>(ll h = <span class="number">0</span>; h &lt; j; ++h) &#123;</span><br><span class="line">                            v.<span class="built_in">push_back</span>(arr[k + h]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(v.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">                        s.<span class="built_in">insert</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">                res += s.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(m == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(ll j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                cin &gt;&gt; arr[j];</span><br><span class="line">                arr[j] *= m;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">            <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                vector&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">                <span class="keyword">for</span>(ll j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">                    num.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(ll j = i; j &lt; n; ++j)</span><br><span class="line">                    num.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">                v.<span class="built_in">push_back</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;v的size &quot; &lt;&lt; v.size() &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">for</span>(ll a = <span class="number">0</span>; a &lt; v.<span class="built_in">size</span>(); ++a) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(ll j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                        arr[j] += v[a][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= n; ++j) &#123; <span class="comment">//一次几个</span></span><br><span class="line">                        set&lt;vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt;  s;</span><br><span class="line">                        <span class="keyword">for</span>(ll k = <span class="number">0</span>; k &lt; n; ++k) &#123; <span class="comment">//从哪里开始</span></span><br><span class="line">                            vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ve;</span><br><span class="line">                            <span class="keyword">if</span>(k + j &lt;= n) &#123;</span><br><span class="line">                                <span class="keyword">for</span>(ll h = <span class="number">0</span>; h &lt; j; ++h) &#123;</span><br><span class="line">                                    ve.<span class="built_in">push_back</span>(arr[k + h]);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span>(ve.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">                                s.<span class="built_in">insert</span>(ve);</span><br><span class="line">                        &#125;</span><br><span class="line">                        res += s.<span class="built_in">size</span>();</span><br><span class="line">                        res %= <span class="number">998244353</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//消除增加值的影响</span></span><br><span class="line">                    <span class="keyword">for</span>(ll j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                        arr[j] -= v[a][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span>(<span class="built_in">next_permutation</span>(v[a].<span class="built_in">begin</span>(), v[a].<span class="built_in">end</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;可怜有一个数组 &lt;em&gt;A&lt;/em&gt;，定义它的复杂度 &lt;em&gt;c&lt;/em&gt;(&lt;em&gt;A&lt;/em&gt;) 等于它本质不同的子区间个数。举例来说，&lt;em&gt;c&lt;/em&gt;([1,1,1])=3，因为 [1,1,1] 只有 3 个本质不同</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-14 森森旅游 (30 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/21/7-14%20%E6%A3%AE%E6%A3%AE%E6%97%85%E6%B8%B8%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/21/7-14%20%E6%A3%AE%E6%A3%AE%E6%97%85%E6%B8%B8%20(30%20%E5%88%86)/</id>
    <published>2022-01-21T02:02:23.513Z</published>
    <updated>2022-01-21T02:34:32.609Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>好久没出去旅游啦！森森决定去 Z 省旅游一下。</p><p>Z 省有 <em>n</em> 座城市（从 1 到 <em>n</em> 编号）以及 <em>m</em> 条连接两座城市的有向旅行线路（例如自驾、长途汽车、火车、飞机、轮船等），每次经过一条旅行线路时都需要支付该线路的费用（但这个收费标准可能不止一种，例如车票跟机票一般不是一个价格）。</p><p>Z 省为了鼓励大家在省内多逛逛，推出了<strong>旅游金计划</strong>：在 <em>i</em> 号城市可以用 1 元现金兑换 <em>a**i</em> 元旅游金（只要现金足够，可以无限次兑换）。城市间的交通即可以使用现金支付路费，也可以用旅游金支付。具体来说，当通过第 <em>j</em> 条旅行线路时，可以用 <em>c**j</em> 元现金<strong>或</strong> <em>d**j</em> 元旅游金支付路费。<strong>注意：</strong> 每次只能选择一种支付方式，不可同时使用现金和旅游金混合支付。但对于不同的线路，旅客可以自由选择不同的支付方式。</p><p>森森决定从 1 号城市出发，到 <em>n</em> 号城市去。他打算在出发前准备一些现金，并在途中的某个城市将剩余现金 <strong>全部</strong> 换成旅游金后继续旅游，直到到达 <em>n</em> 号城市为止。当然，他也可以选择在 1 号城市就兑换旅游金，或全部使用现金完成旅程。</p><p>Z 省政府会根据每个城市参与活动的情况调整汇率（即调整在某个城市 1 元现金能换多少旅游金）。现在你需要帮助森森计算一下，在每次调整之后最少需要携带多少现金才能完成他的旅程。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在第一行给出三个整数 <em>n</em>，<em>m</em> 与 <em>q</em>（1≤<em>n</em>≤105，1≤<em>m</em>≤2×105，1≤<em>q</em>≤105），依次表示城市的数量、旅行线路的数量以及汇率调整的次数。</p><p>接下来 <em>m</em> 行，每行给出四个整数 <em>u</em>，<em>v</em>，<em>c</em> 与 <em>d</em>（1≤<em>u</em>,<em>v</em>≤<em>n</em>，1≤<em>c</em>,<em>d</em>≤109），表示一条从 <em>u</em> 号城市通向 <em>v</em> 号城市的有向旅行线路。每次通过该线路需要支付 <em>c</em> 元现金或 <em>d</em> 元旅游金。数字间以空格分隔。输入保证从 1 号城市出发，一定可以通过若干条线路到达 <em>n</em> 号城市，但两城市间的旅行线路可能不止一条，对应不同的收费标准；也允许在城市内部游玩（即 <em>u</em> 和 <em>v</em> 相同）。</p><p>接下来的一行输入 <em>n</em> 个整数 <em>a</em>1,<em>a</em>2,⋯,<em>a**n</em>（1≤<em>a**i</em>≤109），其中 <em>a**i</em> 表示一开始在 <em>i</em> 号城市能用 1 元现金兑换 <em>a**i</em> 个旅游金。数字间以空格分隔。</p><p>接下来 <em>q</em> 行描述汇率的调整。第 <em>i</em> 行输入两个整数 <em>x**i</em> 与 <em>a**i</em>′（1≤<em>x**i</em>≤<em>n</em>，1≤<em>a**i</em>′≤109），表示第 <em>i</em> 次汇率调整后，<em>x**i</em> 号城市能用 1 元现金兑换 <em>a**i</em>′ 个旅游金，而其它城市旅游金汇率不变。<strong>请注意：</strong>每次汇率调整都是在上一次汇率调整的基础上进行的。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每一次汇率调整，在对应的一行中输出调整后森森至少需要准备多少现金，才能按他的计划从 1 号城市旅行到 <em>n</em> 号城市。</p><p><strong>再次提醒：</strong>如果森森决定在途中的某个城市兑换旅游金，那么他必须将剩余现金<strong>全部、一次性</strong>兑换，剩下的旅途将完全使用旅游金支付。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">11</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">8</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">10</span> <span class="number">8</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">10</span> <span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">10</span> <span class="number">12</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">10</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">5</span> <span class="number">100</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">17</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释:"></a>样例解释:</h3><p>对于第一次汇率调整，森森可以沿着 1→2→4→6 的线路旅行，并在 2 号城市兑换旅游金；</p><p>对于第二次汇率调整，森森可以沿着 1→2→3→4→6 的线路旅行，并在 3 号城市兑换旅游金；</p><p>对于第三次汇率调整，森森可以沿着 1→3→5→6 的线路旅行，并在 1 号城市兑换旅游金。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    不亏是L3的题，就是不会。参考的柳神（柳婼）的代码。</p><p>​    整体来讲是Dijstra，只是参数量变多了，而且需要一次正向，一次反向。</p><ol><li>使用现金从城市1出发，计算到达所有城市的最小花费，保存在dis1中</li><li>使用旅游金从城市n出发，计算到达所有城市的最小花费，保存在dis2中</li><li>这样我们枚举所有的中转点，得到在第i个城市将现金换成旅游金的情况下需要的现金总额，即从城市1到达城市i的现金加上从城市n到达城市i的旅游金除以城市i的汇率，就可以得到在城市i兑换所需要的总现金费用，保存在cost[i]中</li><li>big[i]存储城市i的汇率</li><li>注意最后的总现金费用保存在multiset,因为可能会出现两条及两条以上最优路线，更改汇率后，在multiset删除cost[i]的值，然后插入新的计算值 </li></ol><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//注意由于是long long 所以用long long的最大值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF LLONG_MAX</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> big[<span class="number">100005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dis;</span><br><span class="line">    <span class="comment">//这个地方很新奇，以前没遇见过，运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">int</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.dis &gt; b.dis; <span class="comment">//注意这是递减排序，但sort反向</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; cost1[<span class="number">100005</span>]; <span class="comment">//存储现金支付</span></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; cost2[<span class="number">100005</span>]; <span class="comment">//存储现旅游金支付</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis1[<span class="number">100005</span>], dis2[<span class="number">1000005</span>]; <span class="comment">//正反向的遍历</span></span><br><span class="line"><span class="comment">//优先队列的Dijstra</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> s,vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; cost[],<span class="keyword">long</span> <span class="keyword">long</span> dis[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> visited[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">fill</span>(dis + <span class="number">1</span>,dis + n + <span class="number">1</span>,INF);</span><br><span class="line">    <span class="comment">//源点到源点距离为0</span></span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;Node&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(Node&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = qu.<span class="built_in">top</span>().id;</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(visited[t])  <span class="keyword">continue</span>;</span><br><span class="line">        visited[t] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)cost[t].<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> v = cost[t][i].first,w = cost[t][i].second;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[t] + w)&#123;</span><br><span class="line">                dis[v] = dis[t] + w;</span><br><span class="line">                qu.<span class="built_in">push</span>(Node&#123;v,dis[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a, b, c, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">        <span class="comment">//正向和反向各存一遍</span></span><br><span class="line">        cost1[a].<span class="built_in">push_back</span>(&#123;b, c&#125;);</span><br><span class="line">        cost2[b].<span class="built_in">push_back</span>(&#123;a, d&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;big[i]);</span><br><span class="line">    <span class="comment">//正反向计算最短路</span></span><br><span class="line">    <span class="built_in">dijstra</span>(<span class="number">1</span>,cost1,dis1);</span><br><span class="line">    <span class="built_in">dijstra</span>(n,cost2,dis2);</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">cost</span><span class="params">(n + <span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    multiset&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s;</span><br><span class="line">    <span class="comment">//如果没有路，就不插入，否则就计算总现金花费，注意要向上取整</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">       <span class="keyword">if</span>(dis1[i] == INF || dis2[i] == INF)    <span class="keyword">continue</span>;</span><br><span class="line">       s.<span class="built_in">insert</span>(cost[i] = dis1[i] + <span class="built_in">ceil</span>(<span class="number">1.0</span> * dis2[i] / big[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//看看修改汇率的城市是否有路或者汇率不变</span></span><br><span class="line">        <span class="keyword">if</span>(cost[a] != <span class="number">0</span> &amp;&amp; b != big[a])&#123;</span><br><span class="line">            big[a] = b;</span><br><span class="line">            <span class="comment">/*这里是multiset，直接删除值的话，会删除对应值的所有元素，所以只能删除传一个迭代器，删除一个元素*/</span></span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(cost[a]));</span><br><span class="line">            s.<span class="built_in">insert</span>(cost[a] = dis1[a] + <span class="built_in">ceil</span>(<span class="number">1.0</span> * dis2[a] / big[a]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,*s.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;好久没出去旅游啦！森森决定去 Z 省旅游一下。&lt;/p&gt;
&lt;p&gt;Z 省有 &lt;em&gt;n&lt;/em&gt; 座城市（从 1 到 &lt;em&gt;n&lt;/em&gt; 编号）以及 &lt;em&gt;m&lt;/em&gt; 条连接两座城市的有向旅行线路（例如自驾、长途汽车、火车</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-13 社交集群 (30 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/20/7-13%20%E7%A4%BE%E4%BA%A4%E9%9B%86%E7%BE%A4%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/20/7-13%20%E7%A4%BE%E4%BA%A4%E9%9B%86%E7%BE%A4%20(30%20%E5%88%86)/</id>
    <published>2022-01-20T15:34:56.047Z</published>
    <updated>2022-01-20T15:57:16.240Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>当你在社交网络平台注册时，一般总是被要求填写你的个人兴趣爱好，以便找到具有相同兴趣爱好的潜在的朋友。一个“社交集群”是指部分兴趣爱好相同的人的集合。你需要找出所有的社交集群。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数 N（≤1000），为社交网络平台注册的所有用户的人数。于是这些人从 1 到 N 编号。随后 N 行，每行按以下格式给出一个人的兴趣爱好列表：</p><p><em>K**i</em>: <em>h**i</em>[1] <em>h**i</em>[2] … <em>h**i</em>[<em>K**i</em>]</p><p>其中<em>K**i</em>(&gt;0)是兴趣爱好的个数，<em>h**i</em>[<em>j</em>]是第<em>j</em>个兴趣爱好的编号，为区间 [1, 1000] 内的整数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出不同的社交集群的个数。随后第二行按非增序输出每个集群中的人数。数字间以一个空格分隔，行末不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">3</span>: <span class="number">2</span> <span class="number">7</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span>: <span class="number">4</span></span><br><span class="line"><span class="number">2</span>: <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>: <span class="number">4</span></span><br><span class="line"><span class="number">1</span>: <span class="number">3</span></span><br><span class="line"><span class="number">1</span>: <span class="number">4</span></span><br><span class="line"><span class="number">4</span>: <span class="number">6</span> <span class="number">8</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    虽然知道是并查集，但我还是应付不过一点点的改变，代码我改的不太优雅，从网上发现一种特别好的解法</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">10001</span>],arr[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[s] == s) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">return</span> father[s] = <span class="built_in">Find</span>(father[s]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root1 = <span class="built_in">Find</span>(a),root2 = <span class="built_in">Find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(root1 != root2)  father[root2] = root1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i)</span><br><span class="line">        father[i] = i;</span><br><span class="line">    <span class="comment">/*将每个人首个兴趣存入数组，用来代表人，然后他的其他兴趣都已第一个兴趣为根*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> k,t;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        cin &gt;&gt; k &gt;&gt; c &gt;&gt; arr[i];</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            <span class="built_in">Union</span>(arr[i],t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后用map存每个集合的人数，map的元素个数是集合的数量</span></span><br><span class="line">    <span class="comment">/*因为每个人用首个兴趣代替，只要找到每个人首个兴趣所属的集合，就等于给人确定了集合*/</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">Find</span>(arr[i]);</span><br><span class="line">        m[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//注意最后的集合人数可能会重复，所以用multiset,反向遍历</span></span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        s.<span class="built_in">insert</span>(it -&gt; second);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = s.<span class="built_in">rbegin</span>(); it != s.<span class="built_in">rend</span>(); it++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>        flag = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;当你在社交网络平台注册时，一般总是被要求填写你的个人兴趣爱好，以便找到具有相同兴趣爱好的潜在的朋友。一个“社交集群”是指部分兴趣爱好相同的人的集合。你需要找出所有的社交集群。&lt;/p&gt;
&lt;h3 id=&quot;输入格式：&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-12 红色警报 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/20/7-12%20%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%8A%A5%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/20/7-12%20%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%8A%A5%20(25%20%E5%88%86)/</id>
    <published>2022-01-20T14:04:46.882Z</published>
    <updated>2022-01-20T14:50:23.077Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出两个整数<code>N</code>（0 &lt; <code>N</code> ≤ 500）和<code>M</code>（≤ 5000），分别为城市个数（于是默认城市从0到<code>N</code>-1编号）和连接两城市的通路条数。随后<code>M</code>行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数<code>K</code>和随后的<code>K</code>个被攻占的城市的编号。</p><p>注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个被攻占的城市，如果它会改变整个国家的连通性，则输出<code>Red Alert: City k is lost!</code>，其中<code>k</code>是该城市的编号；否则只输出<code>City k is lost.</code>即可。如果该国失去了最后一个城市，则增加一行输出<code>Game Over.</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">City <span class="number">1</span> is lost.</span><br><span class="line">City <span class="number">2</span> is lost.</span><br><span class="line">Red Alert: City <span class="number">0</span> is lost!</span><br><span class="line">City <span class="number">4</span> is lost.</span><br><span class="line">City <span class="number">3</span> is lost.</span><br><span class="line">Game Over.</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    两种思路，一种dfs，一种并查集</p><p>​    自己想到的是dfs，可能上课讲的时候就是由dfs或者bfs求连通分量数所以想到的是dfs，并查集当时没想到，看到网上的题解后才意识到可以。</p><p>​    题目简单来说就是计算连通分支数，如果删除结点后，连通分支数的增量超过1,说明删除结点后使得其他某个结点也变得不联通，此时改变了整体的连通性，所以发出警报。其中如果删除了最后一座城市，则输出Game Over.</p><p>​    好像dfs要比并查集快得多</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; mar;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> visited[<span class="number">501</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    visited[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mar[s].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[mar[s][i]])</span><br><span class="line">            <span class="built_in">dfs</span>(mar[s][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    mar.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        mar[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        mar[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, k;</span><br><span class="line">    <span class="comment">//就算最初的连通分支数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="comment">//初始化visited数组</span></span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="comment">//将删除的结点存储数组，并标记为已访问，防止dfs时作为中间结点</span></span><br><span class="line">        v.<span class="built_in">push_back</span>(t);</span><br><span class="line">        <span class="comment">//连通分支数首先初始化为已经删除结点的个数</span></span><br><span class="line">        <span class="keyword">int</span> num2 = v.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            visited[v[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算连通分支数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j]) &#123;</span><br><span class="line">                num2++;</span><br><span class="line">                <span class="built_in">dfs</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果增量超过1，则发出红色警报</span></span><br><span class="line">        <span class="keyword">if</span>(num2 &gt; num + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Red Alert: City %d is lost!\n&quot;</span>, t);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;City %d is lost.\n&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新连通分支数</span></span><br><span class="line">        num = num2;</span><br><span class="line">        <span class="comment">//判断是否是最后一个结点</span></span><br><span class="line">        <span class="keyword">if</span>(i == n - <span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">&quot;Game Over.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, m,k,flag;</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">501</span>],mar[<span class="number">501</span>][<span class="number">501</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x] == <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> father[x] = <span class="built_in">Find</span>(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root1 = <span class="built_in">Find</span>(a),root2 = <span class="built_in">Find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(root1 != root2)</span><br><span class="line">        father[root2] = root1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountPart</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(father[i] == <span class="number">-1</span>) num++;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(father,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(father));</span><br><span class="line">    <span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        mar[a][b] = mar[b][a] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">Union</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算连通分支数</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">CountPart</span>();</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="comment">//判断最后是否需要输出Game Over</span></span><br><span class="line">    <span class="keyword">if</span>(k == n)  flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="keyword">int</span> t,num2 = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="comment">//初始化并查集</span></span><br><span class="line">        <span class="built_in">memset</span>(father,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(father));</span><br><span class="line">        <span class="comment">//删除结点连接的所有路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  </span><br><span class="line">            mar[t][i] = mar[i][t] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//更新并查集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; ++j)</span><br><span class="line">                <span class="keyword">if</span>(mar[i][j])   <span class="built_in">Union</span>(i,j);</span><br><span class="line">        <span class="comment">//计算新的连通分支数</span></span><br><span class="line">        num2 = <span class="built_in">CountPart</span>();</span><br><span class="line">        <span class="keyword">if</span>(num2 &gt; num + <span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">&quot;Red Alert: City %d is lost!\n&quot;</span>, t);</span><br><span class="line">        <span class="keyword">else</span>                <span class="built_in">printf</span>(<span class="string">&quot;City %d is lost.\n&quot;</span>, t);</span><br><span class="line">        num = num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)    <span class="built_in">printf</span>(<span class="string">&quot;Game Over.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-11 小字辈 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/20/7-11%20%E5%B0%8F%E5%AD%97%E8%BE%88%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/20/7-11%20%E5%B0%8F%E5%AD%97%E8%BE%88%20(25%20%E5%88%86)/</id>
    <published>2022-01-20T13:18:40.112Z</published>
    <updated>2022-01-20T13:58:09.215Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>本题给定一个庞大家族的家谱，要请你给出最小一辈的名单。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出家族人口总数 N（不超过 100 000 的正整数） —— 简单起见，我们把家族成员从 1 到 N 编号。随后第二行给出 N 个编号，其中第 i 个编号对应第 i 位成员的父/母。家谱中辈分最高的老祖宗对应的父/母编号为 -1。一行中的数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先输出最小的辈分（老祖宗的辈分为 1，以下逐级递增）。然后在第二行按递增顺序输出辈分最小的成员的编号。编号间以一个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">5</span> <span class="number">5</span> <span class="number">-1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">4</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    看到了这题，突然想起了我数据结构月考题，小字辈（加强版），为啥当时给我出个加强版那么难的题。。。（我不理解）</p><p>​    并查集的一种改编，不能压缩路径，但需要计算结点所在的高度</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">100001</span>],level[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果已经计算过了，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(level[s])    <span class="keyword">return</span> level[s];</span><br><span class="line">    <span class="comment">//如果是根节点，然后赋值后返回1</span></span><br><span class="line">    <span class="keyword">if</span>(father[s] == <span class="number">-1</span>) <span class="keyword">return</span> level[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//没有计算并且不是根节点，在其父亲的辈分上+1</span></span><br><span class="line">    <span class="keyword">return</span> level[s] = <span class="built_in">Find</span>(father[s]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(father,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(father));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; father[i];</span><br><span class="line">    <span class="comment">//找父亲，别压缩路径，这样辈分就乱了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">Find</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后找辈分中最小的（相当于数值最大的）</span></span><br><span class="line">    <span class="keyword">int</span> maxnum = *<span class="built_in">max_element</span>(level + <span class="number">1</span>,level + <span class="number">1</span> + n);</span><br><span class="line">    cout &lt;&lt; maxnum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//然后依次遍历辈分数组，找到最小辈分就输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(level[i] == maxnum)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span>        flag = <span class="number">1</span>;</span><br><span class="line">            cout &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;本题给定一个庞大家族的家谱，要请你给出最小一辈的名单。&lt;/p&gt;
&lt;h3 id=&quot;输入格式：&quot;&gt;&lt;a href=&quot;#输入格式：&quot; class=&quot;headerlink&quot; title=&quot;输入格式：&quot;&gt;&lt;/a&gt;输入格式：&lt;/h3&gt;&lt;</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-10 列车调度 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/20/7-10%20%E5%88%97%E8%BD%A6%E8%B0%83%E5%BA%A6%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/20/7-10%20%E5%88%97%E8%BD%A6%E8%B0%83%E5%BA%A6%20(25%20%E5%88%86)/</id>
    <published>2022-01-20T13:06:59.995Z</published>
    <updated>2022-01-20T13:17:39.844Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>火车站的列车调度铁轨的结构如下图所示。</p><p><img src="https://images.ptausercontent.com/188" alt="img"></p><p>两端分别是一条入口（Entrance）轨道和一条出口（Exit）轨道，它们之间有<code>N</code>条平行的轨道。每趟列车从入口可以选择任意一条轨道进入，最后从出口离开。在图中有9趟列车，在入口处按照{8，4，2，5，3，9，1，6，7}的顺序排队等待进入。如果要求它们必须按序号递减的顺序从出口离开，则至少需要多少条平行铁轨用于调度？</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个整数<code>N</code> (2 ≤ <code>N</code> ≤105)，下一行给出从1到<code>N</code>的整数序号的一个重排列。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出可以将输入的列车按序号递减的顺序调离所需要的最少的铁轨条数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span> <span class="number">9</span> <span class="number">1</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    lower_bound()是大于等于，upper_bound是大于</p><p>​    如果想让列车降序输出，必须在同一条隧道上，编号大的先进入，编号小的后进入。</p><p>​    如果一条隧道新加入的车的编号比隧道里最小的编号还要小的的话，只能新开一个隧道，所以我们只需要记录隧道当前最小的编号即可。</p><p>​    我们采用upper_bound找到第一个比新加入的车大的编号，修改这个隧道的最小编号即可。</p><p>​    最后容器里有几个元素，就最少需要几个隧道</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="comment">//找第一个比t大的元素删除</span></span><br><span class="line">        <span class="keyword">auto</span> it = s.<span class="built_in">upper_bound</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(it != s.<span class="built_in">end</span>())</span><br><span class="line">            s.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="comment">//插入编号t</span></span><br><span class="line">        s.<span class="built_in">insert</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;火车站的列车调度铁轨的结构如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.ptausercontent.com/188&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;两端分别是一条入口（Entrance</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-8 古风排版 (20 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/20/7-8%20%E5%8F%A4%E9%A3%8E%E6%8E%92%E7%89%88%20(20%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/20/7-8%20%E5%8F%A4%E9%A3%8E%E6%8E%92%E7%89%88%20(20%20%E5%88%86)/</id>
    <published>2022-01-20T12:38:26.576Z</published>
    <updated>2022-01-21T03:35:17.425Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>中国的古人写文字，是从右向左竖向排版的。本题就请你编写程序，把一段文字按古风排版。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（&lt;100），是每一列的字符数。第二行给出一个长度不超过1000的非空字符串，以回车结束。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按古风格式排版给定的字符串，每列<em>N</em>个字符（除了最后一列可能不足<em>N</em>个）。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line">This is a test <span class="keyword">case</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asa T</span><br><span class="line">st ih</span><br><span class="line">e tsi</span><br><span class="line"> ce s</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    算是一种模拟吧，首先题目给出每列的字符数（即行数），我们可以根据读取的字符串计算出列数（注意向上取整），然后在字符串的末尾补空格。</p><p>​    然后写出输出的下标得出规律</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>s.size() - k</td><td>s.size() - 2 * k</td><td>….</td><td>0</td><td></td></tr><tr><td>….</td><td>….</td><td>….</td><td>1</td><td></td></tr><tr><td>s.size() - 2</td><td>s.size() - (k +2)</td><td>….</td><td>….</td><td></td></tr><tr><td>s.size() - 1</td><td>s.size() - (k + 1)</td><td>….</td><td>k - 1</td><td></td></tr></tbody></table><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">ceil</span>(<span class="number">1.0</span> * s.<span class="built_in">size</span>() / m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>(); i &lt; m * n;++i)</span><br><span class="line">        s = s + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">//m为行，n为列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;   <span class="comment">//打印m行</span></span><br><span class="line">        <span class="comment">//第i行的第一个为s.size()-m+i,最后一个为i,步长为m</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = -m + i; -j &lt;= s.<span class="built_in">size</span>(); j -= m)&#123;</span><br><span class="line">            cout &lt;&lt; s[s.<span class="built_in">size</span>() + j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    cin &gt;&gt; row;</span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="comment">//读取行数，计算列数</span></span><br><span class="line">    <span class="keyword">int</span> col = <span class="built_in">ceil</span>(<span class="number">1.0</span> * s.<span class="built_in">size</span>() / row);</span><br><span class="line">    vector&lt;<span class="keyword">char</span>&gt; ve[col];</span><br><span class="line">    <span class="comment">//然后按照从最后一列的第一行一次向下存储，读到最后一行，列数减一</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = col - <span class="number">1</span>; i &lt; (<span class="keyword">int</span>)s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        ve[j].<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span>((i + <span class="number">1</span>) % row == <span class="number">0</span>)</span><br><span class="line">            j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在第一列进行补0，补到容器大小和行数相同</span></span><br><span class="line">    <span class="keyword">while</span>((<span class="keyword">int</span>)ve[<span class="number">0</span>].<span class="built_in">size</span>() != row)</span><br><span class="line">        ve[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="comment">//行数不同，列数移动，然后接着打印下一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)</span><br><span class="line">            cout &lt;&lt; ve[j][i];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;中国的古人写文字，是从右向左竖向排版的。本题就请你编写程序，把一段文字按古风排版。&lt;/p&gt;
&lt;h3 id=&quot;输入格式：&quot;&gt;&lt;a href=&quot;#输入格式：&quot; class=&quot;headerlink&quot; title=&quot;输入格式：&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-9 拯救007 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/18/7-10%20%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/18/7-10%20%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%20(25%20%E5%88%86)/</id>
    <published>2022-01-18T03:47:39.895Z</published>
    <updated>2022-01-18T03:49:48.076Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>分而治之，各个击破是兵家常用的策略之一。在战争中，我们希望首先攻下敌方的部分城市，使其剩余的城市变成孤立无援，然后再分头各个击破。为此参谋部提供了若干打击方案。本题就请你编写程序，判断每个方案的可行性。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出两个正整数 N 和 M（均不超过10 000），分别为敌方城市个数（于是默认城市从 1 到 N 编号）和连接两城市的通路条数。随后 M 行，每行给出一条通路所连接的两个城市的编号，其间以一个空格分隔。在城市信息之后给出参谋部的系列方案，即一个正整数 K （≤ 100）和随后的 K 行方案，每行按以下格式给出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Np v[1] v[2] ... v[Np]</span><br></pre></td></tr></table></figure><p>其中 <code>Np</code> 是该方案中计划攻下的城市数量，后面的系列 <code>v[i]</code> 是计划攻下的城市编号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每一套方案，如果可行就输出<code>YES</code>，否则输出<code>NO</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">11</span></span><br><span class="line"><span class="number">8</span> <span class="number">7</span></span><br><span class="line"><span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">8</span> <span class="number">4</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">10</span> <span class="number">3</span> <span class="number">8</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span> <span class="number">4</span> <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">8</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    和图着色一样，暴力枚举，如果边的两个端点都没有被访问过，这一定不是割集</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">100001</span>];</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; g[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[g[i].x] &amp;&amp; !visited[g[i].y])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        cin &gt;&gt; g[i].x &gt;&gt; g[i].y;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="literal">false</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">        <span class="keyword">int</span> num,x;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        <span class="keyword">while</span>(num--)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            visited[x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Judge</span>()) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 9999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; mar;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    mar.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        mar[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        mar[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="keyword">int</span> num,t;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            v[i] = i;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; se;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i)&#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            v[t] = <span class="number">0</span>;</span><br><span class="line">            se.<span class="built_in">insert</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; flag; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i] == <span class="number">0</span>)   <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mar[v[i]].<span class="built_in">size</span>() &amp;&amp; flag; ++j)&#123;</span><br><span class="line">                se.<span class="built_in">insert</span>(mar[v[i]][j]);</span><br><span class="line">                <span class="keyword">if</span>(se.<span class="built_in">size</span>() != num)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    flag = <span class="number">0</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;分而治之，各个击破是兵家常用的策略之一。在战争中，我们希望首先攻下敌方的部分城市，使其剩余的城市变成孤立无援，然后再分头各个击破。为此参谋部提供了若干打击方案。本题就请你编写程序，判断每个方案的可行性。&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-9 拯救007 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/18/7-9%20%E6%8B%AF%E6%95%91007%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/18/7-9%20%E6%8B%AF%E6%95%91007%20(25%20%E5%88%86)/</id>
    <published>2022-01-18T03:29:11.881Z</published>
    <updated>2022-01-18T03:47:21.229Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>在老电影“007之生死关头”（Live and Let Die）中有一个情节，007被毒贩抓到一个鳄鱼池中心的小岛上，他用了一种极为大胆的方法逃脱 —— 直接踩着池子里一系列鳄鱼的大脑袋跳上岸去！（据说当年替身演员被最后一条鳄鱼咬住了脚，幸好穿的是特别加厚的靴子才逃过一劫。）</p><p>设鳄鱼池是长宽为100米的方形，中心坐标为 (0, 0)，且东北角坐标为 (50, 50)。池心岛是以 (0, 0) 为圆心、直径15米的圆。给定池中分布的鳄鱼的坐标、以及007一次能跳跃的最大距离，你需要告诉他是否有可能逃出生天。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>首先第一行给出两个正整数：鳄鱼数量 <em>N</em>（≤100）和007一次能跳跃的最大距离 <em>D</em>。随后 <em>N</em> 行，每行给出一条鳄鱼的 (<em>x</em>,<em>y</em>) 坐标。注意：不会有两条鳄鱼待在同一个点上。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如果007有可能逃脱，就在一行中输出”Yes”，否则输出”No”。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span> <span class="number">20</span></span><br><span class="line"><span class="number">25</span> <span class="number">-15</span></span><br><span class="line"><span class="number">-25</span> <span class="number">28</span></span><br><span class="line"><span class="number">8</span> <span class="number">49</span></span><br><span class="line"><span class="number">29</span> <span class="number">15</span></span><br><span class="line"><span class="number">-35</span> <span class="number">-2</span></span><br><span class="line"><span class="number">5</span> <span class="number">28</span></span><br><span class="line"><span class="number">27</span> <span class="number">-29</span></span><br><span class="line"><span class="number">-8</span> <span class="number">-28</span></span><br><span class="line"><span class="number">-20</span> <span class="number">-35</span></span><br><span class="line"><span class="number">-25</span> <span class="number">-20</span></span><br><span class="line"><span class="number">-13</span> <span class="number">29</span></span><br><span class="line"><span class="number">-30</span> <span class="number">15</span></span><br><span class="line"><span class="number">-35</span> <span class="number">40</span></span><br><span class="line"><span class="number">12</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="number">-12</span> <span class="number">12</span></span><br><span class="line"><span class="number">12</span> <span class="number">12</span></span><br><span class="line"><span class="number">-12</span> <span class="number">-12</span></span><br><span class="line"><span class="number">12</span> <span class="number">-12</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    深度优先搜索</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,d,flag;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">&#125;node[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> visited[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断是否能够到岸</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">50</span> - <span class="built_in">abs</span>(node[s].x)&lt;= d || <span class="number">50</span> - <span class="built_in">abs</span>(node[s].y) &lt;= d)&#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//然后遍历看看能跳到的路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="built_in">pow</span>(node[s].x - node[i].x ,<span class="number">2</span>) + <span class="built_in">pow</span>(node[s].y - node[i].y,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(!visited[i] &amp;&amp;sum &lt;= d * d) </span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; node[i].x &gt;&gt; node[i].y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; !flag; ++i)&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="built_in">pow</span>(node[i].x,<span class="number">2</span>) + <span class="built_in">pow</span>(node[i].y,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum &lt;= <span class="built_in">pow</span>((<span class="number">15</span> + d),<span class="number">2</span>))    <span class="built_in">dfs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,d,answer;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> r = <span class="number">15</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">&#125;node[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsSafe</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[pos].x - d &lt;= <span class="number">-50</span> || node[pos].x + d &gt;= <span class="number">50</span> || node[pos].y - d &lt;= <span class="number">-50</span> || node[pos].y + d &gt;= <span class="number">50</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstJudge</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pow</span>(node[pos].x,<span class="number">2</span>) + <span class="built_in">pow</span>(node[pos].y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(d + r / <span class="number">2</span>,<span class="number">2</span>))  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Jump</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> next)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">pow</span>(node[cur].x - node[next].x,<span class="number">2</span>) + <span class="built_in">pow</span>(node[cur].y - node[next].y,<span class="number">2</span>) &lt;= d * d )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    node[pos].flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsSafe</span>(pos))   answer = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!node[i].flag &amp;&amp; <span class="built_in">Jump</span>(pos,i))</span><br><span class="line">                answer = <span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(answer)  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Save</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node[i].flag &amp;&amp; <span class="built_in">FirstJudge</span>(i))&#123;</span><br><span class="line">            answer = <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(answer) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; node[i].x &gt;&gt; node[i].y;</span><br><span class="line">    <span class="built_in">Save</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;在老电影“007之生死关头”（Live and Let Die）中有一个情节，007被毒贩抓到一个鳄鱼池中心的小岛上，他用了一种极为大胆的方法逃脱 —— 直接踩着池子里一系列鳄鱼的大脑袋跳上岸去！（据说当年替身演员被最后一条</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-8 图着色问题 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/18/7-8%20%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/18/7-8%20%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98%20(25%20%E5%88%86)/</id>
    <published>2022-01-18T03:25:34.066Z</published>
    <updated>2022-01-18T03:28:53.880Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>图着色问题是一个著名的NP完全问题。给定无向图<em>G</em>=(<em>V</em>,<em>E</em>)，问可否用<em>K</em>种颜色为<em>V</em>中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具有同一种颜色？</p><p>但本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出3个整数<em>V</em>（0&lt;<em>V</em>≤500）、<em>E</em>（≥0）和<em>K</em>（0&lt;<em>K</em>≤<em>V</em>），分别是无向图的顶点数、边数、以及颜色数。顶点和颜色都从1到<em>V</em>编号。随后<em>E</em>行，每行给出一条边的两个端点的编号。在图的信息给出之后，给出了一个正整数<em>N</em>（≤20），是待检查的颜色分配方案的个数。随后<em>N</em>行，每行顺次给出<em>V</em>个顶点的颜色（第<em>i</em>个数字表示第<em>i</em>个顶点的颜色），数字间以空格分隔。题目保证给定的无向图是合法的（即不存在自回路和重边）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每种颜色分配方案，如果是图着色问题的一个解则输出<code>Yes</code>，否则输出<code>No</code>，每句占一行。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">8</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    暴力枚举</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> v, e, k;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; mar;</span><br><span class="line"><span class="keyword">int</span> col[<span class="number">501</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e &gt;&gt; k;</span><br><span class="line">    mar.<span class="built_in">resize</span>(v + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= e; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        mar[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        mar[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="comment">//利用set判断颜色数，如果颜色数不等，则直接是No</span></span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; ++i)&#123;</span><br><span class="line">            cin &gt;&gt; col[i];</span><br><span class="line">            s.<span class="built_in">insert</span>(col[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() != k)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后遍历各个结点，判断结点连出边的端点是否颜色相同</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v &amp;&amp; flag;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mar[i].<span class="built_in">size</span>() &amp;&amp; flag; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(col[i] == col[mar[i][j]])&#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)  cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line">PII g[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> v,e,k,n;</span><br><span class="line">cin&gt;&gt;v&gt;&gt;e&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e;i++)&#123;</span><br><span class="line">cin&gt;&gt;g[i].x&gt;&gt;g[i].y;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">1</span>,color[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=v;i++)&#123;</span><br><span class="line">cin&gt;&gt;color[i];</span><br><span class="line">s.<span class="built_in">insert</span>(color[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">size</span>()!=k) flag=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历边，看看端点是否颜色相同</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;e;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(color[g[i].x]==color[g[i].y])&#123;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;图着色问题是一个著名的NP完全问题。给定无向图&lt;em&gt;G&lt;/em&gt;=(&lt;em&gt;V&lt;/em&gt;,&lt;em&gt;E&lt;/em&gt;)，问可否用&lt;em&gt;K&lt;/em&gt;种颜色为&lt;em&gt;V&lt;/em&gt;中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-7 城市间紧急救援 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/18/7-7%20%E5%9F%8E%E5%B8%82%E9%97%B4%E7%B4%A7%E6%80%A5%E6%95%91%E6%8F%B4%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/18/7-7%20%E5%9F%8E%E5%B8%82%E9%97%B4%E7%B4%A7%E6%80%A5%E6%95%91%E6%8F%B4%20(25%20%E5%88%86)/</id>
    <published>2022-01-18T03:18:09.577Z</published>
    <updated>2022-01-18T03:25:25.169Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任务是带领你的救援队尽快赶往事发地，同时，一路上召集尽可能多的救援队。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第一行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0 ~ (<em>N</em>−1)；<em>M</em>是快速道路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。</p><p>第二行给出<em>N</em>个正整数，其中第<em>i</em>个数是第<em>i</em>个城市的救援队的数目，数字间以空格分隔。随后的<em>M</em>行中，每行给出一条快速道路的信息，分别是：城市1、城市2、快速道路的长度，中间用空格分开，数字均为整数且不超过500。输入保证救援可行且最优解唯一。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>第一行输出最短路径的条数和能够召集的最多的救援队数量。第二行输出从<em>S</em>到<em>D</em>的路径中经过的城市编号。数字间以空格分隔，输出结尾不能有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">60</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    dijstra的一个改编版，需要多计算最短的路径数</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 9999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N, M, S, D;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">501</span>][<span class="number">501</span>], num[<span class="number">501</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[N], visted[N], pre[N],cnt[N],val[N];</span><br><span class="line">    <span class="built_in">memset</span>(visted, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visted));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">    <span class="comment">//初始化距离，救援队总量和路径数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        dis[i] = mar[s][i];</span><br><span class="line">        val[i] = num[i];</span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visted[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> minnum = inf, pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visted[j] &amp;&amp; dis[j] &lt; minnum) &#123;</span><br><span class="line">                pos = j;</span><br><span class="line">                minnum = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        visted[pos] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="comment">/*如果能够更新路径，则修改它的前驱结点，路径数等于新加入点的路径数，救援队总量等于新加入点的总量和该点的数量*/</span></span><br><span class="line">            <span class="keyword">if</span>(!visted[j] &amp;&amp; dis[j] &gt; dis[pos] + mar[pos][j]) &#123;</span><br><span class="line">                dis[j] = dis[pos] + mar[pos][j];</span><br><span class="line">                pre[j] = pos;</span><br><span class="line">                cnt[j] = cnt[pos];</span><br><span class="line">                val[j] = val[pos] + num[j];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!visted[j] &amp;&amp; dis[j] == dis[pos] + mar[pos][j])&#123;</span><br><span class="line">                <span class="comment">/*如果长度相同，则路径数加上新加入点的路径数，看看是否需要更新救援队总量*/</span></span><br><span class="line">                cnt[j] += cnt[pos];</span><br><span class="line">                <span class="keyword">if</span>(val[j] &lt; val[pos] + num[j])&#123;</span><br><span class="line">                    val[j] = val[pos] + num[j];</span><br><span class="line">                    pre[j] = pos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">int</span> end = D;</span><br><span class="line">    <span class="keyword">while</span>(end != <span class="number">-1</span>) &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(end);</span><br><span class="line">        end = pre[end];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出路径数和救援队数量，这里需要加上源点的数量</span></span><br><span class="line">    cout &lt;&lt; cnt[D] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; val[D] + num[S] &lt;&lt; endl;</span><br><span class="line">   <span class="comment">//输出源点</span></span><br><span class="line">    cout &lt;&lt; S;</span><br><span class="line">    <span class="comment">//进行弹栈</span></span><br><span class="line">    <span class="keyword">while</span>(st.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; D;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span> ; i &lt; N ; ++i)</span><br><span class="line">        cin &gt;&gt; num[i];</span><br><span class="line">    <span class="built_in">memset</span>(mar, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mar));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        mar[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        mar[a][b] = mar[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijstra</span>(S);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-6 功夫传人 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/18/7-6%20%E5%8A%9F%E5%A4%AB%E4%BC%A0%E4%BA%BA%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/18/7-6%20%E5%8A%9F%E5%A4%AB%E4%BC%A0%E4%BA%BA%20(25%20%E5%88%86)/</id>
    <published>2022-01-18T03:14:52.770Z</published>
    <updated>2022-01-18T03:17:58.660Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>一门武功能否传承久远并被发扬光大，是要看缘分的。一般来说，师傅传授给徒弟的武功总要打个折扣，于是越往后传，弟子们的功夫就越弱…… 直到某一支的某一代突然出现一个天分特别高的弟子（或者是吃到了灵丹、挖到了特别的秘笈），会将功夫的威力一下子放大N倍 —— 我们称这种弟子为“得道者”。</p><p>这里我们来考察某一位祖师爷门下的徒子徒孙家谱：假设家谱中的每个人只有1位师傅（除了祖师爷没有师傅）；每位师傅可以带很多徒弟；并且假设辈分严格有序，即祖师爷这门武功的每个第<code>i</code>代传人只能在第<code>i-1</code>代传人中拜1个师傅。我们假设已知祖师爷的功力值为<code>Z</code>，每向下传承一代，就会减弱<code>r%</code>，除非某一代弟子得道。现给出师门谱系关系，要求你算出所有得道者的功力总值。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出3个正整数，分别是：<em>N</em>（≤105）——整个师门的总人数（于是每个人从0到<em>N</em>−1编号，祖师爷的编号为0）；<em>Z</em>——祖师爷的功力值（不一定是整数，但起码是正数）；<em>r</em> ——每传一代功夫所打的折扣百分比值（不超过100的正数）。接下来有<em>N</em>行，第<em>i</em>行（<em>i</em>=0,⋯,<em>N</em>−1）描述编号为<em>i</em>的人所传的徒弟，格式为：</p><p><em>K**i</em> ID[1] ID[2] ⋯ ID[<em>K**i</em>]</p><p>其中<em>K**i</em>是徒弟的个数，后面跟的是各位徒弟的编号，数字间以空格间隔。<em>K**i</em>为零表示这是一位得道者，这时后面跟的一个数字表示其武功被放大的倍数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出所有得道者的功力总值，只保留其整数部分。题目保证输入和正确的输出都不超过1010。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">18.0</span> <span class="number">1.00</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span></span><br><span class="line"><span class="number">0</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">8</span></span><br><span class="line"><span class="number">0</span> <span class="number">9</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">404</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    太菜了，当时没想到是深度优先搜索，因为得道者因为k = 0,所以得道者一定是叶子节点，所以只需要从根节点进行深度优先搜索，把所有分支返回的结果进行相加即可</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> z,r;</span><br><span class="line"><span class="comment">//存储放大倍数</span></span><br><span class="line"><span class="keyword">int</span> big[<span class="number">100001</span>];</span><br><span class="line"><span class="comment">//存储孩子结点</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; child;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(child[x].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> big[x] * z * <span class="built_in">pow</span>(r,t);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; child[x].<span class="built_in">size</span>(); ++i)</span><br><span class="line">            ans += <span class="built_in">dfs</span>(child[x][i],t + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; z &gt;&gt; r;</span><br><span class="line">    child.<span class="built_in">resize</span>(n);</span><br><span class="line">    r = <span class="number">1</span> - <span class="number">0.01</span> * r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> k,t;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            big[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            child[i].<span class="built_in">push_back</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;一门武功能否传承久远并被发扬光大，是要看缘分的。一般来说，师傅传授给徒弟的武功总要打个折扣，于是越往后传，弟子们的功夫就越弱…… 直到某一支的某一代突然出现一个天分特别高的弟子（或者是吃到了灵丹、挖到了特别的秘笈），会将功夫</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>【2022寒假萌新训练-3】7-7 点赞狂魔</title>
    <link href="http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-7%20%E7%82%B9%E8%B5%9E%E7%8B%82%E9%AD%94/"/>
    <id>http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-7%20%E7%82%B9%E8%B5%9E%E7%8B%82%E9%AD%94/</id>
    <published>2022-01-17T03:12:17.000Z</published>
    <updated>2022-01-18T03:14:47.400Z</updated>
    
    <content type="html"><![CDATA[<p>微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。然而有这么一种人，他们会通过给自己看到的一切内容点赞来狂刷存在感，这种人就被称为“点赞狂魔”。他们点赞的标签非常分散，无法体现出明显的特性。本题就要求你写个程序，通过统计每个人点赞的不同标签的数量，找出前3名点赞狂魔。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤100），是待统计的用户数。随后<em>N</em>行，每行列出一位用户的点赞标签。格式为“<code>Name</code> <em>K</em> <em>F</em>1⋯<em>FK</em>”，其中<code>Name</code>是不超过8个英文小写字母的非空用户名，1≤<em>K</em>≤1000，<em>Fi</em>（<em>i</em>=1,⋯,<em>K</em>）是特性标签的编号，我们将所有特性标签从 1 到 10^7 编号。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>统计每个人点赞的不同标签的数量，找出数量最大的前3名，在一行中顺序输出他们的用户名,其间以1个空格分隔,且行末不得有多余空格。如果有并列，则输出标签出现次数平均值最小的那个，题目保证这样的用户没有并列。若不足3人，则用<code>-</code>补齐缺失，例如<code>mike jenny -</code>就表示只有2人。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">bob 11 101 102 103 104 105 106 107 108 108 107 107</span><br><span class="line">peter 8 1 2 3 4 3 2 5 1</span><br><span class="line">chris 12 1 2 3 4 5 6 7 8 9 1 2 3</span><br><span class="line">john 10 8 7 6 5 4 3 2 1 7 5</span><br><span class="line">jack 9 6 7 8 9 10 11 12 13 14</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jack chris john</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    根据题意，要名字，不同标签的数量以及标签出现次数平均值，存储的元素挺多，可以采用结构体。</p><ul><li>名字直接读取</li><li>不同标签的数量可以利用set不存储重复元素的特性得到</li><li>标签出现的平均次数可以等价于，如果存在并列，则他们不同标签的数量num一定是相同的，平均次数为k / num,此时谁的k值小，谁的平均次数就小,所以只需要比较k值就好</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="comment">//num为不同标签的数量，cnt记录总次数，其实就是k</span></span><br><span class="line">    <span class="keyword">int</span> num, cnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.num != b.num)</span><br><span class="line">        <span class="keyword">return</span> a.num &gt; b.num;</span><br><span class="line">    <span class="keyword">return</span> a.cnt &lt; b.cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    Node node[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; node[i].name;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="comment">//利用set不存储重复元素的特性得到不同标签的数量</span></span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            s.<span class="built_in">insert</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        node[i].num = s.<span class="built_in">size</span>();</span><br><span class="line">        node[i].cnt = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(node, node + n, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n) cout &lt;&lt; node[i].name;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。然而有这么一种人，他们会通过给自己看到的一切内容点赞来狂刷存在感，这种人就被称为“点赞狂魔”。他们点赞的标签非常分散，无法体现出明显的特</summary>
      
    
    
    
    <category term="2022寒假萌新程序设计训练" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/"/>
    
    <category term="2022寒假萌新训练-3" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3/"/>
    
    
    <category term="STL,sort" scheme="http://wangxu1905.github.io/tags/STL-sort/"/>
    
  </entry>
  
  <entry>
    <title>【2022寒假萌新训练-3】7-6 树种统计</title>
    <link href="http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-6%20%E6%A0%91%E7%A7%8D%E7%BB%9F%E8%AE%A1/"/>
    <id>http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-6%20%E6%A0%91%E7%A7%8D%E7%BB%9F%E8%AE%A1/</id>
    <published>2022-01-17T02:55:11.000Z</published>
    <updated>2022-01-18T03:14:40.555Z</updated>
    
    <content type="html"><![CDATA[<p>随着卫星成像技术的应用，自然资源研究机构可以识别每一棵树的种类。请编写程序帮助研究人员统计每种树的数量，计算每种树占总数的百分比。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入首先给出正整数N（≤10^5），随后N行，每行给出卫星观测到的一棵树的种类名称。种类名称由不超过30个英文字母和空格组成（大小写不区分）。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按字典序递增输出各种树的种类名称及其所占总数的百分比，其间以空格分隔，保留小数点后4位。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">29</span><br><span class="line">Red Alder</span><br><span class="line">Ash</span><br><span class="line">Aspen</span><br><span class="line">Basswood</span><br><span class="line">Ash</span><br><span class="line">Beech</span><br><span class="line">Yellow Birch</span><br><span class="line">Ash</span><br><span class="line">Cherry</span><br><span class="line">Cottonwood</span><br><span class="line">Ash</span><br><span class="line">Cypress</span><br><span class="line">Red Elm</span><br><span class="line">Gum</span><br><span class="line">Hackberry</span><br><span class="line">White Oak</span><br><span class="line">Hickory</span><br><span class="line">Pecan</span><br><span class="line">Hard Maple</span><br><span class="line">White Oak</span><br><span class="line">Soft Maple</span><br><span class="line">Red Oak</span><br><span class="line">Red Oak</span><br><span class="line">White Oak</span><br><span class="line">Poplan</span><br><span class="line">Sassafras</span><br><span class="line">Sycamore</span><br><span class="line">Black Walnut</span><br><span class="line">Willow</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Ash 13.7931%</span><br><span class="line">Aspen 3.4483%</span><br><span class="line">Basswood 3.4483%</span><br><span class="line">Beech 3.4483%</span><br><span class="line">Black Walnut 3.4483%</span><br><span class="line">Cherry 3.4483%</span><br><span class="line">Cottonwood 3.4483%</span><br><span class="line">Cypress 3.4483%</span><br><span class="line">Gum 3.4483%</span><br><span class="line">Hackberry 3.4483%</span><br><span class="line">Hard Maple 3.4483%</span><br><span class="line">Hickory 3.4483%</span><br><span class="line">Pecan 3.4483%</span><br><span class="line">Poplan 3.4483%</span><br><span class="line">Red Alder 3.4483%</span><br><span class="line">Red Elm 3.4483%</span><br><span class="line">Red Oak 6.8966%</span><br><span class="line">Sassafras 3.4483%</span><br><span class="line">Soft Maple 3.4483%</span><br><span class="line">Sycamore 3.4483%</span><br><span class="line">White Oak 10.3448%</span><br><span class="line">Willow 3.4483%</span><br><span class="line">Yellow Birch 3.4483%</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    根据题意，统计树的种类和它的占比，采用map存储，根据map的自动排序，string直接是按照字典序进行排序，我们只需要遍历输出即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    map&lt;string, <span class="keyword">int</span>&gt; book;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="built_in">getline</span>(cin, str);</span><br><span class="line">        book[str]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = book.<span class="built_in">begin</span>(); it != book.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %.4f%%\n&quot;</span>, it -&gt; first.<span class="built_in">c_str</span>(), (<span class="keyword">float</span>)it -&gt; second / n * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;随着卫星成像技术的应用，自然资源研究机构可以识别每一棵树的种类。请编写程序帮助研究人员统计每种树的数量，计算每种树占总数的百分比。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式:&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="2022寒假萌新程序设计训练" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/"/>
    
    <category term="2022寒假萌新训练-3" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3/"/>
    
    
    <category term="map容器" scheme="http://wangxu1905.github.io/tags/map%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【2022寒假萌新训练-3】7-5 点赞</title>
    <link href="http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-5%20%E7%82%B9%E8%B5%9E/"/>
    <id>http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-5%20%E7%82%B9%E8%B5%9E/</id>
    <published>2022-01-17T02:36:40.000Z</published>
    <updated>2022-01-18T03:14:33.310Z</updated>
    
    <content type="html"><![CDATA[<p>微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。本题就要求你写个程序，通过统计一个人点赞的纪录，分析这个人的特性。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数<em>N</em>（≤1000），是该用户点赞的博文数量。随后<em>N</em>行，每行给出一篇被其点赞的博文的特性描述，格式为“<em>K</em> <em>F</em>1⋯<em>FK</em>”，其中1≤<em>K</em>≤10，<em>Fi</em>（<em>i</em>=1,⋯,<em>K</em>）是特性标签的编号，我们将所有特性标签从1到1000编号。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>统计所有被点赞的博文中最常出现的那个特性标签，在一行中输出它的编号和出现次数，数字间隔1个空格。如果有并列，则输出编号最大的那个。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3 889 233 2</span><br><span class="line">5 100 3 233 2 73</span><br><span class="line">4 3 73 889 2</span><br><span class="line">2 233 123</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">233 3</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    和7-4 天梯赛的善良的一样，需要记录两个值，一个值为特征描述值，一个值为出现的次数，可以采用map存储。</p><p>​    最后输出出现次数最大的特征值中编号最大的，可以采用map反向遍历（从大的特征值开始遍历），max1记录特征值，max2记录出现的次数，只要找到比max2大的，就更新max1和max2，最后输出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k, t;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            m[t]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//max1记录特征值，max2记录出现的次数</span></span><br><span class="line">    <span class="keyword">int</span> max1 = <span class="number">0</span>, max2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m.<span class="built_in">rbegin</span>(); it != m.<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(it -&gt; second &gt; max2) &#123;</span><br><span class="line">            max1 = it -&gt; first;</span><br><span class="line">            max2 = it -&gt; second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; max1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; max2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。本题就要求你写个程序，通过统计一个人点赞的纪录，分析这个人的特性。&lt;/p&gt;
&lt;h3 id=&quot;输入格式：&quot;&gt;&lt;a href=&quot;#输入格式：</summary>
      
    
    
    
    <category term="2022寒假萌新程序设计训练" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/"/>
    
    <category term="2022寒假萌新训练-3" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3/"/>
    
    
    <category term="map容器" scheme="http://wangxu1905.github.io/tags/map%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【2022寒假萌新训练-3】7-4 天梯赛的善良</title>
    <link href="http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-4%20%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%9A%84%E5%96%84%E8%89%AF/"/>
    <id>http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-4%20%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%9A%84%E5%96%84%E8%89%AF/</id>
    <published>2022-01-17T02:26:25.000Z</published>
    <updated>2022-01-18T03:14:26.164Z</updated>
    
    <content type="html"><![CDATA[<p>天梯赛是个善良的比赛。善良的命题组希望将题目难度控制在一个范围内，使得每个参赛的学生都有能做出来的题目，并且最厉害的学生也要非常努力才有可能得到高分。</p><p>于是命题组首先将编程能力划分成了 10^6个等级（太疯狂了，这是假的），然后调查了每个参赛学生的编程能力。现在请你写个程序找出所有参赛学生的最小和最大能力值，给命题组作为出题的参考。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出一个正整数 <em>N</em>（≤2×10^4），即参赛学生的总数。随后一行给出 <em>N</em> 个不超过 10^6 的正整数，是参赛学生的能力值。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>第一行输出所有参赛学生的最小能力值，以及具有这个能力值的学生人数。第二行输出所有参赛学生的最大能力值，以及具有这个能力值的学生人数。同行数字间以 1 个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">86 75 233 888 666 75 886 888 75 666</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">75 3</span><br><span class="line">888 2</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    根据题意，要找出最小和最大能力值已经相应的人数，要记录的是能力值和人数，可以采用map存储，利用map的自动排序，map的第一个元素就是最小能力值和人数，最后一个元素就是最大能力值和人数。</p><p>​    rbegin()返回的是一个反向迭代器，指向的是map的最后一个元素。</p><p>​    不采用end()是因为end()返回的是map最后一个元素<strong>之后</strong>的地址。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        m[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">begin</span>() -&gt; first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m.<span class="built_in">begin</span>() -&gt; second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">rbegin</span>() -&gt; first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m.<span class="built_in">rbegin</span>() -&gt; second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;天梯赛是个善良的比赛。善良的命题组希望将题目难度控制在一个范围内，使得每个参赛的学生都有能做出来的题目，并且最厉害的学生也要非常努力才有可能得到高分。&lt;/p&gt;
&lt;p&gt;于是命题组首先将编程能力划分成了 10^6个等级（太疯狂了，这是假的），然后调查了每个参赛学生的编程能力。现</summary>
      
    
    
    
    <category term="2022寒假萌新程序设计训练" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/"/>
    
    <category term="2022寒假萌新训练-3" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3/"/>
    
    
    <category term="map容器" scheme="http://wangxu1905.github.io/tags/map%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【2022寒假萌新训练-3】7-3 素数对猜想</title>
    <link href="http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-3%20%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"/>
    <id>http://wangxu1905.github.io/2022/01/17/%E3%80%902022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3%E3%80%917-3%20%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/</id>
    <published>2022-01-17T02:11:25.000Z</published>
    <updated>2022-01-18T03:14:19.219Z</updated>
    
    <content type="html"><![CDATA[<p>7-3 素数对猜想 (20 分)</p><p>让我们定义<em>dn</em>为：<em>dn</em>=<em>pn</em>+1−<em>pn</em>，其中<em>pi</em>是第<em>i</em>个素数。显然有<em>d</em>1=1，且对于<em>n</em>&gt;1有<em>dn</em>是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p><p>现给定任意正整数<code>N</code>(&lt;10^5)，请计算不超过<code>N</code>的满足猜想的素数对的个数。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行给出正整数<code>N</code>。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出不超过<code>N</code>的满足猜想的素数对的个数。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>​    套用判断素数的模板，然后遍历从2~n，判断的是数字i和数字i + 2是否同时为素数即可，同时为素数则ans++</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsPrime</span>(i) &amp;&amp; <span class="built_in">IsPrime</span>(i + <span class="number">2</span>))</span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;7-3 素数对猜想 (20 分)&lt;/p&gt;
&lt;p&gt;让我们定义&lt;em&gt;dn&lt;/em&gt;为：&lt;em&gt;dn&lt;/em&gt;=&lt;em&gt;pn&lt;/em&gt;+1−&lt;em&gt;pn&lt;/em&gt;，其中&lt;em&gt;pi&lt;/em&gt;是第&lt;em&gt;i&lt;/em&gt;个素数。显然有&lt;em&gt;d&lt;/em&gt;1=1，且对于&lt;em&gt;n&lt;/e</summary>
      
    
    
    
    <category term="2022寒假萌新程序设计训练" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/"/>
    
    <category term="2022寒假萌新训练-3" scheme="http://wangxu1905.github.io/categories/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AE%AD%E7%BB%83/2022%E5%AF%92%E5%81%87%E8%90%8C%E6%96%B0%E8%AE%AD%E7%BB%83-3/"/>
    
    
    <category term="素数" scheme="http://wangxu1905.github.io/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
</feed>
