<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moon</title>
  
  
  <link href="http://wangxu1905.github.io/atom.xml" rel="self"/>
  
  <link href="http://wangxu1905.github.io/"/>
  <updated>2022-03-23T03:46:24.241Z</updated>
  <id>http://wangxu1905.github.io/</id>
  
  <author>
    <name>Moon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>7-21 三足鼎立 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/23/7-21%20%E4%B8%89%E8%B6%B3%E9%BC%8E%E7%AB%8B%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/23/7-21%20%E4%B8%89%E8%B6%B3%E9%BC%8E%E7%AB%8B%20(25%20%E5%88%86)/</id>
    <published>2022-03-23T03:12:16.003Z</published>
    <updated>2022-03-23T03:46:24.241Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>当三个国家中的任何两国实力之和都大于第三国的时候，这三个国家互相结盟就呈“三足鼎立”之势，这种状态是最稳定的。</p><p>现已知本国的实力值，又给出 <em>n</em> 个其他国家的实力值。我们需要从这 <em>n</em> 个国家中找 2 个结盟，以成三足鼎立。有多少种选择呢？</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先在第一行给出 2 个正整数 <em>n</em>（2≤<em>n</em>≤105）和 <em>P</em>（≤109），分别为其他国家的个数、以及本国的实力值。随后一行给出 <em>n</em> 个正整数，表示<em>n</em> 个其他国家的实力值。每个数值不超过 109，数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出本国结盟选择的个数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">30</span></span><br><span class="line"><span class="number">42</span> <span class="number">16</span> <span class="number">2</span> <span class="number">51</span> <span class="number">92</span> <span class="number">27</span> <span class="number">35</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="样例解释："><a href="#样例解释：" class="headerlink" title="样例解释："></a>样例解释：</h3><p>能联合的另外 2 个国家的 9 种选择分别为：</p><p>{16, 27}, {16, 35}, {16, 42}, {27, 35}, {27, 42}, {27, 51}, {35, 42}, {35, 51}, {42, 51}。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    试过暴力，超时了。改用二分,先排序</p><p>​    其实就是三角形，两个短边之和要大于长边。记本国实力值为a,分成二种情况</p><p>​    因为遍历的时候，直接记ve[i]为b,所以a,b已知，求解c的范围</p><ul><li><p>a是长边，b + c &gt; a,即c &gt; a - b,b &lt; a,c &lt; a</p></li><li><p>a是短边，b或者c是长边(两者等价)，看我们把谁定义成b,c了</p><p>a + b &gt; c,c &gt; a,c &gt; b</p></li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n, a, res = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ve</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; n; ++i)  cin &gt;&gt; ve[i];</span><br><span class="line">    <span class="built_in">sort</span>(ve.<span class="built_in">begin</span>(), ve.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//a是长边</span></span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ve[i] &gt; a)   <span class="keyword">break</span>;</span><br><span class="line">        ll b = ve[i];</span><br><span class="line">        <span class="comment">//找第一个符合的</span></span><br><span class="line">        <span class="keyword">auto</span> it1 = <span class="built_in">upper_bound</span>(ve.<span class="built_in">begin</span>() + i + <span class="number">1</span>, ve.<span class="built_in">end</span>(), a - b);</span><br><span class="line">        <span class="comment">//c也要大于a,为了防止b,c重复，则只能往b的后方找</span></span><br><span class="line">        <span class="keyword">auto</span> it2 = <span class="built_in">lower_bound</span>(ve.<span class="built_in">begin</span>() + i + <span class="number">1</span>, ve.<span class="built_in">end</span>(), a);</span><br><span class="line">        res += it2 - it1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//c是长边</span></span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ll b = ve[i];</span><br><span class="line">        <span class="comment">//找第一个不符合的</span></span><br><span class="line">        <span class="keyword">auto</span> it1 = <span class="built_in">lower_bound</span>(ve.<span class="built_in">begin</span>() + i + <span class="number">1</span>, ve.<span class="built_in">end</span>(), a + b);</span><br><span class="line">        <span class="comment">//找a,b中最大的，因为c &gt; a,c &gt; b</span></span><br><span class="line">        <span class="keyword">auto</span> it2 = <span class="built_in">lower_bound</span>(ve.<span class="built_in">begin</span>() + i + <span class="number">1</span>, ve.<span class="built_in">end</span>(), <span class="built_in">max</span>(a, b));</span><br><span class="line">        res += it1 - it2;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;当三个国家中的任何两国实力之和都大于第三国的时候，这三个国家互相结盟就呈“三足鼎立”之势，这种状态是最稳定的。&lt;/p&gt;
&lt;p&gt;现已知本国的实力值，又给出 &lt;em&gt;n&lt;/em&gt; 个其他国家的实力值。我们需要从这 &lt;em&gt;n&lt;/</summary>
      
    
    
    
    
    <category term="天梯赛" scheme="http://wangxu1905.github.io/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    
    <category term="二分" scheme="http://wangxu1905.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>7-20 最小生成树的唯一性 (35 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/23/7-20%20%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%20(35%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/23/7-20%20%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%20(35%20%E5%88%86)/</id>
    <published>2022-03-23T02:57:02.249Z</published>
    <updated>2022-03-23T03:01:20.086Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>7-20 最小生成树的唯一性 (35 分)</p><p>给定一个带权无向图，如果是连通图，则至少存在一棵最小生成树，有时最小生成树并不唯一。本题就要求你计算最小生成树的总权重，并且判断其是否唯一。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>首先第一行给出两个整数：无向图中顶点数 <em>N</em>（≤500）和边数 <em>M</em>。随后 <em>M</em> 行，每行给出一条边的两个端点和权重，格式为“顶点1 顶点2 权重”，其中顶点从 1 到<em>N</em> 编号，权重为正整数。题目保证最小生成树的总权重不会超过 230。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如果存在最小生成树，首先在第一行输出其总权重，第二行输出“Yes”，如果此树唯一，否则输出“No”。如果树不存在，则首先在第一行输出“No MST”，第二行输出图的连通集个数。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line">No</span><br></pre></td></tr></table></figure><h3 id="输入样例-3："><a href="#输入样例-3：" class="headerlink" title="输入样例 3："></a>输入样例 3：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-3："><a href="#输出样例-3：" class="headerlink" title="输出样例 3："></a>输出样例 3：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No MST</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    通过Kruskal进行求解，如果加入了a边，a的下一条边b，权重和a相同，并且b的端点和a的端点在两颗相同的树上，则最小生成树不具有唯一性</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125; e[<span class="number">5000050</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, f[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> edge &amp;a, <span class="keyword">const</span> edge &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] == <span class="number">-1</span>)  <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> f[x] = <span class="built_in">Find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="built_in">sort</span>(e, e + m, cmp);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> fa = <span class="built_in">Find</span>(e[i].u), fb = <span class="built_in">Find</span>(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(fa != fb) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>, fa1 = <span class="built_in">Find</span>(e[j].u), fb1 = <span class="built_in">Find</span>(e[j].v);</span><br><span class="line">            <span class="comment">//有两种情况</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; m &amp;&amp; e[j].w == e[i].w &amp;&amp; ((fa == fa1 &amp;&amp; fb == fb1) || (fa == fb1 &amp;&amp; fb == fa1)))</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">            res += e[i].w;</span><br><span class="line">            f[fb] = fa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(f[i] == <span class="number">-1</span>)  sum++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No MST&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;7-20 最小生成树的唯一性 (35 分)&lt;/p&gt;
&lt;p&gt;给定一个带权无向图，如果是连通图，则至少存在一棵最小生成树，有时最小生成树并不唯一。本题就要求你计算最小生成树的总权重，并且判断其是否唯一。&lt;/p&gt;
&lt;h3 id=&quot;</summary>
      
    
    
    
    
    <category term="天梯赛" scheme="http://wangxu1905.github.io/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    
    <category term="图论" scheme="http://wangxu1905.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最小生成树" scheme="http://wangxu1905.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
    <category term="Kruskal" scheme="http://wangxu1905.github.io/tags/Kruskal/"/>
    
  </entry>
  
  <entry>
    <title>7-17 堆的建立 (20 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/23/7-17%20%E5%A0%86%E7%9A%84%E5%BB%BA%E7%AB%8B%20(20%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/23/7-17%20%E5%A0%86%E7%9A%84%E5%BB%BA%E7%AB%8B%20(20%20%E5%88%86)/</id>
    <published>2022-03-23T02:33:36.770Z</published>
    <updated>2022-03-23T02:55:27.159Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>所谓“堆的建立”，是指将已经存在的N个元素调整成最大堆或最小堆。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行是一个整数N，表示元素的个数，N&lt;=10000。第二行N个元素的值。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出2行，第一行是输入序列调整为最大堆后的元素序列，元素之间用空格分开。第二行是输入序列调整为最小堆后的元素序列，元素之间用空格分开。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>在这里给出一组输入。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">5</span> <span class="number">8</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><p>在这里给出相应的输出。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">5</span> <span class="number">7</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">7</span> <span class="number">8</span> <span class="number">6</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​        和之前的堆建立不同，这个是全部存储后再调整（堆排序的调整方法）。</p><p>​    </p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, heap1[<span class="number">100001</span>], heap2[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    heap1[<span class="number">0</span>] = INT_MAX;</span><br><span class="line">    heap2[<span class="number">0</span>] = INT_MIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从第一个非叶结点开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> child;</span><br><span class="line">        <span class="comment">//向下调整，保证父亲的子树是堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> parent = i; parent &lt;= n / <span class="number">2</span>; parent = child) &#123;</span><br><span class="line">            child = parent * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(child + <span class="number">1</span> &lt;= n &amp;&amp; heap1[child] &lt; heap1[child + <span class="number">1</span>])   child += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(heap1[child] &gt; heap1[parent])</span><br><span class="line">                <span class="built_in">swap</span>(heap1[child],heap1[parent]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> child;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> parent = i; parent &lt;= n / <span class="number">2</span>; parent = child) &#123;</span><br><span class="line">            child = parent * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(child + <span class="number">1</span> &lt;= n &amp;&amp; heap2[child] &gt; heap2[child + <span class="number">1</span>])   child += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(heap2[child] &lt; heap2[parent])</span><br><span class="line">                <span class="built_in">swap</span>(heap2[child],heap2[parent]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">1</span>)   cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; heap1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">1</span>)   cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; heap2[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        heap1[i] = t;</span><br><span class="line">        heap2[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//附上一种偷懒写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="keyword">int</span> n, t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        ve.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ve1, ve2;</span><br><span class="line">    ve1 = ve, ve2 = ve;</span><br><span class="line">    <span class="built_in">make_heap</span>(ve1.<span class="built_in">begin</span>(), ve1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">make_heap</span>(ve2.<span class="built_in">begin</span>(), ve2.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve1.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i)   cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; ve1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve2.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i)   cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; ve2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;所谓“堆的建立”，是指将已经存在的N个元素调整成最大堆或最小堆。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式:&quot;&gt;&lt;/a&gt;输入格式:&lt;/h</summary>
      
    
    
    
    
    <category term="天梯赛" scheme="http://wangxu1905.github.io/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    
    <category term="堆" scheme="http://wangxu1905.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>Kruskal算法</title>
    <link href="http://wangxu1905.github.io/2022/03/21/Floyed%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84/"/>
    <id>http://wangxu1905.github.io/2022/03/21/Floyed%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84/</id>
    <published>2022-03-21T12:26:17.704Z</published>
    <updated>2022-03-21T12:28:01.432Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n, m, s, mar[<span class="number">501</span>][<span class="number">501</span>], dis[<span class="number">501</span>][<span class="number">501</span>], path[<span class="number">501</span>][<span class="number">501</span>];</span><br><span class="line"><span class="comment">//只打印中继结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = path[s][d];</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">PrintPath</span>(s, k);</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintPath</span>(k, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="comment">//path[i][j]的值为i，j的中继节点</span></span><br><span class="line">                <span class="keyword">if</span>(dis[i][j] &gt; dis[i][k] + dis[k][j]) &#123;</span><br><span class="line">                    dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">                    path[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//另外打印起点和终点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1 &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintPath</span>(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(mar, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mar));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(path, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(path));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        mar[i][i] = dis[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        mar[a][b] = mar[b][a] = c;</span><br><span class="line">        dis[a][b] = dis[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Floyd</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6 8</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment">1 3 3</span></span><br><span class="line"><span class="comment">2 3 1</span></span><br><span class="line"><span class="comment">3 5 4</span></span><br><span class="line"><span class="comment">3 4 2</span></span><br><span class="line"><span class="comment">4 5 4</span></span><br><span class="line"><span class="comment">1 6 0</span></span><br><span class="line"><span class="comment">2 6 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    
    <category term="图论" scheme="http://wangxu1905.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路" scheme="http://wangxu1905.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Kruskal算法</title>
    <link href="http://wangxu1905.github.io/2022/03/21/Kruskal%E7%AE%97%E6%B3%95/"/>
    <id>http://wangxu1905.github.io/2022/03/21/Kruskal%E7%AE%97%E6%B3%95/</id>
    <published>2022-03-21T11:29:50.204Z</published>
    <updated>2022-03-21T11:34:25.087Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>​    利用并查集实现判断有没有环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125; e[<span class="number">5050</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, f[<span class="number">5050</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] == <span class="number">-1</span>)  <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> f[x] = <span class="built_in">Find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//按边的权重进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(e, e + m, cmp);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> fa = <span class="built_in">Find</span>(e[i].u), fb = <span class="built_in">Find</span>(e[i].v);</span><br><span class="line">        <span class="comment">//如果没有环</span></span><br><span class="line">        <span class="keyword">if</span>(fa != fb) &#123;</span><br><span class="line">            sum += e[i].w;</span><br><span class="line">            f[fb] = fa;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == n - <span class="number">1</span>)    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;</span><br><span class="line">    <span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;​    利用并查集实现判断有没有环&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp</summary>
      
    
    
    
    
    <category term="图论" scheme="http://wangxu1905.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路" scheme="http://wangxu1905.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra堆优化</title>
    <link href="http://wangxu1905.github.io/2022/03/21/Dijkstra%E5%A0%86%E4%BC%98%E5%8C%96/"/>
    <id>http://wangxu1905.github.io/2022/03/21/Dijkstra%E5%A0%86%E4%BC%98%E5%8C%96/</id>
    <published>2022-03-21T11:17:36.422Z</published>
    <updated>2022-03-21T11:24:44.492Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>​    我们为了避免优先队列里面，有重复的二元组（即第二值相同，点相同），我们设置visited数组，来避免访问重复结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">int</span> n, m,s, dis[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">100010</span>];</span><br><span class="line">vector&lt;PII&gt; mar[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//别初始化，初始化，如果初始点是超级源点，则根本什么也更新不了</span></span><br><span class="line">    <span class="comment">/*3 3 0</span></span><br><span class="line"><span class="comment">      0 1 1</span></span><br><span class="line"><span class="comment">      0 2 3</span></span><br><span class="line"><span class="comment">      1 2 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*for(int i = 0; i &lt; mar[s].size(); ++i)</span></span><br><span class="line"><span class="comment">        dis[mar[s][i].x] = mar[s][i].y;*/</span></span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">top</span>().y;</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//为了防止重复访问结点</span></span><br><span class="line">        <span class="keyword">if</span>(visited[u])  <span class="keyword">continue</span>;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mar[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = mar[u][i].x, w = mar[u][i].y;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v] &amp;&amp; dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                qu.<span class="built_in">push</span>(&#123;dis[v], v&#125;);</span><br><span class="line">                cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        mar[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;​    我们为了避免优先队列里面，有重复的二元组（即第二值相同，点相同），我们设置visited数组，来避免访问重复结点。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td </summary>
      
    
    
    
    
    <category term="图论" scheme="http://wangxu1905.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路" scheme="http://wangxu1905.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>数据离散化</title>
    <link href="http://wangxu1905.github.io/2022/03/20/%E6%95%B0%E6%8D%AE%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <id>http://wangxu1905.github.io/2022/03/20/%E6%95%B0%E6%8D%AE%E7%A6%BB%E6%95%A3%E5%8C%96/</id>
    <published>2022-03-20T03:32:04.632Z</published>
    <updated>2022-03-20T03:44:24.382Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="一、unique函数（可处理重复元素）"><a href="#一、unique函数（可处理重复元素）" class="headerlink" title="一、unique函数（可处理重复元素）"></a>一、unique函数（可处理重复元素）</h3><p>unique是c++自带的一个函数，表示对一个数列去重，然后返回不重复的元素个数，当然在后面要减去首地址。</p><p>对brr排序去重，得到出不重复元素的个数，然后二分查找arr[i]的元素在brr中的位置，减去brr首地址即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">6</span>,arr[] = &#123;<span class="number">45</span>,<span class="number">6</span>,<span class="number">97</span>,<span class="number">35</span>,<span class="number">35</span>,<span class="number">2</span>&#125;,brr[] = &#123;<span class="number">45</span>,<span class="number">6</span>,<span class="number">97</span>,<span class="number">35</span>,<span class="number">35</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(brr,brr + n);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">unique</span>(brr,brr + n) - brr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; ++i) &#123;</span><br><span class="line">        arr[i] = <span class="built_in">lower_bound</span>(brr,brr + m,arr[i]) - brr;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、数组转换（不能处理重复元素）（不介绍了）"><a href="#二、数组转换（不能处理重复元素）（不介绍了）" class="headerlink" title="二、数组转换（不能处理重复元素）（不介绍了）"></a>二、数组转换（不能处理重复元素）（不介绍了）</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;一、unique函数（可处理重复元素）&quot;&gt;&lt;a href=&quot;#一、unique函数（可处理重复元素）&quot; class=&quot;headerlink&quot; title=&quot;一、unique函数（可处理重复元素）&quot;&gt;&lt;/a&gt;一、un</summary>
      
    
    
    
    
    <category term="离散化" scheme="http://wangxu1905.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Bellman-Ford算法和spfa算法</title>
    <link href="http://wangxu1905.github.io/2022/03/20/Bellman-Ford%E7%AE%97%E6%B3%95%E5%92%8Cspfa%E7%AE%97%E6%B3%95/"/>
    <id>http://wangxu1905.github.io/2022/03/20/Bellman-Ford%E7%AE%97%E6%B3%95%E5%92%8Cspfa%E7%AE%97%E6%B3%95/</id>
    <published>2022-03-20T02:12:43.009Z</published>
    <updated>2022-03-20T03:08:40.739Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="一、Bellman-Ford"><a href="#一、Bellman-Ford" class="headerlink" title="一、Bellman-Ford"></a>一、Bellman-Ford</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125; e[<span class="number">400010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> dis[n + <span class="number">1</span>],k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        e[++k].u = u,e[k].v = v,e[k].w = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = e[j].u,v = e[j].v,w = e[j].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + w)&#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(i == n - <span class="number">1</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)</span><br><span class="line">        cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(VE),V是顶点数，E是边数</li></ul><p>而Dijkstra的时间复杂度为O（V^2），显然如果是稠密图的话，Bellman-Ford要慢的多，但它可以判负权图</p><h3 id="二、spfa算法"><a href="#二、spfa算法" class="headerlink" title="二、spfa算法"></a>二、spfa算法</h3><p>spfa的算法是对于Bellman-Ford的算法一种改进</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w,fail;</span><br><span class="line">    <span class="built_in">edge</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> _v,<span class="keyword">int</span> _w,<span class="keyword">int</span> _fail)&#123;</span><br><span class="line">        v = _v,w = _w,fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[<span class="number">500050</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,s,len,head[<span class="number">500050</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[len] = <span class="built_in">edge</span>(v,w,head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[n + <span class="number">1</span>],visited[n + <span class="number">1</span>],in[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">fill</span>(dis,dis + n + <span class="number">1</span>,INT_MAX);</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    visited[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        visited[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].fail)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v,w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + w)&#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">                    qu.<span class="built_in">push</span>(v);</span><br><span class="line">                    visited[v] = <span class="number">1</span>;</span><br><span class="line">                    in[v]++;</span><br><span class="line">                    <span class="keyword">if</span>(in[v] &gt;= n)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)</span><br><span class="line">        cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;一、Bellman-Ford&quot;&gt;&lt;a href=&quot;#一、Bellman-Ford&quot; class=&quot;headerlink&quot; title=&quot;一、Bellman-Ford&quot;&gt;&lt;/a&gt;一、Bellman-Ford&lt;/h3&gt;</summary>
      
    
    
    
    
    <category term="图论" scheme="http://wangxu1905.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路" scheme="http://wangxu1905.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>L2-004 这是二叉搜索树吗？ (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/19/L2-004%20%E8%BF%99%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%90%97%EF%BC%9F%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/19/L2-004%20%E8%BF%99%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%90%97%EF%BC%9F%20(25%20%E5%88%86)/</id>
    <published>2022-03-19T13:11:05.514Z</published>
    <updated>2022-03-19T13:20:56.422Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>一棵二叉搜索树可被递归地定义为具有下列性质的二叉树：对于任一结点，</p><ul><li>其左子树中所有结点的键值小于该结点的键值；</li><li>其右子树中所有结点的键值大于等于该结点的键值；</li><li>其左右子树都是二叉搜索树。</li></ul><p>所谓二叉搜索树的“镜像”，即将所有结点的左右子树对换位置后所得到的树。</p><p>给定一个整数键值序列，现请你编写程序，判断这是否是对一棵二叉搜索树或其镜像进行前序遍历的结果。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入的第一行给出正整数 <em>N</em>（≤1000）。随后一行给出 <em>N</em> 个整数键值，其间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如果输入序列是对一棵二叉搜索树或其镜像进行前序遍历的结果，则首先在一行中输出 <code>YES</code> ，然后在下一行输出该树后序遍历的结果。数字间有 1 个空格，一行的首尾不得有多余空格。若答案是否，则输出 <code>NO</code>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span> <span class="number">6</span> <span class="number">5</span> <span class="number">7</span> <span class="number">10</span> <span class="number">8</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">11</span> <span class="number">10</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span> <span class="number">10</span> <span class="number">11</span> <span class="number">8</span> <span class="number">6</span> <span class="number">7</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line"><span class="number">11</span> <span class="number">8</span> <span class="number">10</span> <span class="number">7</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-3："><a href="#输入样例-3：" class="headerlink" title="输入样例 3："></a>输入样例 3：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span> <span class="number">6</span> <span class="number">8</span> <span class="number">5</span> <span class="number">10</span> <span class="number">9</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-3："><a href="#输出样例-3：" class="headerlink" title="输出样例 3："></a>输出样例 3：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​        根据二叉搜索树的性质，先序遍历的话，第一个结点是根节点，之后左子树若干个结点值都比它小，右子树的值都大于等于它，我们可以从前到后找左子树的边界，从后到前找右子树的边界，如果两个边界相差为1，那么则符合二叉搜索树的性质。</p><p>​    先序是根，左子树，右子树，我们可以按照特点，在最后把根节点放入post中</p><p>​        因为可能是镜像的原因，所以我们假如第一次得到不到结果，则按镜像跑第二次，如果都无解，则为NO，否则输出post</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> ismirror;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; pre,post;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> tail)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root &gt; tail) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = root + <span class="number">1</span>,j = tail;</span><br><span class="line">    <span class="keyword">if</span>(!ismirror)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= tail &amp;&amp; pre[i] &lt; pre[root])  i++;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; root &amp;&amp; pre[j] &gt;= pre[root]) j--;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= tail &amp;&amp; pre[i] &gt;= pre[root])  i++;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; root &amp;&amp; pre[j] &lt; pre[root]) j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i - j != <span class="number">1</span>)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">solve</span>(root + <span class="number">1</span>,i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">solve</span>(j + <span class="number">1</span>,tail);</span><br><span class="line">    post.<span class="built_in">push_back</span>(pre[root]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    pre.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  cin &gt;&gt; pre[i];</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(post.<span class="built_in">size</span>() != n)&#123;</span><br><span class="line">        post.<span class="built_in">clear</span>();</span><br><span class="line">        ismirror = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">solve</span>(<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(post.<span class="built_in">size</span>() != n) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; post.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i)   cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; post[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;一棵二叉搜索树可被递归地定义为具有下列性质的二叉树：对于任一结点，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其左子树中所有结点的键值小于该结点的键值；&lt;/li&gt;
&lt;li&gt;其右子树中所有结点的键值大于等于该结点的键值；&lt;/li&gt;
&lt;li&gt;其</summary>
      
    
    
    
    
    <category term="天梯赛" scheme="http://wangxu1905.github.io/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>C++ set_intersection等集合函数</title>
    <link href="http://wangxu1905.github.io/2022/03/19/C++%20set_intersection%E7%AD%89%E9%9B%86%E5%90%88%E5%87%BD%E6%95%B0/"/>
    <id>http://wangxu1905.github.io/2022/03/19/C++%20set_intersection%E7%AD%89%E9%9B%86%E5%90%88%E5%87%BD%E6%95%B0/</id>
    <published>2022-03-19T11:19:24.871Z</published>
    <updated>2022-03-19T13:11:33.032Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>C++ STL 提供</p><ul><li>求交集的函数 set_intersection( ) </li><li>求集合差的函数set_difference()</li><li>合并两个集合的函数set_union</li></ul><p>首先传递的容器必须是排序的，set容器中元素默认是排序的，而vector需要调用sort函数进行排序。其次set_intersection中最后存放交集的容器的容量必须要足够大到能放下所有的元素，即函数只执行复制，不是插入！<strong>但是模板insert_iterator可以将复制转换为插入，可以解决该问题。</strong>(好像inserter也行)</p><p>这些函数不是set的方法，而是通用函数。使用set时，可以自动忽略重复的元素，而使用vector时可以保留重复的元素，即保留‘个数’这一信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ve1,ve2,ve3;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) ve1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) ve2.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="comment">//set_union(ve1.begin(),ve1.end(),ve2.begin(),ve2.end(),inserter(ve3,ve3.begin()));</span></span><br><span class="line">    <span class="comment">//set_difference(ve1.begin(),ve1.end(),ve2.begin(),ve2.end(),inserter(ve3,ve3.begin()));</span></span><br><span class="line">    <span class="built_in">set_intersection</span>(ve1.<span class="built_in">begin</span>(),ve1.<span class="built_in">end</span>(),ve2.<span class="built_in">begin</span>(),ve2.<span class="built_in">end</span>(),<span class="built_in">inserter</span>(ve3,ve3.<span class="built_in">begin</span>()));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve3.<span class="built_in">size</span>(); ++i) cout &lt;&lt; ve3[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;C++ STL 提供&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;求交集的函数 set_intersection( ) &lt;/li&gt;
&lt;li&gt;求集合差的函数set_difference()&lt;/li&gt;
&lt;li&gt;合并两个集合的函数set_union</summary>
      
    
    
    
    
    <category term="C++" scheme="http://wangxu1905.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>L2-036 网红点打卡攻略 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/19/L2-036%20%E7%BD%91%E7%BA%A2%E7%82%B9%E6%89%93%E5%8D%A1%E6%94%BB%E7%95%A5%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/19/L2-036%20%E7%BD%91%E7%BA%A2%E7%82%B9%E6%89%93%E5%8D%A1%E6%94%BB%E7%95%A5%20(25%20%E5%88%86)/</id>
    <published>2022-03-19T03:46:52.550Z</published>
    <updated>2022-03-19T03:53:24.943Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>首先第一行给出两个正整数：网红点的个数 <em>N</em>（1&lt;<em>N</em>≤200）和网红点之间通路的条数 <em>M</em>。随后 <em>M</em> 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 <em>N</em> 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 <code>0</code>。</p><p>再下一行给出一个正整数 <em>K</em>，是待检验的攻略的数量。随后 <em>K</em> 行，每行给出一条待检攻略，格式为：</p><p><em>n</em> <em>V</em>1 <em>V</em>2 ⋯ <em>V**n</em></p><p>其中 <em>n</em>(≤200) 是攻略中的网红点数，<em>V**i</em> 是路径上的网红点编号。这里假设你从家里出发，从 <em>V</em>1 开始打卡，最后从 <em>V**n</em> 回家。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在第一行输出满足要求的攻略的个数。</p><p>在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。</p><p>题目保证至少存在一个有效攻略，并且总路费不超过 109。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">13</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">6</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">6</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">6</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">8</span> <span class="number">6</span> <span class="number">2</span> <span class="number">1</span> <span class="number">6</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><h3 id="样例说明："><a href="#样例说明：" class="headerlink" title="样例说明："></a>样例说明：</h3><p>第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。</p><p>第 1 条攻略的总路费是：(0-&gt;5) 2 + (5-&gt;1) 2 + (1-&gt;4) 2 + (4-&gt;3) 2 + (3-&gt;6) 2 + (6-&gt;2) 2 + (2-&gt;0) 2 = 14；</p><p>第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 = 11，是一条更省钱的攻略；</p><p>第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 = 11，与第 5 条花费相同，但序号较大，所以不输出。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    很简单，就是建立图，然后用unordered_set判断是否经过所有景点一次且仅一次</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(mar,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mar));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) mar[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        mar[a][b] = mar[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>,res = INF,pos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k ; ++i)&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; se;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>,num,a = <span class="number">0</span>,b,sum = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; num; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span>(se.<span class="built_in">find</span>(b) == se.<span class="built_in">end</span>())  se.<span class="built_in">insert</span>(b);</span><br><span class="line">            <span class="keyword">else</span>    flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(mar[a][b] == INF)    flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>    sum += mar[a][b];</span><br><span class="line">            a = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mar[a][<span class="number">0</span>] == INF)    flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>    sum += mar[a][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(se.<span class="built_in">size</span>() != n || !flag) <span class="keyword">continue</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(res &gt; sum)&#123;</span><br><span class="line">            res = sum;</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pos &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。&lt;</summary>
      
    
    
    
    
    <category term="天梯赛" scheme="http://wangxu1905.github.io/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>7-3 冠军魔术 (10 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/19/7-3%20%E5%86%A0%E5%86%9B%E9%AD%94%E6%9C%AF%20(10%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/19/7-3%20%E5%86%A0%E5%86%9B%E9%AD%94%E6%9C%AF%20(10%20%E5%88%86)/</id>
    <published>2022-03-19T02:51:08.094Z</published>
    <updated>2022-03-19T02:58:14.368Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://images.ptausercontent.com/a4b1f9c6-007d-4137-aa94-28b343aa3c34.jpg" alt="魔术.jpg"></p><p>2018年FISM（世界魔术大会）近景总冠军简纶廷的表演中有一个情节：以桌面上一根带子为界，当他将纸牌从带子的一边推到另一边时，纸牌会变成硬币；把硬币推回另一边会变成纸牌。</p><p>这里我们假设纸牌会变成等量的硬币，而硬币变成纸牌时，纸牌的数量会加倍。那么给定纸牌的初始数量，当他来回推了 N 次（来/回各算一次）后，手里拿的是纸牌还是硬币？数量是多少？</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行里给出两个正整数，分别是纸牌的初始数量和魔术师推送的次数。这里假设初始状态下魔术师手里全是纸牌。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如果最后魔术师手里是纸牌，输出 0 和纸牌数量；如果是硬币，则输出 1 和硬币数量。数字间须有 1 个空格。题目保证结果数值不超出整型范围（即 2^31−1）。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">24</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">32</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    是我菜了,round的返回值是double,不管是int,还是long long,乘double的话，都会自动转成double，所以round计算之后要转成int</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,k,t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(m &amp; <span class="number">1</span>)   cout &lt;&lt; <span class="string">&quot;1 &quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;0 &quot;</span>;</span><br><span class="line">    cout &lt;&lt; n * (<span class="keyword">int</span>)<span class="built_in">round</span>(<span class="built_in">pow</span>(<span class="number">2</span>,m / <span class="number">2</span>)) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ptausercontent.com/a4b1f9c6-007d-4137-aa94-28b343aa3c34.jpg&quot; alt=&quot;魔术.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;2018年</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>L2-001 紧急救援 (25 分) 堆优化版</title>
    <link href="http://wangxu1905.github.io/2022/03/19/L2-001%20%E7%B4%A7%E6%80%A5%E6%95%91%E6%8F%B4%20(25%20%E5%88%86)%20%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88/"/>
    <id>http://wangxu1905.github.io/2022/03/19/L2-001%20%E7%B4%A7%E6%80%A5%E6%95%91%E6%8F%B4%20(25%20%E5%88%86)%20%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88/</id>
    <published>2022-03-19T02:27:47.450Z</published>
    <updated>2022-03-19T02:51:15.018Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任务是带领你的救援队尽快赶往事发地，同时，一路上召集尽可能多的救援队。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第一行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0 ~ (<em>N</em>−1)；<em>M</em>是快速道路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。</p><p>第二行给出<em>N</em>个正整数，其中第<em>i</em>个数是第<em>i</em>个城市的救援队的数目，数字间以空格分隔。随后的<em>M</em>行中，每行给出一条快速道路的信息，分别是：城市1、城市2、快速道路的长度，中间用空格分开，数字均为整数且不超过500。输入保证救援可行且最优解唯一。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>第一行输出最短路径的条数和能够召集的最多的救援队数量。第二行输出从<em>S</em>到<em>D</em>的路径中经过的城市编号。数字间以空格分隔，输出结尾不能有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">60</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​        根据前天测试卡我朴素Dijkstra,让我开始学习堆优化版。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">int</span> n, m, s, d, val[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">505</span>];</span><br><span class="line">vector&lt;PII&gt; mar[<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[n],cnt[n],num[n], pre[n];</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mar[s].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        dis[mar[s][i].x] = mar[s][i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    cnt[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//建成小根堆，然后PII第一个值存距离，第二个值存点</span></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//注意是second</span></span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">top</span>().y;</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//如果已经访问过，就继续</span></span><br><span class="line">        <span class="keyword">if</span>(visited[u])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//标记已经访问</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mar[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">           <span class="comment">//这里就是按正常顺序的first，sceond</span></span><br><span class="line">            <span class="keyword">int</span> v = mar[u][i].x, w = mar[u][i].y;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v] &amp;&amp; dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                cnt[v] = cnt[u];</span><br><span class="line">                pre[v] = u;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                num[v] = num[u] + val[v];</span><br><span class="line">                qu.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!visited[v] &amp;&amp; dis[v] == dis[u] + w) &#123;</span><br><span class="line">                cnt[v] += cnt[u];</span><br><span class="line">                <span class="keyword">if</span>(num[v] &lt; num[u] + val[v]) &#123;</span><br><span class="line">                    pre[v] = u;</span><br><span class="line">                    num[v] = num[u] + val[v];</span><br><span class="line">                &#125;</span><br><span class="line">                qu.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt[d] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num[d] + val[s] &lt;&lt; endl;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">while</span>(d != <span class="number">-1</span>)&#123;</span><br><span class="line">        st.<span class="built_in">push</span>(d);</span><br><span class="line">        d = pre[d];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>    flag = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt;  st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  cin &gt;&gt; val[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        mar[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">        mar[v].<span class="built_in">push_back</span>(&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任</summary>
      
    
    
    
    
    <category term="Dijkstra" scheme="http://wangxu1905.github.io/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>素数筛</title>
    <link href="http://wangxu1905.github.io/2022/03/18/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    <id>http://wangxu1905.github.io/2022/03/18/%E7%B4%A0%E6%95%B0%E7%AD%9B/</id>
    <published>2022-03-18T13:51:19.639Z</published>
    <updated>2022-03-18T14:26:16.785Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="一、暴力（略）"><a href="#一、暴力（略）" class="headerlink" title="一、暴力（略）"></a>一、暴力（略）</h3><h3 id="二、埃氏筛"><a href="#二、埃氏筛" class="headerlink" title="二、埃氏筛"></a>二、埃氏筛</h3><p>​        简单来说，筛选[1,n]内的素数，2是最小的素数，那么把2的倍数全都划去。表中剩下最小的数是3，它不能被更小的数整除，所以是素数，再把3的素数都划去。以此类推，如果表中剩余的最小数字是m，m就是素数，将m的倍数都划去。</p><p>像这样反复操作，就能依次枚举n以内的素数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> cnt,prime[MAX_N];</span><br><span class="line"><span class="keyword">bool</span> is_prime[MAX_N + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(is_prime));</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime[i])&#123;</span><br><span class="line">            prime[cnt++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= n; j += i)  is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sieve</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt ;++i)&#123;</span><br><span class="line">        cout &lt;&lt; prime[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、区间筛法"><a href="#三、区间筛法" class="headerlink" title="三、区间筛法"></a>三、区间筛法</h3><p>​    b以内的合数的最小质因子肯定不超过根号b，如果有根号b以内的素数表的话，我们就可以把埃氏筛法运用到[a,b)上了。也就是说，先分别做好[2,根号b)的表和[a,b)的表，然后从[2,根号b)的表筛得质数的同时，也将其倍数从[a,b)的表划去，最后剩下的就是[a,b)的素数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100001</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> cnt,prime[MAX_N];</span><br><span class="line"><span class="keyword">bool</span> is_prime[MAX_N + <span class="number">1</span>],is_prime_small[MAX_N + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segment_sieve</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i * i &lt; b; ++i)   is_prime_small[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; b - a; ++i) is_prime[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">2</span>; i * i &lt; b; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime_small[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(ll j = <span class="number">2</span> * i; j * j &lt; b; j += i)    is_prime_small[j] = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//(a + i - 1) / i * i 取最接近a的i的倍数，并且j至少是i的两倍，2LL,指的是long long</span></span><br><span class="line">            <span class="keyword">for</span>(ll j = <span class="built_in">max</span>(<span class="number">2LL</span>,(a + i - <span class="number">1</span>) / i) * i; j &lt; b; j += i) is_prime[j - a] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">segment_sieve</span>(<span class="number">50</span>,<span class="number">90</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime[i])</span><br><span class="line">            cout &lt;&lt; <span class="number">50</span> + i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;一、暴力（略）&quot;&gt;&lt;a href=&quot;#一、暴力（略）&quot; class=&quot;headerlink&quot; title=&quot;一、暴力（略）&quot;&gt;&lt;/a&gt;一、暴力（略）&lt;/h3&gt;&lt;h3 id=&quot;二、埃氏筛&quot;&gt;&lt;a href=&quot;#二、埃</summary>
      
    
    
    
    
    <category term="素数筛" scheme="http://wangxu1905.github.io/tags/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    
  </entry>
  
  <entry>
    <title>L2-4 风雪火车站 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/18/7-13%20%E6%8C%91%E8%8B%B9%E6%9E%9C%20(35%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/18/7-13%20%E6%8C%91%E8%8B%B9%E6%9E%9C%20(35%20%E5%88%86)/</id>
    <published>2022-03-18T10:38:53.715Z</published>
    <updated>2022-03-18T10:54:47.875Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>妈妈买了<em>N</em>个苹果，每个苹果都有对应的美味度。为了公平，妈妈规定小红和小明需要轮流从剩余的苹果中选择最左边的苹果或者最右边的苹果吃，小红先选。</p><p>小明和小红想要自己吃到苹果的美味度的总和尽可能大，假如小红和小明足够聪明，每次都用最优的策略选择苹果，现在需要你求出小红吃到苹果的美味度的总和。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行输入一个正整数<em>N</em>(1≤<em>N</em>≤100)</p><p>第二行输入<em>N</em>个正整数,表示从左到右苹果的美味度</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出一个数，表示小红能吃到的苹果的美味度的总和。</p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">0</span> <span class="number">20</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure><p>解释：小红先选择美味度为3的苹果，之后小明选择美味度为9的苹果，小红再选择美味度为20的苹果，小明选择美味度为0的苹果，所以小红在最优策略下选择的苹果的美味度总和为20+3=23</p><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">9</span> <span class="number">5</span> <span class="number">16</span> <span class="number">15</span> <span class="number">10</span> </span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><p><strong>小提示：小红和小明都选择最优的策略，也就是小红和小明都要想方设法让自己获得苹果的美味度最大。由于总的苹果的美味度不变，所以小红的策略就是让小明获得的苹果的最大美味度最小，而小明的策略是让小红获得的苹果的最大美味度最小。</strong></p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    区间dp没学过，但是记忆化递归还是能看懂的。</p><p>​    我们先求一遍前缀和，令dfs(l,r)表示当前选的人在[l,r]区间能选到的最大值。</p><p>​    共有两种决策，选左边的苹果与右边的苹果，也就是转移到[l + 1,r]与[l, r - 1]。</p><p>​    那么就会有dfs(l,r) = sum[r] - sum[l - 1] - min(dfs(l + 1,r),dfs(l,r - 1));</p><p>​    也就是[l,r]区间的美味度总和减去另一个人能获得的最大值的最小值就是当前这个人的最优决策能获得的最大值。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,dp[<span class="number">101</span>][<span class="number">101</span>],sum[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[l][r] != <span class="number">-1</span>)  <span class="keyword">return</span> dp[l][r];</span><br><span class="line">    <span class="keyword">if</span>(l == r)  <span class="keyword">return</span> dp[l][r] = sum[r] - sum[l - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[l][r] = sum[r] - sum[l - <span class="number">1</span>] - <span class="built_in">min</span>(<span class="built_in">dfs</span>(l + <span class="number">1</span>,r),<span class="built_in">dfs</span>(l,r - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; sum[i];</span><br><span class="line">        sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>,n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;妈妈买了&lt;em&gt;N&lt;/em&gt;个苹果，每个苹果都有对应的美味度。为了公平，妈妈规定小红和小明需要轮流从剩余的苹果中选择最左边的苹果或者最右边的苹果吃，小红先选。&lt;/p&gt;
&lt;p&gt;小明和小红想要自己吃到苹果的美味度的总和尽可能大，</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>L2-4 风雪火车站 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/17/L2-4%20%E9%A3%8E%E9%9B%AA%E7%81%AB%E8%BD%A6%E7%AB%99%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/17/L2-4%20%E9%A3%8E%E9%9B%AA%E7%81%AB%E8%BD%A6%E7%AB%99%20(25%20%E5%88%86)/</id>
    <published>2022-03-17T12:23:24.480Z</published>
    <updated>2022-03-18T10:09:04.077Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>B国共有 <em>n</em> 座城市，分别编号为 1,2,…,<em>n</em>。你所在地点的编号是 <em>s</em> ，火车站的编号是 <em>t</em>。</p><p>有 <em>m</em> 条道路连接这些城市，它们的长度分别为 <em>w**i</em>。为了便于绘制地图，B国的道路规划保证每条道路严格地连接两个不同的地点，并且不会有两条道路连接的两个地点相同。 你的走路速度是 1<em>m</em>/<em>s</em>。</p><p>开始时，地点 <em>i</em> 的积雪深度为 <em>h**i</em> 。每秒钟地面上积雪的厚度会增加 <em>q</em> 。每个地点都有一个步行的极限雪深 <em>l**i</em> ，如果到达此地时此地的雪深 ，你会被困在这个点，无法继续前进。</p><p>不考虑起始点和火车站的雪。你需要在<em>g</em>秒内到达火车站，如果能到达火车站，输出最快可以到达火车站的时间，否则输出<code>-1</code>。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第 1 行 6 个整数，空格隔开，分别代表 <em>n</em>,<em>m</em>,<em>s</em>,<em>t</em>,<em>g</em>,<em>q</em> 。</p><p>接下来<em>n</em> 行，每行2 个整数，空格隔开，分别表示这个地点的 <em>h**i</em> 和 <em>l**i</em>。</p><p>接下来<em>m</em> 行，每行 3 个整数，空格隔开，分别表示这条路连接的两个地点<em>u</em>,<em>v</em> 和这条路的长度 <em>w**i</em>。</p><p>对所有的数据1≤<em>n</em>≤105,1≤<em>m</em>≤5×105</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出一个整数，表示最短到达火车站的时间，若无法到达，则输出<code>-1</code></p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">10</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">3</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">5</span> <span class="number">10</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">9</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    王伯成大佬说的，我不知道，说是堆优化能过，专门卡spfa。</p><p>​    菜了，当初还写个计时器记录时间，看到刘哲轩的题解后，才明白过来，dijkstra更新距离的时候，已经算上前面的距离了，所以当前dis[v]的距离就是从开始到现在的经历的时间。</p><p>​    然后就是，优先队列是按pair&lt;ll,ll&gt;的第一个元素进行排序，所以我们可以然距离在前，地点标号在后</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; PII;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ll h, l;</span><br><span class="line">&#125; node[<span class="number">200010</span>];</span><br><span class="line">ll n, m, s, t, g, q, timenum;</span><br><span class="line">vector&lt;PII&gt; mar[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Dijkstra</span><span class="params">(ll s)</span> </span>&#123;</span><br><span class="line">    ll dis[<span class="number">200010</span>];</span><br><span class="line">    <span class="comment">//注意，要定义小根堆，咱也不知道重载运算符为啥不能用</span></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; qu;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    qu.<span class="built_in">push</span>(<span class="built_in">PII</span>(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        PII p = qu.<span class="built_in">top</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        ll u = p.y;</span><br><span class="line">        <span class="comment">//如果积雪厚度超过了极限，则依然不选择</span></span><br><span class="line">        <span class="keyword">if</span>(visited[u] || node[u].h + dis[u] * q &gt;= node[u].l)  <span class="keyword">continue</span>;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; mar[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ll v = mar[u][i].x, w = mar[u][i].y;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                qu.<span class="built_in">push</span>(<span class="built_in">PII</span>(dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[t] &lt;= g)</span><br><span class="line">        cout &lt;&lt; dis[t] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t &gt;&gt; g &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; node[i].h &gt;&gt; node[i].l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        ll u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        mar[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">        mar[v].<span class="built_in">push_back</span>(&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;B国共有 &lt;em&gt;n&lt;/em&gt; 座城市，分别编号为 1,2,…,&lt;em&gt;n&lt;/em&gt;。你所在地点的编号是 &lt;em&gt;s&lt;/em&gt; ，火车站的编号是 &lt;em&gt;t&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;有 &lt;em&gt;m&lt;/em&gt; 条道路连接这些</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>L2-3 加密信息 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/17/L2-3%20%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/17/L2-3%20%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%20(25%20%E5%88%86)/</id>
    <published>2022-03-17T11:24:16.768Z</published>
    <updated>2022-03-17T11:35:16.689Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定一个长度为<em>n</em>(<em>n</em>&lt;=5×105)的加密字符串<em>S</em>,解密方式如下：</p><p>1.初始时字符串<em>T</em>为空.</p><p>2.从头遍历S字符串,令<em>i</em>=1,2,3…,<em>n</em>, 若<em>S</em>的第<em>i</em>个字符是<code>R</code>,那么翻转字符串<em>T</em>，否则将该字符加入字符串<em>T</em>中.</p><p>3.在上述操作结束后，若<em>T</em>串有两个连续的字符相同， 那么就删除这两个字符，直到<em>T</em>串中没有两个相同的连续字符为止.</p><p>那么<em>T</em>串就是最终解密完毕的字符串.</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入一个加密字符串<em>S</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S</span><br></pre></td></tr></table></figure><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出最后解密完毕的字符串<em>T</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T</span><br></pre></td></tr></table></figure><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ozRnonnoe</span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zone</span><br></pre></td></tr></table></figure><p>样例解释：</p><p>● 初始时<em>T</em>为空</p><p>● 将<code>o</code>加入<em>T</em>中， 此时<em>T</em>是<code>o</code></p><p>●将<code>z</code>加入<em>T</em>中， 此时<em>T</em>是<code>oz</code></p><p>●翻转<em>T</em>,此时<em>T</em>是<code>zo</code></p><p>●将<code>n</code>加入<em>T</em>中， 此时<em>T</em>是<code>zon</code></p><p>●将<code>o</code>加入<em>T</em>中， 此时<em>T</em>是<code>zono</code></p><p>●将<code>n</code>加入<em>T</em>中， 此时<em>T</em>是<code>zonon</code></p><p>●将<code>n</code>加入<em>T</em>中， 此时<em>T</em>是<code>zononn</code></p><p>●将<code>o</code>加入<em>T</em>中， 此时<em>T</em>是<code>zononno</code></p><p>●将<code>e</code>加入<em>T</em>中， 此时<em>T</em>是<code>zononnoe</code></p><p>●把<em>T</em>中的<code>nn</code>删除，此时<em>T</em>是<code>zonooe</code></p><p>●把<em>T</em>中的<code>oo</code>删除，此时<em>T</em>是<code>zone</code></p><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hellospaceRhellospace</span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><p>此时所有字符都被删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    原本是打算维护两个字符串进行前插和后插，遍历到’R’时，两个字符串进行交换，暴力循环删除重复字符，超时了…….</p><p>​    感谢超漂亮的柳洋学姐，通过双端队列进行模拟，通过标记变量，维护一个双端队列就可以了。然后在插入的时候进行判断删除就可以了，最后直接输出（我感觉我的那个改改其实可能也行，但时间复杂度肯定比学姐的高）</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h5 id="1-学姐的"><a href="#1-学姐的" class="headerlink" title="1.学姐的"></a>1.学姐的</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string t,s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    deque &lt;<span class="keyword">char</span>&gt; de;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">length</span>();i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">            f = (<span class="number">1</span> - f);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!de.<span class="built_in">empty</span>() &amp;&amp; de.<span class="built_in">back</span>() == s[i])&#123;</span><br><span class="line">                    de.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    de.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!de.<span class="built_in">empty</span>() &amp;&amp; de.<span class="built_in">front</span>() == s[i])&#123;</span><br><span class="line">                    de.<span class="built_in">pop_front</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    de.<span class="built_in">push_front</span>(s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!de.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cout &lt;&lt; de.<span class="built_in">back</span>();</span><br><span class="line">            de.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!de.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cout &lt;&lt; de.<span class="built_in">front</span>();</span><br><span class="line">            de.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-我的（未改）"><a href="#2-我的（未改）" class="headerlink" title="2.我的（未改）"></a>2.我的（未改）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s,t = <span class="string">&quot;&quot;</span>,tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != <span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">            t += s[i];</span><br><span class="line">            tmp = s[i] + tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">swap</span>(t,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string res = t;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i] != res[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                ans += res[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定一个长度为&lt;em&gt;n&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;&amp;lt;=5×105)的加密字符串&lt;em&gt;S&lt;/em&gt;,解密方式如下：&lt;/p&gt;
&lt;p&gt;1.初始时字符串&lt;em&gt;T&lt;/em&gt;为空.&lt;/p&gt;
&lt;p&gt;2.从头遍历S字符串,令</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>C++ 结构体运算符重载</title>
    <link href="http://wangxu1905.github.io/2022/03/16/C++%20%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>http://wangxu1905.github.io/2022/03/16/C++%20%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</id>
    <published>2022-03-16T13:09:20.459Z</published>
    <updated>2022-03-19T02:16:20.127Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="一、map重载"><a href="#一、map重载" class="headerlink" title="一、map重载"></a>一、map重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;Node,<span class="keyword">int</span>&gt; book;</span><br><span class="line">    book[Node&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;] = <span class="number">1</span>;</span><br><span class="line">    book[Node&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>&#125;] = <span class="number">1</span>;</span><br><span class="line">    book[Node&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = book.<span class="built_in">begin</span>(); it != book.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">        Node node = it -&gt; first;</span><br><span class="line">        cout &lt;&lt; node.x &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; node.y &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; node.z &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map是按键进行自动排序，但是当用结构体当键时，就无法知道怎么排序，所以我们要进行运算符重载，重新定义Node的大小，以达到排序。</p><p><strong>重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。</strong></p><h3 id="二、优先队列重载"><a href="#二、优先队列重载" class="headerlink" title="二、优先队列重载"></a>二、优先队列重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Node &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;Node,vector&lt;Node&gt;,greater&lt;Node&gt;&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(Node&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    qu.<span class="built_in">push</span>(Node&#123;<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    qu.<span class="built_in">push</span>(Node&#123;<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        Node t = qu.<span class="built_in">top</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; t.x &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; t.y &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; t.z &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    less&lt;&gt;，重载&lt;号，greater重载&gt;号</p><p>​    return x &gt; b.x; 这个和sort是反着的，这个是按递增排序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;一、map重载&quot;&gt;&lt;a href=&quot;#一、map重载&quot; class=&quot;headerlink&quot; title=&quot;一、map重载&quot;&gt;&lt;/a&gt;一、map重载&lt;/h3&gt;&lt;figure class=&quot;highlight c++</summary>
      
    
    
    
    
    <category term="C++" scheme="http://wangxu1905.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>P6145 [USACO20FEB]Timeline G</title>
    <link href="http://wangxu1905.github.io/2022/03/13/P6145%20[USACO20FEB]Timeline%20G/"/>
    <id>http://wangxu1905.github.io/2022/03/13/P6145%20[USACO20FEB]Timeline%20G/</id>
    <published>2022-03-13T10:01:08.861Z</published>
    <updated>2022-03-13T10:13:44.977Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Bessie 在过去的 M天内参加了 N 次挤奶。但她已经忘了她每次挤奶是在哪个时候了。</p><p>对于第 i次挤奶，Bessie 记得它不早于第 S_i天进行。另外，她还有 C条记忆，每条记忆形如一个三元组 (a,b,x)，含义是第 b<em>b</em> 次挤奶在第 a<em>a</em> 次挤奶结束至少 x天后进行。</p><p>现在请你帮 Bessie 算出在满足所有条件的前提下，每次挤奶的最早日期。</p><p>保证 Bessie 的记忆没有错误，这意味着一定存在一种合法的方案，使得：</p><ul><li>第 i<em>i</em> 次挤奶不早于第 S_i 天进行，且不晚于第 M 天进行；</li><li>所有的记忆都得到满足；</li></ul><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行三个整数 N,M,C。保证 1≤<em>N</em>,<em>C</em>≤105，2≤<em>M</em>≤109。</p><p>接下来一行包含 N 个整数 S<em>1,<em>S</em>2,…,<em>Sn，保证 ∀1≤</em>i</em>≤<em>n</em>，都满足1≤<em>Si</em>≤<em>M</em>。</p><p>下面 C<em>C</em> 行每行三个整数 a,b,x，描述一条记忆。保证a<em>!=<em>b，且 1≤</em>x</em>≤<em>M</em>。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 N 行，每行一个整数，第 i 行的数表示第 i 次挤奶的最早日期。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">10</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><ul><li>测试点 2∼4 满足 <em>N</em>,<em>C</em>≤103。</li><li>测试点 5∼10 没有特殊限制。</li></ul><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    因为求最早时间，跑最长路</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, fail;</span><br><span class="line">    <span class="built_in">edge</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _fail) &#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">        fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, k, len, head[maxn], dis[maxn], in[maxn];</span><br><span class="line"><span class="keyword">bool</span> visited[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[len] = <span class="built_in">edge</span>(v, w, head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(s);</span><br><span class="line">    in[s] = <span class="number">1</span>;</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        visited[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].fail) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &lt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">                    qu.<span class="built_in">push</span>(v);</span><br><span class="line">                    in[v]++;</span><br><span class="line">                    visited[v] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">int</span> a, b, x;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,i,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; x;</span><br><span class="line">        <span class="built_in">add</span>(a,b,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cout &lt;&lt; dis[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;Bessie 在过去的 M天内参加了 N 次挤奶。但她已经忘了她每次挤奶是</summary>
      
    
    
    
    
    <category term="差分约束" scheme="http://wangxu1905.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
    <category term="spfa" scheme="http://wangxu1905.github.io/tags/spfa/"/>
    
  </entry>
  
  <entry>
    <title>P1250 种树</title>
    <link href="http://wangxu1905.github.io/2022/03/13/P1250%20%E7%A7%8D%E6%A0%91/"/>
    <id>http://wangxu1905.github.io/2022/03/13/P1250%20%E7%A7%8D%E6%A0%91/</id>
    <published>2022-03-13T09:50:35.667Z</published>
    <updated>2022-03-15T12:31:02.156Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>一条街的一边有几座房子，因为环保原因居民想要在路边种些树。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>路边的地区被分割成块，并被编号成 1,2,…,<em>n</em>。每个部分为一个单位尺寸大小并最多可种一棵树。</p><p>每个居民都想在门前种些树，并指定了三个号码 b，e，t。这三个数表示该居民想在地区 b 和 e之间（包括 b 和 e）种至少 t棵树。</p><p>居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行是一个整数，代表区域的个数 n。</p><p>输入的第二行是一个整数，代表房子个数 h。</p><p>第 3 到第 (h + 2) 行，每行三个整数，第 (i + 2) 行的整数依次为 b_i, e_i, t_i，代表第 i 个居民想在 b_i 和 e_i之间种至少 t_i 棵树。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数，代表最少的树木个数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">8</span> <span class="number">9</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 100% 的数据，保证：</p><ul><li>1≤<em>n</em>≤3×104，1≤<em>h</em>≤5×103。</li><li>1≤<em>bi</em>≤<em>ei</em>≤<em>n</em>，1 1≤<em>ti</em>≤<em>ei</em>−<em>bi</em>+1。</li></ul><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    为了加入超级源点后，得到是否有解，为什么不再跑一遍源点？</p><p>​    因为跑的是最长路，我们加入的边都是正权。加入边权为-1的点，也不影响，因为是为了当正权边更新距离后，通过负权边更新前面的结点</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100001</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, fail;</span><br><span class="line">    <span class="built_in">edge</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _fail) &#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        w = _w;</span><br><span class="line">        fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, k, len, head[maxn], dis[maxn], in[maxn];</span><br><span class="line"><span class="keyword">bool</span> visited[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[len] = <span class="built_in">edge</span>(v, w, head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(s);</span><br><span class="line">    in[s] = <span class="number">1</span>;</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        visited[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].fail) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &lt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">                    qu.<span class="built_in">push</span>(v);</span><br><span class="line">                    in[v]++;</span><br><span class="line">                    visited[v] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i + <span class="number">1</span>,i,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i,i + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(u - <span class="number">1</span>,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; dis[n] &lt;&lt; endl;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500005</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; ve[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> n, m,k, dis[maxn], cnt[maxn];</span><br><span class="line"><span class="keyword">bool</span> visited[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">    dis[s] = <span class="number">0</span>, visited[s] = <span class="number">1</span>, cnt[s] = <span class="number">1</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        visited[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = ve[u][i].x, w = ve[u][i].y;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &lt; dis[u] + w) &#123;</span><br><span class="line">                cnt[v]++;</span><br><span class="line">                <span class="keyword">if</span>(cnt[v] &gt;= n + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">                    qu.<span class="built_in">push</span>(v);</span><br><span class="line">                    visited[v] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        ve[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        ve[i].<span class="built_in">push_back</span>(&#123;i + <span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        ve[i + <span class="number">1</span>].<span class="built_in">push_back</span>(&#123;i,<span class="number">-1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        ve[u - <span class="number">1</span>].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; dis[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目背景&quot;&gt;&lt;a href=&quot;#题目背景&quot; class=&quot;headerlink&quot; title=&quot;题目背景&quot;&gt;&lt;/a&gt;题目背景&lt;/h2&gt;&lt;p&gt;一条街的一边有几座房子，因为环保原因居民想要在路边种些树。&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    
    <category term="差分约束" scheme="http://wangxu1905.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
    <category term="spfa" scheme="http://wangxu1905.github.io/tags/spfa/"/>
    
  </entry>
  
</feed>
