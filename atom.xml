<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moon</title>
  
  
  <link href="http://wangxu1905.github.io/atom.xml" rel="self"/>
  
  <link href="http://wangxu1905.github.io/"/>
  <updated>2022-03-10T12:35:19.590Z</updated>
  <id>http://wangxu1905.github.io/</id>
  
  <author>
    <name>Moon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>P3902 递增</title>
    <link href="http://wangxu1905.github.io/2022/03/10/P3902%20%E9%80%92%E5%A2%9E/"/>
    <id>http://wangxu1905.github.io/2022/03/10/P3902%20%E9%80%92%E5%A2%9E/</id>
    <published>2022-03-10T12:06:29.775Z</published>
    <updated>2022-03-10T12:35:19.590Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有数 A*1,<em>A</em>2,⋯,*An，修改最少的数字为<strong>实数</strong>，使得数列严格单调递增。</p><p>注：原题误表述为修改为整数，现已纠正为实数。本题数据确保按照修改为整数的做法也可以 AC（只是不能过样例）</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，一个整数 n。</p><p>第二行，n 个整数A*1,<em>A</em>2,⋯,*An</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>1 个整数，表示最少修改多少个数字</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输入 #2</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p><strong>输出 #2</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>• 对于50% 的数据，N ≤ 10^3</p><p>• 对于100% 的数据，1 ≤ <em>N</em> ≤ 10^5,1 ≤ Ai ≤10 ^9</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    本来从树状数组找的题，结果感觉还是二分插入比较好。</p><p>​    因为可以修改为实数，所以理论上可以改成任何值（但可能受限于存储，实际不能取无数值）</p><p>​    参考二分插入排序，插入时分为两种情况</p><ul><li>如果待加入的值大于序列的最大值，则直接插入到最后，不需要修改</li><li>如果小于等于，则进行二分插入，找到第一个大于等于待插入值的位置，然后将该位置原本的数进行修改（其实我们未做操作，采取直接覆盖的方法）</li></ul><p>可以用测试样例1，2举例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line">插入 <span class="number">1</span>序列： <span class="number">1</span></span><br><span class="line">插入 <span class="number">3</span>序列： <span class="number">1</span>  <span class="number">3</span></span><br><span class="line">插入 <span class="number">3</span>序列： <span class="number">1</span>  <span class="number">2</span> 将原本的<span class="number">3</span>改为<span class="number">1</span>到<span class="number">2</span>中的一个实数值</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line">插入 <span class="number">1</span>序列： <span class="number">1</span></span><br><span class="line">插入 <span class="number">2</span>序列： <span class="number">1</span>  <span class="number">2</span></span><br><span class="line">插入 <span class="number">3</span>序列： <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line">插入 <span class="number">4</span>序列： <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line">插入 <span class="number">4</span>序列： <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>将原本<span class="number">4</span>改为<span class="number">3</span>到<span class="number">4</span>中的一个实数值</span><br><span class="line">插入 <span class="number">5</span>序列： <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span></span><br><span class="line">插入 <span class="number">6</span>序列： <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line">插入 <span class="number">7</span>序列： <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,t,cnt = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ve;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(ve.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; t &lt;= *ve.<span class="built_in">rbegin</span>()) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            *<span class="built_in">lower_bound</span>(ve.<span class="built_in">begin</span>(),ve.<span class="built_in">end</span>(),t) = t;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ve.<span class="built_in">push_back</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;现有数 A*1,&lt;em&gt;A&lt;/em&gt;2,⋯,*An，修改最少的数字为&lt;st</summary>
      
    
    
    
    
    <category term="树状数组" scheme="http://wangxu1905.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>P4378 [USACO18OPEN]Out of Sorts S</title>
    <link href="http://wangxu1905.github.io/2022/03/10/P4378%20[USACO18OPEN]Out%20of%20Sorts%20S/"/>
    <id>http://wangxu1905.github.io/2022/03/10/P4378%20[USACO18OPEN]Out%20of%20Sorts%20S/</id>
    <published>2022-03-10T11:48:47.672Z</published>
    <updated>2022-03-10T12:06:02.381Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>留意着农场之外的长期职业生涯的可能性，奶牛Bessie开始在不同的在线编程网站上学习算法。</p><p>她到目前为止最喜欢的算法是“冒泡排序”。这是Bessie的对长度为N<em>N</em>的数组A<em>A</em>进行排序的奶牛码实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span> = false</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">not</span> <span class="built_in">sorted</span>):</span><br><span class="line">   <span class="built_in">sorted</span> = true</span><br><span class="line">   moo</span><br><span class="line">   <span class="keyword">for</span> i = <span class="number">0</span> to N-<span class="number">2</span>:</span><br><span class="line">      <span class="keyword">if</span> A[i+<span class="number">1</span>] &lt; A[i]:</span><br><span class="line">         swap A[i], A[i+<span class="number">1</span>]</span><br><span class="line">         <span class="built_in">sorted</span> = false</span><br></pre></td></tr></table></figure><p>显然，奶牛码中的“moo”指令的作用只是输出“moo”。奇怪的是，Bessie看上去执着于在她的代码中的不同位置使用这个语句。</p><p>给定一个输入数组，请预测Bessie的代码会输出多少次“moo”。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行包含N（1≤<em>N</em>≤100,000）。接下来N行描述了A[0]…<em>A</em>[N−1]，每个数都是一个范围为0…10^9的整数。输入数据不保证各不相同。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出“moo”被输出的次数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>供题：Brian Dean</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    原先一看以为是个逆序对板子题，结果输出的结果太大了，才发现每进行一次最外层的循环，结果才会+1，若某个数存在逆序对，每进行一次外循环，则它的逆序对就会减少1，那么，我们就可以找产生逆序对最多的数字，它的逆序对个数才决定最外层循环多少次。</p><p>​    消除完所有逆序对后，还会进行一次外层循环来检查是否还存在逆序对。</p><p>​    综上，最后的结果为产生逆序对最多的数字的逆序对数量 + 1.</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1000010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, order;</span><br><span class="line">&#125; num[maxn + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n, t[maxn + <span class="number">2</span>], numrank[maxn + <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node &amp;a,Node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.val != b.val)  <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">    <span class="keyword">return</span> a.order &lt; b.order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lowbit</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k &amp; -k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x, ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">        t[x] += k;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">        ans += t[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; num[i].val;</span><br><span class="line">        num[i].order = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + n, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        numrank[num[i].order] = i;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">add</span>(numrank[i],<span class="number">1</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,i - <span class="built_in">sum</span>(numrank[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;留意着农场之外的长期职业生涯的可能性，奶牛Bessie开始在不同的在线编程</summary>
      
    
    
    
    
    <category term="树状数组" scheme="http://wangxu1905.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>P5057 [CQOI2006]简单题</title>
    <link href="http://wangxu1905.github.io/2022/03/10/P5057%20[CQOI2006]%E7%AE%80%E5%8D%95%E9%A2%98/"/>
    <id>http://wangxu1905.github.io/2022/03/10/P5057%20[CQOI2006]%E7%AE%80%E5%8D%95%E9%A2%98/</id>
    <published>2022-03-10T11:27:04.526Z</published>
    <updated>2022-03-10T11:47:35.340Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个 n 个元素的数组，每个元素初始均为 0。有 m 条指令，要么让其中一段连续序列数字反转——0 变 1，1 变 0（操作 1），要么询问某个元素的值（操作 2）。 例如当 n = 20 时，10 条指令如下：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/44663.png" alt="img"></p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 n, m，表示数组的长度和指令的条数； 以下 m 行，每行的第一个数 t 表示操作的种类：</p><p>若 t = 1，则接下来有两个数 L, R，表示区间 [L, R] 的每个数均反转； 若 t = 2，则接下来只有一个数 i，表示询问的下标。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>每个操作 2 输出一行（非 0 即 1），表示每次操作 2 的回答。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">12</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">12</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">16</span></span><br><span class="line"><span class="number">1</span> <span class="number">11</span> <span class="number">17</span></span><br><span class="line"><span class="number">2</span> <span class="number">12</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong>复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>对于 50% 的数据，1 ≤ n ≤ 10^3, 1 ≤ m ≤ 10^4； 对于 100% 的数据，1 ≤ n ≤ 10^5, 1 ≤ m ≤ 5 × 10^5，保证 L ≤ R。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    看到题解里面有个特别容易的解法。</p><p>​    因为最后结果<strong>只有0或者1</strong>，大佬就想到了可以**%2**。可以来一波简单的差分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假设初始数组为 <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">我们要将(<span class="number">1</span>，<span class="number">3</span>)反过来，参考差分,只需要在第一个数 + <span class="number">1</span>,第四个数 + <span class="number">1</span>,得到</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">然后查询第一个数 = d[<span class="number">1</span>] % <span class="number">2</span> = <span class="number">1</span> % <span class="number">2</span> = <span class="number">1</span> </span><br><span class="line">然后查询第二个数 = d[<span class="number">2</span>] % <span class="number">2</span> = (<span class="number">1</span> + <span class="number">0</span>) % <span class="number">2</span> = <span class="number">1</span> </span><br><span class="line">然后查询第三个数 = d[<span class="number">3</span>] % <span class="number">2</span> = (<span class="number">1</span> + <span class="number">0</span> + <span class="number">0</span>) % <span class="number">2</span> = <span class="number">1</span> </span><br><span class="line">然后查询第四个数 = d[<span class="number">4</span>] % <span class="number">2</span> = (<span class="number">1</span> + <span class="number">0</span> + <span class="number">0</span> + <span class="number">1</span>) % <span class="number">2</span> = <span class="number">0</span> </span><br><span class="line">然后查询第五个数 = d[<span class="number">5</span>] % <span class="number">2</span> = (<span class="number">1</span> + <span class="number">0</span> + <span class="number">0</span> + <span class="number">1</span> + <span class="number">0</span>) % <span class="number">2</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,t[maxn + <span class="number">10</span>];</span><br><span class="line"><span class="function">ll <span class="title">lowbit</span><span class="params">(ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k &amp; -k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x,ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n)&#123;</span><br><span class="line">        t[x] += k;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        ans += t[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> op,x,y;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="built_in">add</span>(x,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">add</span>(y + <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">sum</span>(x) % <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;有一个 n 个元素的数组，每个元素初始均为 0。有 m 条指令，要么让其中</summary>
      
    
    
    
    
    <category term="树状数组" scheme="http://wangxu1905.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>P1908 逆序对</title>
    <link href="http://wangxu1905.github.io/2022/03/10/P1908%20%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://wangxu1905.github.io/2022/03/10/P1908%20%E9%80%86%E5%BA%8F%E5%AF%B9/</id>
    <published>2022-03-10T10:55:19.723Z</published>
    <updated>2022-03-10T11:22:50.165Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>猫猫 TOM 和小老鼠 JERRY 最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。</p><p>最近，TOM 老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中 a_i&gt;a_j且 i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。注意序列中可能有重复数字。</p><p><strong>Update:数据已加强。</strong></p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，一个数 n，表示序列中有 n个数。</p><p>第二行 n 个数，表示给定的序列。序列中每个数字不超过 10^9。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出序列中逆序对的数目。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">5 4 2 6 3 1</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>对于 25% 的数据，<em>n</em>≤2500</p><p>对于 50% 的数据，n*≤4×104。</p><p>对于所有数据，<em>n</em>≤5×105</p><p>请使用较快的输入输出</p><p>应该不会 O(n^2) 过 50 万吧 by chen_zhe</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    本题是个逆序对的板子题，因为输入的数据不一定是1~n，所以我们先把数据进行离散化，让n个数组从小到大依次映射到1 ~ n上，如果对于相等的数，我们可以标记出现的顺序，按出现的顺序进行排序。</p><p>​    对于6个数，[1 5 3 4 9 8]</p><table><thead><tr><th>下标</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>值</td><td>1</td><td>5</td><td>3</td><td>4</td><td>9</td><td>8</td></tr><tr><td>order</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr></tbody></table><p>​    排序之后</p><table><thead><tr><th>下标</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>值</td><td>1</td><td>3</td><td>4</td><td>5</td><td>8</td><td>9</td></tr><tr><td>order</td><td>1</td><td>3</td><td>4</td><td>2</td><td>6</td><td>5</td></tr></tbody></table><p>​    放入numrank数组</p><table><thead><tr><th>下标</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>值</td><td>1</td><td>4</td><td>2</td><td>3</td><td>6</td><td>5</td></tr><tr><td>原本值</td><td>1</td><td>5</td><td>3</td><td>4</td><td>9</td><td>8</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射关系</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">3</span> -&gt; <span class="number">2</span></span><br><span class="line"><span class="number">4</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">5</span> -&gt; <span class="number">4</span></span><br><span class="line"><span class="number">8</span> -&gt; <span class="number">5</span></span><br><span class="line"><span class="number">9</span> -&gt; <span class="number">6</span></span><br></pre></td></tr></table></figure><p>这样就实现了保持相对大小的情况下实现了离散，然后再考虑怎么求逆序对，我们可以参考插入排序的思想，让numrank值依次加入序列，将新加入的值产生的逆序对加入结果中，最后进行输出。</p><p>例如，我们按照numrank数组的顺序，先加入1，然后树状数组在[1,n]范围内前缀和加1，此时产生的逆序对为<code>i-numrank[i]=1-numrank[1]=1-1 = 0 </code>，即假设有序的情况下，前i个前缀和值应为i，numrank[i]的前缀和为当前已经加入的序列里多少个小于等于numrank[i]（即相对位置是正确的），其差值就是逆序对的个数。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 500001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,order;</span><br><span class="line">&#125;num[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">int</span> bit[MAXSIZE],numrank[MAXSIZE],n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.val != b.val)</span><br><span class="line">        <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">    <span class="keyword">return</span> a.order &lt; b.order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">        bit[i] += x;</span><br><span class="line">        i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        res += bit[i];</span><br><span class="line">        i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; num[i].val;</span><br><span class="line">        num[i].order = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(num + <span class="number">1</span>,num + n + <span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        numrank[num[i].order] = i;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">add</span>(numrank[i],<span class="number">1</span>);</span><br><span class="line">        res += i - <span class="built_in">sum</span>(numrank[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;猫猫 TOM 和小老鼠 JERRY 最近又较量上了，但是毕竟都是成年人，他</summary>
      
    
    
    
    
    <category term="树状数组" scheme="http://wangxu1905.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C++ stringstream的用法</title>
    <link href="http://wangxu1905.github.io/2022/03/06/C++%20stringstream%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://wangxu1905.github.io/2022/03/06/C++%20stringstream%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2022-03-06T12:49:42.148Z</published>
    <updated>2022-03-06T13:04:55.537Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="一、分割被空格、制表符等符号分割的字符串"><a href="#一、分割被空格、制表符等符号分割的字符串" class="headerlink" title="一、分割被空格、制表符等符号分割的字符串"></a>一、分割被空格、制表符等符号分割的字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;Hello world,hello c++&quot;</span>;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(ss &gt;&gt; s)&#123;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、stringstream的清空"><a href="#二、stringstream的清空" class="headerlink" title="二、stringstream的清空"></a>二、stringstream的清空</h3><p>如果想清空 stringstream，必须使用 sstream.str(“”); 方式；clear() 方法适用于进行多次数据类型转换的场景。我感觉还是clear好用，str不太会用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line">    <span class="keyword">int</span> first, second;</span><br><span class="line">    <span class="comment">// 插入字符串</span></span><br><span class="line">    sstream &lt;&lt; <span class="string">&quot;456&quot;</span>;</span><br><span class="line">    <span class="comment">// 转换为int类型</span></span><br><span class="line">    sstream &gt;&gt; first;</span><br><span class="line">    cout &lt;&lt; first &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 在进行多次类型转换前，必须先运行clear()</span></span><br><span class="line">    sstream.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// 插入bool值</span></span><br><span class="line">    sstream &lt;&lt; <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 转换为int类型</span></span><br><span class="line">    sstream &gt;&gt; second;</span><br><span class="line">    cout &lt;&lt; second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、数据类型转换（个人感觉stoi和to-string就够了）"><a href="#三、数据类型转换（个人感觉stoi和to-string就够了）" class="headerlink" title="三、数据类型转换（个人感觉stoi和to_string就够了）"></a>三、数据类型转换（个人感觉stoi和to_string就够了）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line">    string s,str = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1000</span>,t;</span><br><span class="line">    <span class="comment">//将int类型的值放入输入流中</span></span><br><span class="line">    sstream &lt;&lt; n;</span><br><span class="line">    <span class="comment">//从sstream中抽取前面插入的int类型的值，赋给string类型</span></span><br><span class="line">    sstream &gt;&gt; s;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    sstream.<span class="built_in">clear</span>();</span><br><span class="line">    sstream &lt;&lt; str;</span><br><span class="line">    sstream &gt;&gt; t;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;一、分割被空格、制表符等符号分割的字符串&quot;&gt;&lt;a href=&quot;#一、分割被空格、制表符等符号分割的字符串&quot; class=&quot;headerlink&quot; title=&quot;一、分割被空格、制表符等符号分割的字符串&quot;&gt;&lt;/a&gt;一</summary>
      
    
    
    
    
    <category term="C++" scheme="http://wangxu1905.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>L1-064 估值一亿的AI核心代码 (20 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/06/L1-064%20%E4%BC%B0%E5%80%BC%E4%B8%80%E4%BA%BF%E7%9A%84AI%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%20(20%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/06/L1-064%20%E4%BC%B0%E5%80%BC%E4%B8%80%E4%BA%BF%E7%9A%84AI%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%20(20%20%E5%88%86)/</id>
    <published>2022-03-06T12:13:37.062Z</published>
    <updated>2022-03-06T12:19:07.201Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://images.ptausercontent.com/3e7829fa-ed75-4890-acca-54a00fbac9d3.jpg" alt="AI.jpg"></p><p>以上图片来自新浪微博。</p><p>本题要求你实现一个稍微更值钱一点的 AI 英文问答程序，规则是：</p><ul><li>无论用户说什么，首先把对方说的话在一行中原样打印出来；</li><li>消除原文中多余空格：把相邻单词间的多个空格换成 1 个空格，把行首尾的空格全部删掉，把标点符号前面的空格删掉；</li><li>把原文中所有大写英文字母变成小写，除了 <code>I</code>；</li><li>把原文中所有独立的 <code>can you</code>、<code>could you</code> 对应地换成 <code>I can</code>、<code>I could</code>—— 这里“独立”是指被空格或标点符号分隔开的单词；</li><li>把原文中所有独立的 <code>I</code> 和 <code>me</code> 换成 <code>you</code>；</li><li>把原文中所有的问号 <code>?</code> 换成惊叹号 <code>!</code>；</li><li>在一行中输出替换后的句子作为 AI 的回答。</li></ul><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先在第一行给出不超过 10 的正整数 N，随后 N 行，每行给出一句不超过 1000 个字符的、以回车结尾的用户的对话，对话为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按题面要求输出，每个 AI 的回答前要加上 <code>AI:</code> 和一个空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line">Hello ?</span><br><span class="line"> Good to chat   with you</span><br><span class="line">can   you speak Chinese?</span><br><span class="line">Really?</span><br><span class="line">Could you show me <span class="number">5</span></span><br><span class="line">What Is <span class="keyword">this</span> prime? I,don <span class="string">&#x27;t know</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello ?</span><br><span class="line">AI: hello!</span><br><span class="line"> Good to chat   with you</span><br><span class="line">AI: good to chat with you</span><br><span class="line">can   you speak Chinese?</span><br><span class="line">AI: I can speak chinese!</span><br><span class="line">Really?</span><br><span class="line">AI: really!</span><br><span class="line">Could you show me <span class="number">5</span></span><br><span class="line">AI: I could show you <span class="number">5</span></span><br><span class="line">What Is <span class="keyword">this</span> prime? I,don <span class="string">&#x27;t know</span></span><br><span class="line"><span class="string">AI: what Is this prime! you,don&#x27;</span>t know</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    原谅我是只菜鸡，是在写不出来了，我与字符串模拟题不共戴天。</p><p>​    在每个空格和标点之前加一个空格，将字符串化为一块一块的，逐个判断输出</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        string s, str[<span class="number">1005</span>], s1;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin, s);</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;AI:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">//isalnum,判断字符和数字</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalnum</span>(s[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] != <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">                    s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//分割成一块一块的</span></span><br><span class="line">                s.<span class="built_in">insert</span>(i, <span class="string">&quot; &quot;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">                s[i] = <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消除空格</span></span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; s1) &#123;</span><br><span class="line">            str[cnt++] = s1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(str[<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">            <span class="comment">//标点符号前不存在空格</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(str[i][<span class="number">0</span>]))</span><br><span class="line">                cout &lt;&lt; str[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&quot;can&quot;</span> &amp;&amp; i + <span class="number">1</span> &lt; cnt &amp;&amp; str[i + <span class="number">1</span>] == <span class="string">&quot;you&quot;</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; I can&quot;</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&quot;could&quot;</span> &amp;&amp; i + <span class="number">1</span> &lt; cnt &amp;&amp; str[i + <span class="number">1</span>] == <span class="string">&quot;you&quot;</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; I could&quot;</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&quot;I&quot;</span> || str[i] == <span class="string">&quot;me&quot;</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; you&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; str[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://images.ptausercontent.com/3e7829fa-ed75-4890-acca-54a00fbac9d3.jpg&quot; alt=&quot;AI.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;以上图片来</summary>
      
    
    
    
    
    <category term="天梯赛" scheme="http://wangxu1905.github.io/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    
    <category term="字符串模拟" scheme="http://wangxu1905.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>C++ priority_queue 自定义排序函数</title>
    <link href="http://wangxu1905.github.io/2022/03/05/C++%20priority_queue%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/"/>
    <id>http://wangxu1905.github.io/2022/03/05/C++%20priority_queue%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/</id>
    <published>2022-03-05T11:25:09.953Z</published>
    <updated>2022-03-05T11:40:29.910Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; qu; <span class="comment">//递增</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; qu;</span><br><span class="line"><span class="comment">//递减</span></span><br></pre></td></tr></table></figure><p>我们如果要按照结构体中的的大小进行排序，就需要重载运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> label;</span><br><span class="line">&#125;a;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (A a1, A a2)&#123;</span><br><span class="line"><span class="keyword">return</span> a1.r &lt; a2.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (A a1, A a2)&#123;</span><br><span class="line"><span class="keyword">return</span> a1.l &gt; a2.l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>大于号 &gt; 的重载对应了greater的重载，是根据重载规则从小到大排序</li><li>小于号 &lt; 的重载对应了less的重载，是根据重载规则从大到小排序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node a,Node b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a &lt; b.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;Node,vector&lt;Node&gt;,less&lt;Node&gt;&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(Node&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    qu.<span class="built_in">push</span>(Node&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    qu.<span class="built_in">push</span>(Node&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        Node node = qu.<span class="built_in">top</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; node.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; node.b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; node.c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    
    <category term="C++" scheme="http://wangxu1905.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>P5960 【模板】差分约束算法</title>
    <link href="http://wangxu1905.github.io/2022/03/03/P5960%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%AE%97%E6%B3%95/"/>
    <id>http://wangxu1905.github.io/2022/03/03/P5960%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%AE%97%E6%B3%95/</id>
    <published>2022-03-03T13:34:37.720Z</published>
    <updated>2022-03-03T13:56:45.848Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>题干不好抄，给个链接吧</p><p><a href="https://www.luogu.com.cn/problem/P5960">P5960 【模板】差分约束算法 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h2 id="算法思路（差分约束）"><a href="#算法思路（差分约束）" class="headerlink" title="算法思路（差分约束）"></a>算法思路（差分约束）</h2><p>​    因为本身看题目就是个模板题，没啥好说的。</p><p><strong>差分约束系统</strong></p><p>如果一个不等式组由 n 个变量和 m个约束条件组成，形成 m个形如$\ x_{i} - x_{j} \le  k  (i,j\in [1,n])$的不等式，则称其为 <strong>差分约束系统</strong>。换句话说，差分约束系统就是求解一组变量的不等式组的算法。</p><p>样例其实可以更为直观地写成以下不等式组：</p><p>$\ \left{\begin{array}{l}<br>x_{1}-x_{2} \leq 3 \<br>x_{2}-x_{3} \leq-2 \<br>x_{1}-x_{3} \leq 1<br>\end{array}\right.$</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> bx,by,mx,my;</span><br><span class="line">    cin &gt;&gt; bx &gt;&gt; by &gt;&gt; mx &gt;&gt; my;</span><br><span class="line">    bx +=<span class="number">2</span>;by += <span class="number">2</span>;mx += <span class="number">2</span>;my += <span class="number">2</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    s[mx][my] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">8</span>; ++i)</span><br><span class="line">        s[mx + dx[i]][my + dy[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= bx; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= by; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j])&#123;</span><br><span class="line">                dp[j] = <span class="number">0</span>;<span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] +=  dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[by] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;题干不好抄，给个链接吧&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P5960&quot;&gt;P5960 【模板】差分约束算法 - 洛谷 | 计算机科学教育新生态 (luogu.co</summary>
      
    
    
    
    
    <category term="差分约束" scheme="http://wangxu1905.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
  </entry>
  
  <entry>
    <title>L2-4 编辑器 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/02/27/L2-4%20%E7%BC%96%E8%BE%91%E5%99%A8%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/02/27/L2-4%20%E7%BC%96%E8%BE%91%E5%99%A8%20(25%20%E5%88%86)/</id>
    <published>2022-02-27T13:31:28.028Z</published>
    <updated>2022-02-27T13:44:49.278Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>原题来自算法竞赛进阶指南，本题略有改动</strong></p><p>小 Z 是一个爱好数学的小学生。最近，他在研究一些关于整数数列的性质。</p><p>为了方便他的研究，小Z希望实现一个叫做“Open Continuous Lines Processor”的数列编辑器。</p><p>一开始，数列编辑器里没有数字，只有一个光标。这个数列编辑器需要支持五种操作。</p><ul><li><code>I x</code> 在当前光标前插入数字<em>x</em></li><li><code>D</code> 删除当前光标前的数字，若光标前没有数字，则忽略此次操作。</li><li><code>L</code> 光标向左移动一个数字，若光标前没有数字，则忽略此次操作。</li><li><code>R</code> 光标向右移动一个数字，若光标后没有数字，则忽略此次操作。</li><li><code>Q</code> 设光标之前的序列为{<em>a</em>1,<em>a</em>2,…<em>a**n</em>}, 求 <em>ma**x</em>{<em>a</em>1,<em>a</em>2,…,<em>a**n</em>}</li></ul><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行包含一个整数 <em>T</em>(1≤<em>T</em>≤106)，表示指令的总数。</p><p>接下来 <em>T</em> 行，每行一个指令，具体指令格式如题目描述。</p><p>数据保证插入的数<em>x</em>满足∣<em>x</em>∣≤103</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>每一个 <code>Q</code> 指令，输出一个整数作为结果，每个结果占一行。如果查询的是一个空序列，那么输出<code>-10000</code></p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line">I <span class="number">-7</span></span><br><span class="line">I <span class="number">-1</span></span><br><span class="line">I <span class="number">1</span></span><br><span class="line">Q</span><br><span class="line">L</span><br><span class="line">D</span><br><span class="line">Q</span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">-7</span></span><br></pre></td></tr></table></figure><p>样例解释：</p><p><img src="https://images.ptausercontent.com/6d704f57-6fd1-48b4-a14d-6d9f2a0d28ef.png" alt="9OLC7(M5.png"></p><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">I <span class="number">-7</span></span><br><span class="line">L</span><br><span class="line">Q</span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-10000</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    本题的特殊点在于，I,D,L,R,Q,五种操作都是在光标位置处发生，并且操作完成后光标至多移动一个位置。根据这种”始终在序列中间某个指定位置进行修改”的性质，我们不难想到一种”对顶栈”的做法（抱歉，我没想到）。</p><p>​    建立两个栈，栈A存储从序列开头到当前光标位置的这一段子序列，栈B存储从当前光标位置到序列结尾的这一段序列，二者都以光标所在的那一端作为栈顶。这两个栈合起来就保存了整个序列。因为查询操作的k不超过光标位置，所以我们用一个数组f维护当前的最大值即可。</p><p>​    通过这样两个”对顶栈”，我们在O（1）时间内实现了每种操作和询问。总时间复杂度为O（n）。</p><h5 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> stkl[maxn], stkr[maxn], tl, tr;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    stkl[++tl] = x;</span><br><span class="line">    f[tl] = <span class="built_in">max</span>(f[tl - <span class="number">1</span>], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tl &gt; <span class="number">0</span>)  tl--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tl &gt; <span class="number">0</span>)</span><br><span class="line">                stkr[++tr] = stkl[tl--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr &gt; <span class="number">0</span>)  <span class="built_in">add</span>(stkr[tr--]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tl) cout &lt;&lt; <span class="string">&quot;-10000&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span>    cout &lt;&lt; f[tl] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;strong&gt;原题来自算法竞赛进阶指南，本题略有改动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小 Z 是一个爱好数学的小学生。最近，他在研究一些关于整数数列的性质。&lt;/p&gt;
&lt;p&gt;为了方便他的研究，小Z希望实现一个叫做“Open </summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>L2-3 手机密码 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/02/27/L2-3%20%E6%89%8B%E6%9C%BA%E5%AF%86%E7%A0%81%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/02/27/L2-3%20%E6%89%8B%E6%9C%BA%E5%AF%86%E7%A0%81%20(25%20%E5%88%86)/</id>
    <published>2022-02-27T03:25:22.980Z</published>
    <updated>2022-02-27T13:45:03.224Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>小A忘记了自己的手机密码，但是他知道手机密码是由4个数字组成的，并且可以确定手机密码里面有那些数字是一定有的，哪些数字是一定没有的和哪些数字是可能有的。他给你一个长度为10的字符串<em>S</em>0<em>S</em>1<em>S</em>2…<em>S</em>9</p><ul><li>若<em>Si</em>为<code>o</code>, 表示密码中一定有数字<code>i</code></li><li>若<em>Si</em>为<code>x</code>, 表示密码中一定没有数字<code>i</code></li><li>若<em>Si</em>为<code>?</code>, 表示密码中可能有数字<code>i</code></li></ul><p>他知道你是个编程高手，所以他希望你能够帮助他找出所有的手机密码。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入一个长度为10的只包括<code>o</code>,<code>x</code>,<code>?</code>的字符串。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出若干行，每行包括一种手机密码，本题采用special judge，以<strong>任意顺序</strong>输出所有的手机密码即可</p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?xxxxxxxxo</span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0009</span></span><br><span class="line"><span class="number">0090</span></span><br><span class="line"><span class="number">0099</span></span><br><span class="line"><span class="number">0900</span></span><br><span class="line"><span class="number">0909</span></span><br><span class="line"><span class="number">0990</span></span><br><span class="line"><span class="number">0999</span></span><br><span class="line"><span class="number">9000</span></span><br><span class="line"><span class="number">9009</span></span><br><span class="line"><span class="number">9090</span></span><br><span class="line"><span class="number">9099</span></span><br><span class="line"><span class="number">9900</span></span><br><span class="line"><span class="number">9909</span></span><br><span class="line"><span class="number">9990</span></span><br><span class="line"><span class="number">9999</span></span><br></pre></td></tr></table></figure><p>?xxxxxxxxo表示可能会有数字<code>0</code>，一定会有数字<code>9</code></p><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o?oo?oxoxo</span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>不存在满足条件的四位密码</p><h3 id="输入样例3"><a href="#输入样例3" class="headerlink" title="输入样例3:"></a>输入样例3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ooxxxxxxxx</span><br></pre></td></tr></table></figure><h3 id="输出样例3"><a href="#输出样例3" class="headerlink" title="输出样例3:"></a>输出样例3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0001</span></span><br><span class="line"><span class="number">0010</span></span><br><span class="line"><span class="number">0011</span></span><br><span class="line"><span class="number">0100</span></span><br><span class="line"><span class="number">0101</span></span><br><span class="line"><span class="number">0110</span></span><br><span class="line"><span class="number">0111</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">1001</span></span><br><span class="line"><span class="number">1010</span></span><br><span class="line"><span class="number">1011</span></span><br><span class="line"><span class="number">1100</span></span><br><span class="line"><span class="number">1101</span></span><br><span class="line"><span class="number">1110</span></span><br></pre></td></tr></table></figure><p>由于允许以任意顺序输出答案，因此下面这个输出也会被认为是正确的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1110</span></span><br><span class="line"><span class="number">1101</span></span><br><span class="line"><span class="number">1100</span></span><br><span class="line"><span class="number">1011</span></span><br><span class="line"><span class="number">1010</span></span><br><span class="line"><span class="number">1001</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">0111</span></span><br><span class="line"><span class="number">0110</span></span><br><span class="line"><span class="number">0101</span></span><br><span class="line"><span class="number">0100</span></span><br><span class="line"><span class="number">0011</span></span><br><span class="line"><span class="number">0010</span></span><br><span class="line"><span class="number">0001</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><h4 id="一、枚举"><a href="#一、枚举" class="headerlink" title="一、枚举"></a>一、枚举</h4><p>这是我没想到的，L2的题暴力枚举即可，是我菜了。</p><p>手机密码一共四位数，答案一定是0000~9999中的某些情况，直接从小到大枚举每种情况，然后判断是否合法即可，合法就输出。</p><h5 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">bool</span> st[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;o&#x27;</span> &amp;&amp; !st[i])   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;x&#x27;</span> &amp;&amp; st[i])    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(st));</span><br><span class="line">        <span class="keyword">int</span> a = i / <span class="number">1000</span>,b = i % <span class="number">1000</span> / <span class="number">100</span>,c = i % <span class="number">100</span> / <span class="number">10</span>,d = i % <span class="number">10</span>;</span><br><span class="line">        st[a] = st[b] = st[c] = st[d] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>()) <span class="built_in">printf</span>(<span class="string">&quot;%04d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、DFS"><a href="#二、DFS" class="headerlink" title="二、DFS"></a>二、DFS</h4><p>每个数字有三种状态，在这里假定为0,1,2，不妨设0代表一定没有该数字，1代表可有可无，2代表一定有；我们根据这三种状态进行搜索；在搜索到一个数字时，如果该数字一定没有，我们直接跳过它，如果一定有，我们将该数字放到该位上，并将该数字的状态由2改为1，也就是由必须有这个数字变为可有可无；如果数字的状态是可有可无，那我们分两种情况来搜索，选这个数字放在该位，或者不选这个数字放在这一位。</p><h5 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>() &lt; <span class="number">4</span>)  <span class="keyword">return</span>; <span class="comment">//答案不合法</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="number">2</span>) &#123;  <span class="comment">//有必选的数字没有选上，答案不合法</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); ++i)</span><br><span class="line">                cout &lt;&lt; res[i];</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);  <span class="comment">//不选</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);  <span class="comment">//选</span></span><br><span class="line">            res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(st[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            st[i] = <span class="number">1</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            st[i] = <span class="number">2</span>;  <span class="comment">//恢复现场</span></span><br><span class="line">            res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;o&#x27;</span>) st[i] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;?&#x27;</span>)    st[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> st[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;小A忘记了自己的手机密码，但是他知道手机密码是由4个数字组成的，并且可以确定手机密码里面有那些数字是一定有的，哪些数字是一定没有的和哪些数字是可能有的。他给你一个长度为10的字符串&lt;em&gt;S&lt;/em&gt;0&lt;em&gt;S&lt;/em&gt;1</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>L2-2 LR插入 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/02/27/L2-2%20LR%E6%8F%92%E5%85%A5%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/02/27/L2-2%20LR%E6%8F%92%E5%85%A5%20(25%20%E5%88%86)/</id>
    <published>2022-02-27T02:41:30.431Z</published>
    <updated>2022-02-27T03:19:15.627Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定一个序列A，初始时只含有一个元素0.</p><p>此外，给定一个长度为<em>N</em>的字符串<em>S</em>，仅由字符<code>L</code>与<code>R</code>组成。</p><p>我们从1~<em>n</em>依次根据下述规则添加数字：</p><ul><li>若第i个字符是<code>L</code>, 那么在数字i-1的左边插入数字i</li><li>若第i个字符是<code>R</code>, 那么在数字i-1的右边插入数字i</li></ul><p>请你输出序列A</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行输入一个正整数<em>N</em>(1≤<em>N</em>≤5×105)</p><p>第二行输入一个长度为<em>N</em>的仅由<code>L</code>与<code>R</code>组成的字符串</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出序列A，以空格为分隔。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">LRRLR</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>初始时,<em>A</em>=(0).</p><p><em>S</em>1为<code>L</code>, 在<code>0</code>的左边插入<code>1</code>, 此时<em>A</em>=(1,0).</p><p><em>S</em>2为<code>R</code>, 在<code>1</code>的右边插入<code>2</code>, 此时<em>A</em>=(1,2,0).</p><p><em>S</em>3为<code>R</code>, 在<code>2</code>的右边插入<code>3</code>, 此时<em>A</em>=(1,2,3,0).</p><p><em>S</em>4为<code>L</code>, 在<code>3</code>的左边插入<code>4</code>, 此时<em>A</em>=(1,2,4,3,0).</p><p><em>S</em>5为<code>R</code>, 在<code>4</code>的右边插入<code>5</code>, 此时<em>A</em>=(1,2,4,5,3,0).</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><h4 id="一、利用二叉树"><a href="#一、利用二叉树" class="headerlink" title="一、利用二叉树"></a>一、利用二叉树</h4><p>通过二叉树的左右孩子来进行左右插入，最后中序遍历的结果就是答案</p><h5 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> l[N],r[N],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;L&#x27;</span>)    l[pos - <span class="number">1</span>] = pos;</span><br><span class="line">    <span class="keyword">else</span>    r[pos - <span class="number">1</span>] = pos;</span><br><span class="line">    <span class="built_in">Build</span>(pos + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="number">-1</span>)   <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">Inorder</span>(l[root]);</span><br><span class="line">    cout &lt;&lt; root &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">Inorder</span>(r[root]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(l,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(l));</span><br><span class="line">    <span class="built_in">memset</span>(r,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(r));</span><br><span class="line">    <span class="built_in">Build</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Inorder</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、倒序枚举"><a href="#二、倒序枚举" class="headerlink" title="二、倒序枚举"></a>二、倒序枚举</h4><p>找规律，首先，将数组内放入n，然后倒序枚举字符串，也就是下标i从n - 1到 0,如果当前字母是L，则将i插入到数组末尾，否则插入到数组前端，为了方便起见，我们可以使用STL里的双端队列deque进行操作。</p><h5 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;L&#x27;</span>) q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">else</span> q.<span class="built_in">push_front</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定一个序列A，初始时只含有一个元素0.&lt;/p&gt;
&lt;p&gt;此外，给定一个长度为&lt;em&gt;N&lt;/em&gt;的字符串&lt;em&gt;S&lt;/em&gt;，仅由字符&lt;code&gt;L&lt;/code&gt;与&lt;code&gt;R&lt;/code&gt;组成。&lt;/p&gt;
&lt;p&gt;我们从1~</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangxu1905.github.io/2022/02/02/public/workbox-ef7ec2a4/"/>
    <id>http://wangxu1905.github.io/2022/02/02/public/workbox-ef7ec2a4/</id>
    <published>2022-02-02T13:52:10.391Z</published>
    <updated>2022-02-02T13:52:35.892Z</updated>
    
    <content type="html"><![CDATA[define("./workbox-ef7ec2a4.js",["exports"],(function(t){"use strict";try{self["workbox:core:6.1.5"]&&_()}catch(t){}const e=(t,...e)=>{let s=t;return e.length>0&&(s+=` :: ${JSON.stringify(e)}`),s};class s extends Error{constructor(t,s){super(e(t,s)),this.name=t,this.details=s}}try{self["workbox:routing:6.1.5"]&&_()}catch(t){}const r=t=>t&&"object"==typeof t?t:{handle:t};class n{constructor(t,e,s="GET"){this.handler=r(e),this.match=t,this.method=s}setCatchHandler(t){this.catchHandler=r(t)}}class i extends n{constructor(t,e,s){super((({url:e})=>{const s=t.exec(e.href);if(s&&(e.origin===location.origin||0===s.index))return s.slice(1)}),e,s)}}class o{constructor(){this.t=new Map,this.i=new Map}get routes(){return this.t}addFetchListener(){self.addEventListener("fetch",(t=>{const{request:e}=t,s=this.handleRequest({request:e,event:t});s&&t.respondWith(s)}))}addCacheListener(){self.addEventListener("message",(t=>{if(t.data&&"CACHE_URLS"===t.data.type){const{payload:e}=t.data,s=Promise.all(e.urlsToCache.map((e=>{"string"==typeof e&&(e=[e]);const s=new Request(...e);return this.handleRequest({request:s,event:t})})));t.waitUntil(s),t.ports&&t.ports[0]&&s.then((()=>t.ports[0].postMessage(!0)))}}))}handleRequest({request:t,event:e}){const s=new URL(t.url,location.href);if(!s.protocol.startsWith("http"))return;const r=s.origin===location.origin,{params:n,route:i}=this.findMatchingRoute({event:e,request:t,sameOrigin:r,url:s});let o=i&&i.handler;const a=t.method;if(!o&&this.i.has(a)&&(o=this.i.get(a)),!o)return;let c;try{c=o.handle({url:s,request:t,event:e,params:n})}catch(t){c=Promise.reject(t)}const h=i&&i.catchHandler;return c instanceof Promise&&(this.o||h)&&(c=c.catch((async r=>{if(h)try{return await h.handle({url:s,request:t,event:e,params:n})}catch(t){r=t}if(this.o)return this.o.handle({url:s,request:t,event:e});throw r}))),c}findMatchingRoute({url:t,sameOrigin:e,request:s,event:r}){const n=this.t.get(s.method)||[];for(const i of n){let n;const o=i.match({url:t,sameOrigin:e,request:s,event:r});if(o)return n=o,(Array.isArray(o)&&0===o.length||o.constructor===Object&&0===Object.keys(o).length||"boolean"==typeof o)&&(n=void 0),{route:i,params:n}}return{}}setDefaultHandler(t,e="GET"){this.i.set(e,r(t))}setCatchHandler(t){this.o=r(t)}registerRoute(t){this.t.has(t.method)||this.t.set(t.method,[]),this.t.get(t.method).push(t)}unregisterRoute(t){if(!this.t.has(t.method))throw new s("unregister-route-but-not-found-with-method",{method:t.method});const e=this.t.get(t.method).indexOf(t);if(!(e>-1))throw new s("unregister-route-route-not-registered");this.t.get(t.method).splice(e,1)}}let a;const c=()=>(a||(a=new o,a.addFetchListener(),a.addCacheListener()),a);const h={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:"undefined"!=typeof registration?registration.scope:""},u=t=>[h.prefix,t,h.suffix].filter((t=>t&&t.length>0)).join("-"),f=t=>t||u(h.runtime);function l(){return(l=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var s="arguments[e];for(var" r in s)object.prototype.hasownproperty.call(s,r)&&(t[r]="s[r])}return" t}).apply(this,arguments)}function w(t,e){const url(t);for(const t of e)s.searchparams.delete(t);return s.href}class d{constructor(){this.promise="new" promise(((t,e)>{this.resolve=t,this.reject=e}))}}const p=new Set;try{self["workbox:strategies:6.1.5"]&&_()}catch(t){}function y(t){return"string"==typeof t?new Request(t):t}class v{constructor(t,e){this.h={},Object.assign(this,e),this.event=e.event,this.u=t,this.l=new d,this.p=[],this.v=[...t.plugins],this.m=new Map;for(const t of this.v)this.m.set(t,{});this.event.waitUntil(this.l.promise)}async fetch(t){const{event:e}=this;let r=y(t);if("navigate"===r.mode&&e instanceof FetchEvent&&e.preloadResponse){const t=await e.preloadResponse;if(t)return t}const n=this.hasCallback("fetchDidFail")?r.clone():null;try{for(const t of this.iterateCallbacks("requestWillFetch"))r=await t({request:r.clone(),event:e})}catch(t){throw new s("plugin-error-request-will-fetch",{thrownError:t})}const i=r.clone();try{let t;t=await fetch(r,"navigate"===r.mode?void 0:this.u.fetchOptions);for(const s of this.iterateCallbacks("fetchDidSucceed"))t=await s({event:e,request:i,response:t});return t}catch(t){throw n&&await this.runCallbacks("fetchDidFail",{error:t,event:e,originalRequest:n.clone(),request:i.clone()}),t}}async fetchAndCachePut(t){const e=await this.fetch(t),s=e.clone();return this.waitUntil(this.cachePut(t,s)),e}async cacheMatch(t){const e=y(t);let s;const{cacheName:r,matchOptions:n}=this.u,i=await this.getCacheKey(e,"read"),o=l({},n,{cacheName:r});s=await caches.match(i,o);for(const t of this.iterateCallbacks("cachedResponseWillBeUsed"))s=await t({cacheName:r,matchOptions:n,cachedResponse:s,request:i,event:this.event})||void 0;return s}async cachePut(t,e){const r=y(t);var n;await(n=0,new Promise((t=>setTimeout(t,n))));const i=await this.getCacheKey(r,"write");if(!e)throw new s("cache-put-with-no-response",{url:(o=i.url,new URL(String(o),location.href).href.replace(new RegExp(`^${location.origin}`),""))});var o;const a=await this.g(e);if(!a)return!1;const{cacheName:c,matchOptions:h}=this.u,u=await self.caches.open(c),f=this.hasCallback("cacheDidUpdate"),d=f?await async function(t,e,s,r){const n=w(e.url,s);if(e.url===n)return t.match(e,r);const i=l({},r,{ignoreSearch:!0}),o=await t.keys(e,i);for(const e of o)if(n===w(e.url,s))return t.match(e,r)}(u,i.clone(),["__WB_REVISION__"],h):null;try{await u.put(i,f?a.clone():a)}catch(t){throw"QuotaExceededError"===t.name&&await async function(){for(const t of p)await t()}(),t}for(const t of this.iterateCallbacks("cacheDidUpdate"))await t({cacheName:c,oldResponse:d,newResponse:a.clone(),request:i,event:this.event});return!0}async getCacheKey(t,e){if(!this.h[e]){let s=t;for(const t of this.iterateCallbacks("cacheKeyWillBeUsed"))s=y(await t({mode:e,request:s,event:this.event,params:this.params}));this.h[e]=s}return this.h[e]}hasCallback(t){for(const e of this.u.plugins)if(t in e)return!0;return!1}async runCallbacks(t,e){for(const s of this.iterateCallbacks(t))await s(e)}*iterateCallbacks(t){for(const e of this.u.plugins)if("function"==typeof e[t]){const s=this.m.get(e),r=r=>{const n=l({},r,{state:s});return e[t](n)};yield r}}waitUntil(t){return this.p.push(t),t}async doneWaiting(){let t;for(;t=this.p.shift();)await t}destroy(){this.l.resolve()}async g(t){let e=t,s=!1;for(const t of this.iterateCallbacks("cacheWillUpdate"))if(e=await t({request:this.request,response:e,event:this.event})||void 0,s=!0,!e)break;return s||e&&200!==e.status&&(e=void 0),e}}t.CacheFirst=class extends class{constructor(t={}){this.cacheName=f(t.cacheName),this.plugins=t.plugins||[],this.fetchOptions=t.fetchOptions,this.matchOptions=t.matchOptions}handle(t){const[e]=this.handleAll(t);return e}handleAll(t){t instanceof FetchEvent&&(t={event:t,request:t.request});const e=t.event,s="string"==typeof t.request?new Request(t.request):t.request,r="params"in t?t.params:void 0,n=new v(this,{event:e,request:s,params:r}),i=this.q(n,s,e);return[i,this.R(i,n,s,e)]}async q(t,e,r){let n;await t.runCallbacks("handlerWillStart",{event:r,request:e});try{if(n=await this.C(e,t),!n||"error"===n.type)throw new s("no-response",{url:e.url})}catch(s){for(const i of t.iterateCallbacks("handlerDidError"))if(n=await i({error:s,event:r,request:e}),n)break;if(!n)throw s}for(const s of t.iterateCallbacks("handlerWillRespond"))n=await s({event:r,request:e,response:n});return n}async R(t,e,s,r){let n,i;try{n=await t}catch(i){}try{await e.runCallbacks("handlerDidRespond",{event:r,request:s,response:n}),await e.doneWaiting()}catch(t){i=t}if(await e.runCallbacks("handlerDidComplete",{event:r,request:s,response:n,error:i}),e.destroy(),i)throw i}}{async C(t,e){let r,n=await e.cacheMatch(t);if(!n)try{n=await e.fetchAndCachePut(t)}catch(t){r=t}if(!n)throw new s("no-response",{url:t.url,error:r});return n}},t.clientsClaim=function(){self.addEventListener("activate",(()=>self.clients.claim()))},t.registerRoute=function(t,e,r){let o;if("string"==typeof t){const s=new URL(t,location.href);o=new n((({url:t})=>t.href===s.href),e,r)}else if(t instanceof RegExp)o=new i(t,e,r);else if("function"==typeof t)o=new n(t,e,r);else{if(!(t instanceof n))throw new s("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});o=t}return c().registerRoute(o),o}}));//# sourceMappingURL=workbox-ef7ec2a4.js.map</arguments.length;e++){var>]]></content>
    
    
      
      
    <summary type="html">define(&quot;./workbox-ef7ec2a4.js&quot;,[&quot;exports&quot;],(function(t){&quot;use strict&quot;;try{self[&quot;workbox:core:6.1.5&quot;]&amp;&amp;_()}catch(t){}const e=(t,...e)=&gt;{let s=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangxu1905.github.io/2022/02/02/public/service-worker/"/>
    <id>http://wangxu1905.github.io/2022/02/02/public/service-worker/</id>
    <published>2022-02-02T13:52:10.389Z</published>
    <updated>2022-02-02T13:52:35.891Z</updated>
    
    <content type="html"><![CDATA[if(!self.define){const e=e=>{"require"!==e&&(e+=".js");let r=Promise.resolve();return t[e]||(r=new Promise((async r=>{if("document"in self){const t=document.createElement("script");t.src=e,document.head.appendChild(t),t.onload=r}else importScripts(e),r()}))),r.then((()=>{if(!t[e])throw new Error(`Module ${e} didn’t register its module`);return t[e]}))},r=(r,t)=>{Promise.all(r.map(e)).then((e=>t(1===e.length?e[0]:e)))},t={require:Promise.resolve(r)};self.define=(r,s,o)=>{t[r]||(t[r]=Promise.resolve().then((()=>{let t={};const i={uri:location.origin+r.slice(1)};return Promise.all(s.map((r=>{switch(r){case"exports":return t;case"module":return i;default:return e(r)}}))).then((e=>{const r=o(...e);return t.default||(t.default=r),t}))})))}}define("./service-worker.js",["./workbox-ef7ec2a4"],(function(e){"use strict";self.skipWaiting(),e.clientsClaim(),e.registerRoute(/^https:\/\/cdn\.example\.com\/.*/,new e.CacheFirst,"GET")}));//# sourceMappingURL=service-worker.js.map]]></content>
    
    
      
      
    <summary type="html">if(!self.define){const e=e=&gt;{&quot;require&quot;!==e&amp;&amp;(e+=&quot;.js&quot;);let r=Promise.resolve();return t[e]||(r=new Promise((async r=&gt;{if(&quot;document&quot;in self){</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>L3-001 凑零钱 (30 分)</title>
    <link href="http://wangxu1905.github.io/2022/02/02/L3-001%20%E5%87%91%E9%9B%B6%E9%92%B1%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/02/02/L3-001%20%E5%87%91%E9%9B%B6%E9%92%B1%20(30%20%E5%88%86)/</id>
    <published>2022-02-02T13:46:55.884Z</published>
    <updated>2022-02-02T13:51:37.446Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>韩梅梅喜欢满宇宙到处逛街。现在她逛到了一家火星店里，发现这家店有个特别的规矩：你可以用任何星球的硬币付钱，但是绝不找零，当然也不能欠债。韩梅梅手边有 104 枚来自各个星球的硬币，需要请你帮她盘算一下，是否可能精确凑出要付的款额。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出两个正整数：<em>N</em>（≤104）是硬币的总个数，<em>M</em>（≤102）是韩梅梅要付的款额。第二行给出 <em>N</em> 枚硬币的正整数面值。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出硬币的面值 <em>V</em>1≤<em>V</em>2≤⋯≤<em>V**k</em>，满足条件 <em>V</em>1+<em>V</em>2+…+<em>V**k</em>=<em>M</em>。数字间以 1 个空格分隔，行首尾不得有多余空格。若解不唯一，则输出最小序列。若无解，则输出 <code>No Solution</code>。</p><p>注：我们说序列{ <em>A</em>[1],<em>A</em>[2],⋯ }比{ <em>B</em>[1],<em>B</em>[2],⋯ }“小”，是指存在 <em>k</em>≥1 使得 <em>A</em>[<em>i</em>]=<em>B</em>[<em>i</em>] 对所有 <em>i</em>&lt;<em>k</em> 成立，并且 <em>A</em>[<em>k</em>]&lt;<em>B</em>[<em>k</em>]。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No Solution</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    01背包，重量和价值同值。因为要输出从小到大的排列，所以先从大到小按面额进行排序，然后看看小面值弄否把大面值代替，然后choice记录路径</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,flag,val[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10001</span>],choice[<span class="number">10001</span>][<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">    <span class="built_in">sort</span>(val + <span class="number">1</span>, val + <span class="number">1</span> + n ,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= val[i]; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j - val[i]] + val[i] &gt;= dp[j])&#123;</span><br><span class="line">                dp[j] = dp[j - val[i]] + val[i];</span><br><span class="line">                choice[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[m] != m)   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n,j = m; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(choice[i][j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                <span class="keyword">else</span>        flag = <span class="number">1</span>;</span><br><span class="line">                cout &lt;&lt; val[i];</span><br><span class="line">                j -= val[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;韩梅梅喜欢满宇宙到处逛街。现在她逛到了一家火星店里，发现这家店有个特别的规矩：你可以用任何星球的硬币付钱，但是绝不找零，当然也不能欠债。韩梅梅手边有 104 枚来自各个星球的硬币，需要请你帮她盘算一下，是否可能精确凑出要付的</summary>
      
    
    
    
    
    <category term="天梯赛" scheme="http://wangxu1905.github.io/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    
    <category term="01背包" scheme="http://wangxu1905.github.io/tags/01%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>C++ STL set的函数</title>
    <link href="http://wangxu1905.github.io/2022/01/21/C++%20STL%20set%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>http://wangxu1905.github.io/2022/01/21/C++%20STL%20set%E7%9A%84%E5%87%BD%E6%95%B0/</id>
    <published>2022-01-21T14:38:48.999Z</published>
    <updated>2022-01-21T14:53:40.359Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>set lower_bound()返回的是第一个大于等于x的迭代器；</p><p>set upper_bound() 第一个大于x的迭代器；</p><p>如果没找到，返回set.end() （好像是容器的大小）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        s.<span class="built_in">insert</span>(i);</span><br><span class="line">    cout &lt;&lt; *s.<span class="built_in">lower_bound</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">//输出3</span></span><br><span class="line">    cout &lt;&lt; *s.<span class="built_in">upper_bound</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">//输出4</span></span><br><span class="line">    cout &lt;&lt; *s.<span class="built_in">upper_bound</span>(<span class="number">11</span>) &lt;&lt; endl; <span class="comment">//返回s.end(),好像s.end()存的是set容器的大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    然后是multiset，直接使用erase的话，是删除所有和值相等的元素，如果值删除单个元素，需要先通过find返回一个元素的迭代器，通过迭代器删除，这样就只删除一个了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*s.erase(1);</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; s.size() &lt;&lt; endl;*/</span></span><br><span class="line">    s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(<span class="number">1</span>));</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;set lower_bound()返回的是第一个大于等于x的迭代器；&lt;/p&gt;
&lt;p&gt;set upper_bound() 第一个大于x的迭代器；&lt;/p&gt;
&lt;p&gt;如果没找到，返回set.end() （好像是容器的大小）&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="STL" scheme="http://wangxu1905.github.io/tags/STL/"/>
    
    <category term="set" scheme="http://wangxu1905.github.io/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>P1439 【模板】最长公共子序列</title>
    <link href="http://wangxu1905.github.io/2022/01/21/P1439%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://wangxu1905.github.io/2022/01/21/P1439%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2022-01-21T14:15:55.413Z</published>
    <updated>2022-01-21T14:26:58.677Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出 1,2,…,n 的两个排列 P_1 和 P_2 ，求它们的最长公共子序列。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个数 n。</p><p>接下来两行，每行为 n个数，为自然数 1,2,…,n的一个排列。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数，即最长公共子序列的长度。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 </span><br><span class="line">3 2 1 4 5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><ul><li>对于 50% 的数据，n≤10^3；</li><li>对于 100% 的数据，n≤10^5。</li></ul><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    我们可以将第一个串作为标准，用第二串匹配第一个串。</p><p>​    我们可以对第一个串通过map进行离散化，用数字对应它的数组下标，然后将第二个串按照上面的对应方式进行离散化表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> 如果我们把他变成 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">    那么 <span class="number">3</span> - <span class="number">1</span>；<span class="number">2</span> - <span class="number">2</span>；<span class="number">1</span> - <span class="number">3</span>；<span class="number">4</span> - <span class="number">4</span>；<span class="number">5</span>- <span class="number">5</span></span><br><span class="line">第二个串按照上述对应原则</span><br><span class="line">    则由 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> 变成了 <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>​    我们将第一个串进行离散化后，满足了第一个串是上升的，那么加入第二串离散化后满足连续上升的也就是第一个串的排列顺序。</p><p>​    最后问题就变成求一个串的最长不下降序列</p><p>​    一种是数组二分，一种是set二分，set自带二分查找，由于返回的是迭代器，不能修改值，所以只能先删除，后加入新值</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    a.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        m[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        a[i] = m[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">fill</span>(dp + <span class="number">1</span>,dp + n + <span class="number">1</span>,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        *<span class="built_in">lower_bound</span>(dp + <span class="number">1</span>,dp+n + <span class="number">1</span>,a[i]) = a[i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">lower_bound</span>(dp + <span class="number">1</span>,dp + n + <span class="number">1</span>,<span class="number">0x3f3f3f3f</span>) - (dp + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    a.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        m[t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        a[i] = m[t];</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = dp.<span class="built_in">lower_bound</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span>(it != dp.<span class="built_in">end</span>())</span><br><span class="line">            dp.<span class="built_in">erase</span>(it);</span><br><span class="line">        dp.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给出 1,2,…,n 的两个排列 P_1 和 P_2 ，求它们的最长公共子</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-15 可怜的复杂度 (30 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/21/7-15%20%E5%8F%AF%E6%80%9C%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/21/7-15%20%E5%8F%AF%E6%80%9C%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%20(30%20%E5%88%86)/</id>
    <published>2022-01-21T02:35:46.037Z</published>
    <updated>2022-01-21T03:01:31.979Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>可怜有一个数组 <em>A</em>，定义它的复杂度 <em>c</em>(<em>A</em>) 等于它本质不同的子区间个数。举例来说，<em>c</em>([1,1,1])=3，因为 [1,1,1] 只有 3 个本质不同的子区间 [1]、[1,1] 和 [1,1,1]；而 <em>c</em>([1,2,1])=5，它包含 5 个本质不同的子区间 [1]、[2]、[1,2]、[2,1]、[1,2,1]。</p><p>可怜打算出一道和复杂度相关的题目。众所周知，引入随机性往往可以让一个简单的题目脱胎换骨。现在，可怜手上有一个长度为 <em>n</em> 的正整数数组 <em>x</em> 和一个正整数 <em>m</em>。接着，可怜会独立地随机产生 <em>n</em> 个 [1,<em>m</em>] 中的随机整数 <em>y**i</em>，并把 <em>x**i</em> 修改为 <em>m<strong>x</strong>i</em>+<em>y**i</em>。</p><p>显然，一共有 <em>N</em>=<em>m**n</em> 种可能的结果数组。现在，可怜想让你求出这 <em>N</em> 个数组的复杂度的和。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行给出一个整数 <em>t</em> (1≤<em>t</em>≤5) 表示数据组数。</p><p>对于每组数据，第一行输入两个整数 <em>n</em> 和 <em>m</em> (1≤<em>n</em>≤100,1≤<em>m</em>≤109)，第二行是 <em>n</em> 个空格隔开的整数表示数组 <em>x</em> 的初始值 (1≤<em>x**i</em>≤109)。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对于每组数据，输出一行一个整数表示答案。答案可能很大，你只需要输出对 998244353 取模后的结果。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">10</span> <span class="number">2</span></span><br><span class="line"><span class="number">80582987</span> <span class="number">187267045</span> <span class="number">80582987</span> <span class="number">187267045</span> <span class="number">80582987</span> <span class="number">187267045</span> <span class="number">80582987</span> <span class="number">187267045</span> <span class="number">80582987</span> <span class="number">187267045</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">44</span></span><br><span class="line"><span class="number">404</span></span><br><span class="line"><span class="number">44616</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    没什么想法，太难了，骗点分就行了。巨佬出的题果然强，同时我也巨菜。</p><p>​    简单点，就是骗m = 1和m = 2的分</p><p>​    就是根据n个数，枚举里面有所有的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当n = <span class="number">3</span>,m = <span class="number">2</span>时</span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">    <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line">    <span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>然后根据这些情况通过next_permutation计算全排列。</p><p>计算一共有多少子区间，采用set的不存储重复元素的特性，按照区间里有1,2,3…n个元素，进行插入，循环一次就把set的容量大小加入到res中</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll t, n, m;</span><br><span class="line">ll arr[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; t; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                cin &gt;&gt; arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= n; ++j) &#123; <span class="comment">//一次几个</span></span><br><span class="line">                set&lt;vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt;  s;</span><br><span class="line">                <span class="keyword">for</span>(ll k = <span class="number">0</span>; k &lt; n; ++k) &#123; <span class="comment">//从哪里开始</span></span><br><span class="line">                    vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; v;</span><br><span class="line">                    <span class="keyword">if</span>(k + j &lt;= n) &#123;</span><br><span class="line">                        <span class="keyword">for</span>(ll h = <span class="number">0</span>; h &lt; j; ++h) &#123;</span><br><span class="line">                            v.<span class="built_in">push_back</span>(arr[k + h]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(v.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">                        s.<span class="built_in">insert</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">                res += s.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(m == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(ll j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                cin &gt;&gt; arr[j];</span><br><span class="line">                arr[j] *= m;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">            <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                vector&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">                <span class="keyword">for</span>(ll j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">                    num.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(ll j = i; j &lt; n; ++j)</span><br><span class="line">                    num.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">                v.<span class="built_in">push_back</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;v的size &quot; &lt;&lt; v.size() &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">for</span>(ll a = <span class="number">0</span>; a &lt; v.<span class="built_in">size</span>(); ++a) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(ll j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                        arr[j] += v[a][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= n; ++j) &#123; <span class="comment">//一次几个</span></span><br><span class="line">                        set&lt;vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt;  s;</span><br><span class="line">                        <span class="keyword">for</span>(ll k = <span class="number">0</span>; k &lt; n; ++k) &#123; <span class="comment">//从哪里开始</span></span><br><span class="line">                            vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ve;</span><br><span class="line">                            <span class="keyword">if</span>(k + j &lt;= n) &#123;</span><br><span class="line">                                <span class="keyword">for</span>(ll h = <span class="number">0</span>; h &lt; j; ++h) &#123;</span><br><span class="line">                                    ve.<span class="built_in">push_back</span>(arr[k + h]);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span>(ve.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">                                s.<span class="built_in">insert</span>(ve);</span><br><span class="line">                        &#125;</span><br><span class="line">                        res += s.<span class="built_in">size</span>();</span><br><span class="line">                        res %= <span class="number">998244353</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//消除增加值的影响</span></span><br><span class="line">                    <span class="keyword">for</span>(ll j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                        arr[j] -= v[a][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span>(<span class="built_in">next_permutation</span>(v[a].<span class="built_in">begin</span>(), v[a].<span class="built_in">end</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;可怜有一个数组 &lt;em&gt;A&lt;/em&gt;，定义它的复杂度 &lt;em&gt;c&lt;/em&gt;(&lt;em&gt;A&lt;/em&gt;) 等于它本质不同的子区间个数。举例来说，&lt;em&gt;c&lt;/em&gt;([1,1,1])=3，因为 [1,1,1] 只有 3 个本质不同</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-14 森森旅游 (30 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/21/7-14%20%E6%A3%AE%E6%A3%AE%E6%97%85%E6%B8%B8%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/21/7-14%20%E6%A3%AE%E6%A3%AE%E6%97%85%E6%B8%B8%20(30%20%E5%88%86)/</id>
    <published>2022-01-21T02:02:23.513Z</published>
    <updated>2022-01-21T02:34:32.609Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>好久没出去旅游啦！森森决定去 Z 省旅游一下。</p><p>Z 省有 <em>n</em> 座城市（从 1 到 <em>n</em> 编号）以及 <em>m</em> 条连接两座城市的有向旅行线路（例如自驾、长途汽车、火车、飞机、轮船等），每次经过一条旅行线路时都需要支付该线路的费用（但这个收费标准可能不止一种，例如车票跟机票一般不是一个价格）。</p><p>Z 省为了鼓励大家在省内多逛逛，推出了<strong>旅游金计划</strong>：在 <em>i</em> 号城市可以用 1 元现金兑换 <em>a**i</em> 元旅游金（只要现金足够，可以无限次兑换）。城市间的交通即可以使用现金支付路费，也可以用旅游金支付。具体来说，当通过第 <em>j</em> 条旅行线路时，可以用 <em>c**j</em> 元现金<strong>或</strong> <em>d**j</em> 元旅游金支付路费。<strong>注意：</strong> 每次只能选择一种支付方式，不可同时使用现金和旅游金混合支付。但对于不同的线路，旅客可以自由选择不同的支付方式。</p><p>森森决定从 1 号城市出发，到 <em>n</em> 号城市去。他打算在出发前准备一些现金，并在途中的某个城市将剩余现金 <strong>全部</strong> 换成旅游金后继续旅游，直到到达 <em>n</em> 号城市为止。当然，他也可以选择在 1 号城市就兑换旅游金，或全部使用现金完成旅程。</p><p>Z 省政府会根据每个城市参与活动的情况调整汇率（即调整在某个城市 1 元现金能换多少旅游金）。现在你需要帮助森森计算一下，在每次调整之后最少需要携带多少现金才能完成他的旅程。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在第一行给出三个整数 <em>n</em>，<em>m</em> 与 <em>q</em>（1≤<em>n</em>≤105，1≤<em>m</em>≤2×105，1≤<em>q</em>≤105），依次表示城市的数量、旅行线路的数量以及汇率调整的次数。</p><p>接下来 <em>m</em> 行，每行给出四个整数 <em>u</em>，<em>v</em>，<em>c</em> 与 <em>d</em>（1≤<em>u</em>,<em>v</em>≤<em>n</em>，1≤<em>c</em>,<em>d</em>≤109），表示一条从 <em>u</em> 号城市通向 <em>v</em> 号城市的有向旅行线路。每次通过该线路需要支付 <em>c</em> 元现金或 <em>d</em> 元旅游金。数字间以空格分隔。输入保证从 1 号城市出发，一定可以通过若干条线路到达 <em>n</em> 号城市，但两城市间的旅行线路可能不止一条，对应不同的收费标准；也允许在城市内部游玩（即 <em>u</em> 和 <em>v</em> 相同）。</p><p>接下来的一行输入 <em>n</em> 个整数 <em>a</em>1,<em>a</em>2,⋯,<em>a**n</em>（1≤<em>a**i</em>≤109），其中 <em>a**i</em> 表示一开始在 <em>i</em> 号城市能用 1 元现金兑换 <em>a**i</em> 个旅游金。数字间以空格分隔。</p><p>接下来 <em>q</em> 行描述汇率的调整。第 <em>i</em> 行输入两个整数 <em>x**i</em> 与 <em>a**i</em>′（1≤<em>x**i</em>≤<em>n</em>，1≤<em>a**i</em>′≤109），表示第 <em>i</em> 次汇率调整后，<em>x**i</em> 号城市能用 1 元现金兑换 <em>a**i</em>′ 个旅游金，而其它城市旅游金汇率不变。<strong>请注意：</strong>每次汇率调整都是在上一次汇率调整的基础上进行的。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每一次汇率调整，在对应的一行中输出调整后森森至少需要准备多少现金，才能按他的计划从 1 号城市旅行到 <em>n</em> 号城市。</p><p><strong>再次提醒：</strong>如果森森决定在途中的某个城市兑换旅游金，那么他必须将剩余现金<strong>全部、一次性</strong>兑换，剩下的旅途将完全使用旅游金支付。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">11</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">8</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">8</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">10</span> <span class="number">8</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">10</span> <span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">10</span> <span class="number">12</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">10</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">5</span> <span class="number">100</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">17</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释:"></a>样例解释:</h3><p>对于第一次汇率调整，森森可以沿着 1→2→4→6 的线路旅行，并在 2 号城市兑换旅游金；</p><p>对于第二次汇率调整，森森可以沿着 1→2→3→4→6 的线路旅行，并在 3 号城市兑换旅游金；</p><p>对于第三次汇率调整，森森可以沿着 1→3→5→6 的线路旅行，并在 1 号城市兑换旅游金。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    不亏是L3的题，就是不会。参考的柳神（柳婼）的代码。</p><p>​    整体来讲是Dijstra，只是参数量变多了，而且需要一次正向，一次反向。</p><ol><li>使用现金从城市1出发，计算到达所有城市的最小花费，保存在dis1中</li><li>使用旅游金从城市n出发，计算到达所有城市的最小花费，保存在dis2中</li><li>这样我们枚举所有的中转点，得到在第i个城市将现金换成旅游金的情况下需要的现金总额，即从城市1到达城市i的现金加上从城市n到达城市i的旅游金除以城市i的汇率，就可以得到在城市i兑换所需要的总现金费用，保存在cost[i]中</li><li>big[i]存储城市i的汇率</li><li>注意最后的总现金费用保存在multiset,因为可能会出现两条及两条以上最优路线，更改汇率后，在multiset删除cost[i]的值，然后插入新的计算值 </li></ol><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//注意由于是long long 所以用long long的最大值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF LLONG_MAX</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> big[<span class="number">100005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dis;</span><br><span class="line">    <span class="comment">//这个地方很新奇，以前没遇见过，运算符重载</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">int</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.dis &gt; b.dis; <span class="comment">//注意这是递减排序，但sort反向</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; cost1[<span class="number">100005</span>]; <span class="comment">//存储现金支付</span></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; cost2[<span class="number">100005</span>]; <span class="comment">//存储现旅游金支付</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis1[<span class="number">100005</span>], dis2[<span class="number">1000005</span>]; <span class="comment">//正反向的遍历</span></span><br><span class="line"><span class="comment">//优先队列的Dijstra</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> s,vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; cost[],<span class="keyword">long</span> <span class="keyword">long</span> dis[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> visited[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="built_in">fill</span>(dis + <span class="number">1</span>,dis + n + <span class="number">1</span>,INF);</span><br><span class="line">    <span class="comment">//源点到源点距离为0</span></span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;Node&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(Node&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = qu.<span class="built_in">top</span>().id;</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(visited[t])  <span class="keyword">continue</span>;</span><br><span class="line">        visited[t] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)cost[t].<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> v = cost[t][i].first,w = cost[t][i].second;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[t] + w)&#123;</span><br><span class="line">                dis[v] = dis[t] + w;</span><br><span class="line">                qu.<span class="built_in">push</span>(Node&#123;v,dis[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a, b, c, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">        <span class="comment">//正向和反向各存一遍</span></span><br><span class="line">        cost1[a].<span class="built_in">push_back</span>(&#123;b, c&#125;);</span><br><span class="line">        cost2[b].<span class="built_in">push_back</span>(&#123;a, d&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;big[i]);</span><br><span class="line">    <span class="comment">//正反向计算最短路</span></span><br><span class="line">    <span class="built_in">dijstra</span>(<span class="number">1</span>,cost1,dis1);</span><br><span class="line">    <span class="built_in">dijstra</span>(n,cost2,dis2);</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">cost</span><span class="params">(n + <span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    multiset&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s;</span><br><span class="line">    <span class="comment">//如果没有路，就不插入，否则就计算总现金花费，注意要向上取整</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">       <span class="keyword">if</span>(dis1[i] == INF || dis2[i] == INF)    <span class="keyword">continue</span>;</span><br><span class="line">       s.<span class="built_in">insert</span>(cost[i] = dis1[i] + <span class="built_in">ceil</span>(<span class="number">1.0</span> * dis2[i] / big[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">//看看修改汇率的城市是否有路或者汇率不变</span></span><br><span class="line">        <span class="keyword">if</span>(cost[a] != <span class="number">0</span> &amp;&amp; b != big[a])&#123;</span><br><span class="line">            big[a] = b;</span><br><span class="line">            <span class="comment">/*这里是multiset，直接删除值的话，会删除对应值的所有元素，所以只能删除传一个迭代器，删除一个元素*/</span></span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(cost[a]));</span><br><span class="line">            s.<span class="built_in">insert</span>(cost[a] = dis1[a] + <span class="built_in">ceil</span>(<span class="number">1.0</span> * dis2[a] / big[a]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,*s.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;好久没出去旅游啦！森森决定去 Z 省旅游一下。&lt;/p&gt;
&lt;p&gt;Z 省有 &lt;em&gt;n&lt;/em&gt; 座城市（从 1 到 &lt;em&gt;n&lt;/em&gt; 编号）以及 &lt;em&gt;m&lt;/em&gt; 条连接两座城市的有向旅行线路（例如自驾、长途汽车、火车</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-13 社交集群 (30 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/20/7-13%20%E7%A4%BE%E4%BA%A4%E9%9B%86%E7%BE%A4%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/20/7-13%20%E7%A4%BE%E4%BA%A4%E9%9B%86%E7%BE%A4%20(30%20%E5%88%86)/</id>
    <published>2022-01-20T15:34:56.047Z</published>
    <updated>2022-01-20T15:57:16.240Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>当你在社交网络平台注册时，一般总是被要求填写你的个人兴趣爱好，以便找到具有相同兴趣爱好的潜在的朋友。一个“社交集群”是指部分兴趣爱好相同的人的集合。你需要找出所有的社交集群。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个正整数 N（≤1000），为社交网络平台注册的所有用户的人数。于是这些人从 1 到 N 编号。随后 N 行，每行按以下格式给出一个人的兴趣爱好列表：</p><p><em>K**i</em>: <em>h**i</em>[1] <em>h**i</em>[2] … <em>h**i</em>[<em>K**i</em>]</p><p>其中<em>K**i</em>(&gt;0)是兴趣爱好的个数，<em>h**i</em>[<em>j</em>]是第<em>j</em>个兴趣爱好的编号，为区间 [1, 1000] 内的整数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在一行中输出不同的社交集群的个数。随后第二行按非增序输出每个集群中的人数。数字间以一个空格分隔，行末不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">3</span>: <span class="number">2</span> <span class="number">7</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span>: <span class="number">4</span></span><br><span class="line"><span class="number">2</span>: <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>: <span class="number">4</span></span><br><span class="line"><span class="number">1</span>: <span class="number">3</span></span><br><span class="line"><span class="number">1</span>: <span class="number">4</span></span><br><span class="line"><span class="number">4</span>: <span class="number">6</span> <span class="number">8</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    虽然知道是并查集，但我还是应付不过一点点的改变，代码我改的不太优雅，从网上发现一种特别好的解法</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">10001</span>],arr[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[s] == s) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">return</span> father[s] = <span class="built_in">Find</span>(father[s]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root1 = <span class="built_in">Find</span>(a),root2 = <span class="built_in">Find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(root1 != root2)  father[root2] = root1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i)</span><br><span class="line">        father[i] = i;</span><br><span class="line">    <span class="comment">/*将每个人首个兴趣存入数组，用来代表人，然后他的其他兴趣都已第一个兴趣为根*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> k,t;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        cin &gt;&gt; k &gt;&gt; c &gt;&gt; arr[i];</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            <span class="built_in">Union</span>(arr[i],t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后用map存每个集合的人数，map的元素个数是集合的数量</span></span><br><span class="line">    <span class="comment">/*因为每个人用首个兴趣代替，只要找到每个人首个兴趣所属的集合，就等于给人确定了集合*/</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">Find</span>(arr[i]);</span><br><span class="line">        m[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//注意最后的集合人数可能会重复，所以用multiset,反向遍历</span></span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        s.<span class="built_in">insert</span>(it -&gt; second);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = s.<span class="built_in">rbegin</span>(); it != s.<span class="built_in">rend</span>(); it++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>        flag = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;当你在社交网络平台注册时，一般总是被要求填写你的个人兴趣爱好，以便找到具有相同兴趣爱好的潜在的朋友。一个“社交集群”是指部分兴趣爱好相同的人的集合。你需要找出所有的社交集群。&lt;/p&gt;
&lt;h3 id=&quot;输入格式：&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-12 红色警报 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/20/7-12%20%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%8A%A5%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/20/7-12%20%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%8A%A5%20(25%20%E5%88%86)/</id>
    <published>2022-01-20T14:04:46.882Z</published>
    <updated>2022-01-20T14:50:23.077Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出两个整数<code>N</code>（0 &lt; <code>N</code> ≤ 500）和<code>M</code>（≤ 5000），分别为城市个数（于是默认城市从0到<code>N</code>-1编号）和连接两城市的通路条数。随后<code>M</code>行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数<code>K</code>和随后的<code>K</code>个被攻占的城市的编号。</p><p>注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个被攻占的城市，如果它会改变整个国家的连通性，则输出<code>Red Alert: City k is lost!</code>，其中<code>k</code>是该城市的编号；否则只输出<code>City k is lost.</code>即可。如果该国失去了最后一个城市，则增加一行输出<code>Game Over.</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">City <span class="number">1</span> is lost.</span><br><span class="line">City <span class="number">2</span> is lost.</span><br><span class="line">Red Alert: City <span class="number">0</span> is lost!</span><br><span class="line">City <span class="number">4</span> is lost.</span><br><span class="line">City <span class="number">3</span> is lost.</span><br><span class="line">Game Over.</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    两种思路，一种dfs，一种并查集</p><p>​    自己想到的是dfs，可能上课讲的时候就是由dfs或者bfs求连通分量数所以想到的是dfs，并查集当时没想到，看到网上的题解后才意识到可以。</p><p>​    题目简单来说就是计算连通分支数，如果删除结点后，连通分支数的增量超过1,说明删除结点后使得其他某个结点也变得不联通，此时改变了整体的连通性，所以发出警报。其中如果删除了最后一座城市，则输出Game Over.</p><p>​    好像dfs要比并查集快得多</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; mar;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> visited[<span class="number">501</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    visited[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mar[s].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[mar[s][i]])</span><br><span class="line">            <span class="built_in">dfs</span>(mar[s][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    mar.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        mar[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        mar[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, k;</span><br><span class="line">    <span class="comment">//就算最初的连通分支数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="comment">//初始化visited数组</span></span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="comment">//将删除的结点存储数组，并标记为已访问，防止dfs时作为中间结点</span></span><br><span class="line">        v.<span class="built_in">push_back</span>(t);</span><br><span class="line">        <span class="comment">//连通分支数首先初始化为已经删除结点的个数</span></span><br><span class="line">        <span class="keyword">int</span> num2 = v.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            visited[v[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算连通分支数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j]) &#123;</span><br><span class="line">                num2++;</span><br><span class="line">                <span class="built_in">dfs</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果增量超过1，则发出红色警报</span></span><br><span class="line">        <span class="keyword">if</span>(num2 &gt; num + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Red Alert: City %d is lost!\n&quot;</span>, t);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;City %d is lost.\n&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新连通分支数</span></span><br><span class="line">        num = num2;</span><br><span class="line">        <span class="comment">//判断是否是最后一个结点</span></span><br><span class="line">        <span class="keyword">if</span>(i == n - <span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">&quot;Game Over.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, m,k,flag;</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">501</span>],mar[<span class="number">501</span>][<span class="number">501</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x] == <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> father[x] = <span class="built_in">Find</span>(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root1 = <span class="built_in">Find</span>(a),root2 = <span class="built_in">Find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(root1 != root2)</span><br><span class="line">        father[root2] = root1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountPart</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(father[i] == <span class="number">-1</span>) num++;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(father,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(father));</span><br><span class="line">    <span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        mar[a][b] = mar[b][a] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">Union</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算连通分支数</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">CountPart</span>();</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="comment">//判断最后是否需要输出Game Over</span></span><br><span class="line">    <span class="keyword">if</span>(k == n)  flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="keyword">int</span> t,num2 = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="comment">//初始化并查集</span></span><br><span class="line">        <span class="built_in">memset</span>(father,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(father));</span><br><span class="line">        <span class="comment">//删除结点连接的所有路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  </span><br><span class="line">            mar[t][i] = mar[i][t] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//更新并查集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; ++j)</span><br><span class="line">                <span class="keyword">if</span>(mar[i][j])   <span class="built_in">Union</span>(i,j);</span><br><span class="line">        <span class="comment">//计算新的连通分支数</span></span><br><span class="line">        num2 = <span class="built_in">CountPart</span>();</span><br><span class="line">        <span class="keyword">if</span>(num2 &gt; num + <span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">&quot;Red Alert: City %d is lost!\n&quot;</span>, t);</span><br><span class="line">        <span class="keyword">else</span>                <span class="built_in">printf</span>(<span class="string">&quot;City %d is lost.\n&quot;</span>, t);</span><br><span class="line">        num = num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)    <span class="built_in">printf</span>(<span class="string">&quot;Game Over.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
</feed>
