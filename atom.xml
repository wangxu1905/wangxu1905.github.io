<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moon</title>
  
  
  <link href="http://wangxu1905.github.io/atom.xml" rel="self"/>
  
  <link href="http://wangxu1905.github.io/"/>
  <updated>2021-10-27T09:33:06.727Z</updated>
  <id>http://wangxu1905.github.io/</id>
  
  <author>
    <name>Moon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2-3 社交网络图中结点的“重要性”计算 (25 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/27/2-3%20%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E5%9B%BE%E4%B8%AD%E7%BB%93%E7%82%B9%E7%9A%84%E2%80%9C%E9%87%8D%E8%A6%81%E6%80%A7%E2%80%9D%E8%AE%A1%E7%AE%97%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/27/2-3%20%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E5%9B%BE%E4%B8%AD%E7%BB%93%E7%82%B9%E7%9A%84%E2%80%9C%E9%87%8D%E8%A6%81%E6%80%A7%E2%80%9D%E8%AE%A1%E7%AE%97%20(25%20%E5%88%86)/</id>
    <published>2021-10-27T09:27:30.228Z</published>
    <updated>2021-10-27T09:33:06.727Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>在社交网络中，个人或单位（结点）之间通过某些关系（边）联系起来。他们受到这些关系的影响，这种影响可以理解为网络中相互连接的结点之间蔓延的一种相互作用，可以增强也可以减弱。而结点根据其所处的位置不同，其在网络中体现的重要性也不尽相同。</p><p>“紧密度中心性”是用来衡量一个结点到达其它结点的“快慢”的指标，即一个有较高中心性的结点比有较低中心性的结点能够更快地（平均意义下）到达网络中的其它结点，因而在该网络的传播过程中有更重要的价值。在有<em>N</em>个结点的网络中，结点<em>v**i</em>的“紧密度中心性”<em>C**c</em>(<em>v**i</em>)数学上定义为<em>v**i</em>到其余所有结点<em>v**j</em> (<em>j</em>\=<em>i</em>) 的最短距离<em>d</em>(<em>v**i</em>,<em>v**j</em>)的平均值的倒数：</p><p><img src="https://images.ptausercontent.com/54" alt="img"></p><p>对于非连通图，所有结点的紧密度中心性都是0。</p><p>给定一个无权的无向图以及其中的一组结点，计算这组结点中每个结点的紧密度中心性。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第一行给出两个正整数<em>N</em>和<em>M</em>，其中<em>N</em>（≤104）是图中结点个数，顺便假设结点从1到<em>N</em>编号；<em>M</em>（≤105）是边的条数。随后的<em>M</em>行中，每行给出一条边的信息，即该边连接的两个结点编号，中间用空格分隔。最后一行给出需要计算紧密度中心性的这组结点的个数<em>K</em>（≤100）以及<em>K</em>个结点编号，用空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按照<code>Cc(i)=x.xx</code>的格式输出<em>K</em>个给定结点的紧密度中心性，每个输出占一行，结果保留到小数点后2位。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> <span class="number">14</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">9</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Cc</span>(<span class="number">3</span>)=<span class="number">0.47</span></span><br><span class="line"><span class="built_in">Cc</span>(<span class="number">4</span>)=<span class="number">0.62</span></span><br><span class="line"><span class="built_in">Cc</span>(<span class="number">9</span>)=<span class="number">0.35</span>结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码-迪杰斯特拉算法"><a href="#AC代码-迪杰斯特拉算法" class="headerlink" title="AC代码(迪杰斯特拉算法)"></a>AC代码(迪杰斯特拉算法)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 9999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M,K;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">10001</span>][<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijstrak</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[N + <span class="number">1</span>],visited[N + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++i)</span><br><span class="line">        dis[i] = mar[s][i];</span><br><span class="line">    visited[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = F,pos;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N ; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dis[j] &lt; min)&#123;</span><br><span class="line">                min = dis[j];</span><br><span class="line">                pos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min == F)  <span class="keyword">break</span>;</span><br><span class="line">        visited[pos] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dis[j] &gt; dis[pos] + mar[pos][j])</span><br><span class="line">                dis[j] = dis[pos] + mar[pos][j]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ;++i)</span><br><span class="line">            sum += dis[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cc(%d)=%.2f\n&quot;</span>,s,<span class="number">1.0</span> * (N - <span class="number">1</span>) / sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">mar[i][j] = F;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        mar[a][b] = mar[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;++i)</span><br><span class="line">        mar[i][i] = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; K;</span><br><span class="line">    <span class="keyword">while</span>(K--)&#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="built_in">dijstrak</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码-弗洛伊德算法"><a href="#AC代码-弗洛伊德算法" class="headerlink" title="AC代码(弗洛伊德算法)"></a>AC代码(弗洛伊德算法)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 9999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M,K;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">10001</span>][<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyld</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= N; a++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= N; b++)</span><br><span class="line">                <span class="keyword">if</span>(mar[a][b] &gt; mar[a][k] + mar[k][b])</span><br><span class="line">                    mar[a][b] = mar[a][k] + mar[k][b]; <span class="comment">//用点k缩短a与b的距离</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;++i)</span><br><span class="line">        sum += mar[s][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cc(%d)=%.2f\n&quot;</span>,s,<span class="number">1.0</span> * (N - <span class="number">1</span>) / sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">fill</span>(mar[<span class="number">0</span>],mar[<span class="number">0</span>] + <span class="number">100</span> * <span class="number">100</span>,F);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        mar[a][b] = mar[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;++i)</span><br><span class="line">        mar[i][i] = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; K;</span><br><span class="line">    <span class="keyword">while</span>(K--)&#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="built_in">floyld</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;在社交网络中，个人或单位（结点）之间通过某些关系（边）联系起来。他们受到这些关系的影响，这种影响可以理解为网络中相互连接的结点之间蔓延的一种相互作用，可以增强也可以减弱。而结点根据其所处的位置不同，其在网络中体现的重要性也不</summary>
      
    
    
    
    
    <category term="数据结构实验" scheme="http://wangxu1905.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>06-图1 列出连通集 (25 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/24/06-%E5%9B%BE2%20Saving%20James%20Bond%20-%20Easy%20Version%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/24/06-%E5%9B%BE2%20Saving%20James%20Bond%20-%20Easy%20Version%20(25%20%E5%88%86)/</id>
    <published>2021-10-24T07:23:08.290Z</published>
    <updated>2021-10-28T14:06:12.523Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).</p><p>Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing two positive integers <em>N</em> (≤100), the number of crocodiles, and <em>D</em>, the maximum distance that James could jump. Then <em>N</em> lines follow, each containing the (<em>x</em>,<em>y</em>) location of a crocodile. Note that no two crocodiles are staying at the same position.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line “Yes” if James can escape, or “No” if not.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span> <span class="number">20</span></span><br><span class="line"><span class="number">25</span> <span class="number">-15</span></span><br><span class="line"><span class="number">-25</span> <span class="number">28</span></span><br><span class="line"><span class="number">8</span> <span class="number">49</span></span><br><span class="line"><span class="number">29</span> <span class="number">15</span></span><br><span class="line"><span class="number">-35</span> <span class="number">-2</span></span><br><span class="line"><span class="number">5</span> <span class="number">28</span></span><br><span class="line"><span class="number">27</span> <span class="number">-29</span></span><br><span class="line"><span class="number">-8</span> <span class="number">-28</span></span><br><span class="line"><span class="number">-20</span> <span class="number">-35</span></span><br><span class="line"><span class="number">-25</span> <span class="number">-20</span></span><br><span class="line"><span class="number">-13</span> <span class="number">29</span></span><br><span class="line"><span class="number">-30</span> <span class="number">15</span></span><br><span class="line"><span class="number">-35</span> <span class="number">40</span></span><br><span class="line"><span class="number">12</span> <span class="number">12</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="number">-12</span> <span class="number">12</span></span><br><span class="line"><span class="number">12</span> <span class="number">12</span></span><br><span class="line"><span class="number">-12</span> <span class="number">-12</span></span><br><span class="line"><span class="number">12</span> <span class="number">-12</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,D,answer;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> flag;   <span class="comment">//是否访问过</span></span><br><span class="line">    <span class="keyword">int</span> safe;   <span class="comment">//是否可以到达岸边</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> diameter=<span class="number">15</span>;</span><br><span class="line">Node cro[<span class="number">100001</span>];</span><br><span class="line"><span class="comment">//判断当前的位置是否可以到达岸边</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsSafe</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cro[pos].x - D &lt;= <span class="number">-50</span> || cro[pos].x + D &gt;= <span class="number">50</span> || cro[pos].y - D &lt;= <span class="number">-50</span> ||cro[pos].y + D &gt;= <span class="number">50</span>)</span><br><span class="line">        cro[pos].safe = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cro[pos].safe = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cro[pos].safe;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为第一跳要考虑到岛的半径，所以单独写一个函数，判断第一跳能跳到的范围</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstJump</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pow</span>(cro[pos].x,<span class="number">2.0</span>) + <span class="built_in">pow</span>(cro[pos].y,<span class="number">2.0</span>) &lt;= <span class="built_in">pow</span>(D + diameter / <span class="number">2</span>,<span class="number">2.0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断下一个结点是否能跳到</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Jump</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> next)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">pow</span>(cro[cur].x - cro[next].x,<span class="number">2.0</span>) + <span class="built_in">pow</span>(cro[cur].y - cro[next].y,<span class="number">2.0</span>) &lt;= D * D )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先搜索，找到可行解就好</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    cro[pos].flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsSafe</span>(pos)) answer = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cro[i].flag &amp;&amp; <span class="built_in">Jump</span>(pos,i))</span><br><span class="line">                answer = <span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(answer)  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Save007</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//尝试各个连通分量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cro[i].flag &amp;&amp; <span class="built_in">FirstJump</span>(i))&#123;</span><br><span class="line">            answer = <span class="built_in">dfs</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(answer)  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(answer) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; D;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)</span><br><span class="line">        cin &gt;&gt; cro[i].x &gt;&gt; cro[i].y;</span><br><span class="line">    <span class="built_in">Save007</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most fa</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>06-图1 列出连通集 (25 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/24/06-%E5%9B%BE1%20%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/24/06-%E5%9B%BE1%20%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86%20(25%20%E5%88%86)/</id>
    <published>2021-10-24T07:16:35.003Z</published>
    <updated>2021-10-24T07:18:23.478Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定一个有<em>N</em>个顶点和<em>E</em>条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到<em>N</em>−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出2个整数<em>N</em>(0&lt;<em>N</em>≤10)和<em>E</em>，分别是图的顶点数和边数。随后<em>E</em>行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按照”{ <em>v</em>1 <em>v</em>2 … <em>v**k</em> }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">7</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> &#125;</span><br><span class="line">&#123; <span class="number">3</span> <span class="number">5</span> &#125;</span><br><span class="line">&#123; <span class="number">6</span> &#125;</span><br><span class="line">&#123; <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">7</span> <span class="number">4</span> &#125;</span><br><span class="line">&#123; <span class="number">3</span> <span class="number">5</span> &#125;</span><br><span class="line">&#123; <span class="number">6</span> &#125;结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,e;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="keyword">bool</span> book[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">bool</span> book1[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; id;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!book[i] &amp;&amp; mar[id][i] == <span class="number">1</span>)&#123;</span><br><span class="line">            book[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(id);</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = qu.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t;</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!book1[i] &amp;&amp; mar[t][i] == <span class="number">1</span>)&#123;</span><br><span class="line">                book1[i] = <span class="literal">true</span>;</span><br><span class="line">                qu.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; e;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= e; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        mar[a][b] = mar[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!book[i])&#123;</span><br><span class="line">            book[i] = <span class="literal">true</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!book1[i])&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">            book1[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">bfs</span>(i);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定一个有&lt;em&gt;N&lt;/em&gt;个顶点和&lt;em&gt;E&lt;/em&gt;条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到&lt;em&gt;N&lt;/em&gt;−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>05-树9 Huffman Codes (30 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/24/05-%E6%A0%919%20Huffman%20Codes%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/24/05-%E6%A0%919%20Huffman%20Codes%20(30%20%E5%88%86)/</id>
    <published>2021-10-24T06:55:10.794Z</published>
    <updated>2021-10-24T07:16:23.503Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>In 1953, David A. Huffman published his paper “A Method for the Construction of Minimum-Redundancy Codes”, and hence printed his name in the history of computer science. As a professor who gives the final exam problem on Huffman codes, I am encountering a big problem: the Huffman codes are NOT unique. For example, given a string “aaaxuaxz”, we can observe that the frequencies of the characters ‘a’, ‘x’, ‘u’ and ‘z’ are 4, 2, 1 and 1, respectively. We may either encode the symbols as {‘a’=0, ‘x’=10, ‘u’=110, ‘z’=111}, or in another way as {‘a’=1, ‘x’=01, ‘u’=001, ‘z’=000}, both compress the string into 14 bits. Another set of code can be given as {‘a’=0, ‘x’=11, ‘u’=100, ‘z’=101}, but {‘a’=0, ‘x’=01, ‘u’=011, ‘z’=001} is NOT correct since “aaaxuaxz” and “aazuaxax” can both be decoded from the code 00001011001001. The students are submitting all kinds of codes, and I need a computer program to help me determine which ones are correct and which ones are not.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives an integer <em>N</em> (2≤<em>N</em>≤63), then followed by a line that contains all the <em>N</em> distinct characters and their frequencies in the following format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[1] f[1] c[2] f[2] ... c[N] f[N]</span><br></pre></td></tr></table></figure><p>where <code>c[i]</code> is a character chosen from {‘0’ - ‘9’, ‘a’ - ‘z’, ‘A’ - ‘Z’, ‘_’}, and <code>f[i]</code> is the frequency of <code>c[i]</code> and is an integer no more than 1000. The next line gives a positive integer <em>M</em> (≤1000), then followed by <em>M</em> student submissions. Each student submission consists of <em>N</em> lines, each in the format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[i] code[i]</span><br></pre></td></tr></table></figure><p>where <code>c[i]</code> is the <code>i</code>-th character and <code>code[i]</code> is an non-empty string of no more than 63 ‘0’s and ‘1’s.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in each line either “Yes” if the student’s submission is correct, or “No” if not.</p><p>Note: The optimal solution is not necessarily generated by Huffman algorithm. Any prefix code with code length being optimal is considered correct.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line">A <span class="number">1</span> B <span class="number">1</span> C <span class="number">1</span> D <span class="number">3</span> E <span class="number">3</span> F <span class="number">6</span> G <span class="number">6</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">A <span class="number">00000</span></span><br><span class="line">B <span class="number">00001</span></span><br><span class="line">C <span class="number">0001</span></span><br><span class="line">D <span class="number">001</span></span><br><span class="line">E <span class="number">01</span></span><br><span class="line">F <span class="number">10</span></span><br><span class="line">G <span class="number">11</span></span><br><span class="line">A <span class="number">01010</span></span><br><span class="line">B <span class="number">01011</span></span><br><span class="line">C <span class="number">0100</span></span><br><span class="line">D <span class="number">011</span></span><br><span class="line">E <span class="number">10</span></span><br><span class="line">F <span class="number">11</span></span><br><span class="line">G <span class="number">00</span></span><br><span class="line">A <span class="number">000</span></span><br><span class="line">B <span class="number">001</span></span><br><span class="line">C <span class="number">010</span></span><br><span class="line">D <span class="number">011</span></span><br><span class="line">E <span class="number">100</span></span><br><span class="line">F <span class="number">101</span></span><br><span class="line">G <span class="number">110</span></span><br><span class="line">A <span class="number">00000</span></span><br><span class="line">B <span class="number">00001</span></span><br><span class="line">C <span class="number">0001</span></span><br><span class="line">D <span class="number">001</span></span><br><span class="line">E <span class="number">00</span></span><br><span class="line">F <span class="number">10</span></span><br><span class="line">G <span class="number">11</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> heapsize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> heap[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = ++heapsize; data &lt; heap[i / <span class="number">2</span>] ; i /= <span class="number">2</span>)</span><br><span class="line">        heap[i] = heap[i / <span class="number">2</span>];</span><br><span class="line">    heap[i] = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除根节点，然后从第二个结点开始找到第一个比last大的，然后结束循环，进行赋值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = heap[<span class="number">1</span>],i;</span><br><span class="line">    <span class="keyword">int</span> last = heap[heapsize];</span><br><span class="line">    heap[heapsize--] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= heapsize ; i *= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap[i] &gt; heap[i + <span class="number">1</span>] &amp;&amp; i + <span class="number">1</span> &lt;= heapsize) ++i;</span><br><span class="line">        <span class="keyword">if</span>(heap[i] &lt; last) heap[i / <span class="number">2</span>] = heap[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i / <span class="number">2</span>] = last;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否有相同的前缀</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hasPrefixCode</span><span class="params">(string s[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N;++j)</span><br><span class="line">            <span class="keyword">if</span>(s[i].<span class="built_in">find</span>(s[j]) == <span class="number">0</span>)   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,WPL = <span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    heap[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; num;</span><br><span class="line">        m[c] = num;</span><br><span class="line">        <span class="built_in">insert</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = heapsize;</span><br><span class="line">    <span class="comment">//计算WPL</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size ; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp1 = <span class="built_in">Delete</span>(),tmp2 = <span class="built_in">Delete</span>();</span><br><span class="line">        <span class="built_in">insert</span>(tmp1 + tmp2);</span><br><span class="line">        WPL += tmp1 + tmp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> checknum;</span><br><span class="line">    cin &gt;&gt; checknum;</span><br><span class="line">    <span class="keyword">while</span>(checknum--)&#123;</span><br><span class="line">        <span class="keyword">int</span> thiswpl = <span class="number">0</span>;</span><br><span class="line">        string s[N];</span><br><span class="line">        <span class="comment">//先计算wpl</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            <span class="keyword">char</span> c;</span><br><span class="line">            cin &gt;&gt; c &gt;&gt; s[i];</span><br><span class="line">            thiswpl += m[c] * s[i].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先判断WPL是否相等，然后再判断是否有前缀码</span></span><br><span class="line">        <span class="keyword">if</span>(thiswpl == WPL &amp;&amp; !<span class="built_in">hasPrefixCode</span>(s,N))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;In 1953, David A. Huffman published his paper “A Method for the Construction of Minimum-Redundancy Codes”, and h</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>05-树8 File Transfer (25 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/24/05-%E6%A0%918%20File%20Transfer%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/24/05-%E6%A0%918%20File%20Transfer%20(25%20%E5%88%86)/</id>
    <published>2021-10-24T03:31:45.583Z</published>
    <updated>2021-10-24T03:36:25.176Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each test case, the first line contains <em>N</em> (2≤<em>N</em>≤104), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and <em>N</em>. Then in the following lines, the input is given in the format:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I c1 c2  </span><br></pre></td></tr></table></figure><p>where <code>I</code> stands for inputting a connection between <code>c1</code> and <code>c2</code>; or</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C c1 c2    </span><br></pre></td></tr></table></figure><p>where <code>C</code> stands for checking if it is possible to transfer files between <code>c1</code> and <code>c2</code>; or</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S</span><br></pre></td></tr></table></figure><p>where <code>S</code> stands for stopping this case.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each <code>C</code> case, print in one line the word “yes” or “no” if it is possible or impossible to transfer files between <code>c1</code> and <code>c2</code>, respectively. At the end of each case, print in one line “The network is connected.” if there is a path between any pair of computers; or “There are <code>k</code> components.” where <code>k</code> is the number of connected components in this network.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">C <span class="number">3</span> <span class="number">2</span></span><br><span class="line">I <span class="number">3</span> <span class="number">2</span></span><br><span class="line">C <span class="number">1</span> <span class="number">5</span></span><br><span class="line">I <span class="number">4</span> <span class="number">5</span></span><br><span class="line">I <span class="number">2</span> <span class="number">4</span></span><br><span class="line">C <span class="number">3</span> <span class="number">5</span></span><br><span class="line">S</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">There are <span class="number">2</span> components.</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">C <span class="number">3</span> <span class="number">2</span></span><br><span class="line">I <span class="number">3</span> <span class="number">2</span></span><br><span class="line">C <span class="number">1</span> <span class="number">5</span></span><br><span class="line">I <span class="number">4</span> <span class="number">5</span></span><br><span class="line">I <span class="number">2</span> <span class="number">4</span></span><br><span class="line">C <span class="number">3</span> <span class="number">5</span></span><br><span class="line">I <span class="number">1</span> <span class="number">3</span></span><br><span class="line">C <span class="number">1</span> <span class="number">5</span></span><br><span class="line">S</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">The network is connected.</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialization</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++i)</span><br><span class="line">        s[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到根节点，并且压缩路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[x] &lt; <span class="number">0</span>)    <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> s[x] = <span class="built_in">Find</span>(s[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过根节点的数组确定这棵树的结点总数，然后把结点少的接到结点多的树上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> Root1,<span class="keyword">int</span> Root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[Root2] &lt; s[Root1])&#123;</span><br><span class="line">        s[Root2] += s[Root1];</span><br><span class="line">        s[Root1] = Root2;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s[Root1] += s[Root2];</span><br><span class="line">        s[Root2] = Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果两个结点不属于同一个集合，则进行合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input_connection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    <span class="keyword">int</span> Root1 = <span class="built_in">Find</span>(u),Root2 = <span class="built_in">Find</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(Root1 != Root2)</span><br><span class="line">        <span class="built_in">Union</span>(Root1,Root2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查两个结点是否属于同一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Check_connection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    <span class="keyword">int</span> Root1 = <span class="built_in">Find</span>(u),Root2 = <span class="built_in">Find</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(Root1 != Root2)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查有几个集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Check_network</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">if</span>(s[i] &lt; <span class="number">0</span>)    ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The network is connected.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot; components.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">Initialization</span>();</span><br><span class="line">    <span class="keyword">char</span> in;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(in)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span> : <span class="built_in">Input_connection</span>();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span> : <span class="built_in">Check_connection</span>();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span> : <span class="built_in">Check_network</span>();<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(in != <span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;We have a network of computers and a list of bi-directional connections. Each of these connections allows a file</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
    <category term="并查集" scheme="http://wangxu1905.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>05-树7 堆中的路径 (25 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/24/05-%E6%A0%917%20%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/24/05-%E6%A0%917%20%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%20(25%20%E5%88%86)/</id>
    <published>2021-10-24T03:26:11.752Z</published>
    <updated>2021-10-24T03:29:29.380Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>将一系列给定数字插入一个初始为空的小顶堆<code>H[]</code>。随后对任意给定的下标<code>i</code>，打印从<code>H[i]</code>到根结点的路径。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>每组测试第1行包含2个正整数<em>N</em>和<em>M</em>(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的<em>N</em>个要被插入一个初始为空的小顶堆的整数。最后一行给出<em>M</em>个下标。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对输入中给出的每个下标<code>i</code>，在一行中输出从<code>H[i]</code>到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">46</span> <span class="number">23</span> <span class="number">26</span> <span class="number">24</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">24</span> <span class="number">23</span> <span class="number">10</span></span><br><span class="line"><span class="number">46</span> <span class="number">23</span> <span class="number">10</span></span><br><span class="line"><span class="number">26</span> <span class="number">10</span>结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> heap[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> heap_size;<span class="comment">//1~heap_size</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">()</span></span>&#123;</span><br><span class="line">    heap_size = <span class="number">0</span>;</span><br><span class="line">    heap[<span class="number">0</span>] = <span class="number">-100001</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> X)</span></span>&#123;</span><br><span class="line">    heap[++heap_size] = X;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = heap_size;heap[i] &lt; heap[i / <span class="number">2</span>]; i /= <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">swap</span>(heap[i],heap[i / <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">look_heap</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &gt; <span class="number">1</span>; i /= <span class="number">2</span>)</span><br><span class="line">        cout &lt;&lt; heap[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; heap[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,M,t;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">Create</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">Insert</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">look_heap</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;将一系列给定数字插入一个初始为空的小顶堆&lt;code&gt;H[]&lt;/code&gt;。随后对任意给定的下标&lt;code&gt;i&lt;/code&gt;，打印从&lt;code&gt;H[i]&lt;/code&gt;到根结点的路径。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>04-树6 Complete Binary Search Tree (30 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/24/04-%E6%A0%916%20Complete%20Binary%20Search%20Tree%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/24/04-%E6%A0%916%20Complete%20Binary%20Search%20Tree%20(30%20%E5%88%86)/</id>
    <published>2021-10-24T03:19:53.077Z</published>
    <updated>2021-10-24T03:22:30.325Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p><ul><li><p>The left subtree of a node contains only nodes with keys less than the node’s key.</p></li><li><p>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</p></li><li><p>Both the left and right subtrees must also be binary search trees.</p></li></ul><p>A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p><p>Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤1000). Then <em>N</em> distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">8</span> <span class="number">1</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">0</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; AVL,CBT;</span><br><span class="line"><span class="keyword">int</span> N,root = <span class="number">1</span>,pos = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//递归建树，不断深入左子树，然后从小到大开始建立结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build_CBT</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root &gt; N)    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * root;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//递归，按照左根右，从小到大的顺序建树</span></span><br><span class="line">        <span class="built_in">Build_CBT</span>(left);</span><br><span class="line">        CBT[root] = AVL[pos++];</span><br><span class="line">        <span class="built_in">Build_CBT</span>(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    AVL = vector&lt;<span class="keyword">int</span>&gt; (N,<span class="number">0</span>);</span><br><span class="line">    CBT = vector&lt;<span class="keyword">int</span>&gt; (N + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; AVL[i];</span><br><span class="line">    <span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(AVL.<span class="built_in">begin</span>(),AVL.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">Build_CBT</span>(root);</span><br><span class="line">    cout &lt;&lt; CBT[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N ; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; CBT[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:&lt;/p&gt;
&lt;ul&gt;
</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>4-11 Isomorphic (10 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/24/4-11%20Isomorphic%20(10%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/24/4-11%20Isomorphic%20(10%20%E5%88%86)/</id>
    <published>2021-10-24T02:51:34.117Z</published>
    <updated>2021-10-24T03:02:13.450Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>Two trees, <code>T1</code> and <code>T2</code>, are <strong>isomorphic</strong> if <code>T1</code> can be transformed into <code>T2</code> by swapping left and right children of (some of the) nodes in <code>T1</code>. For instance, the two trees in Figure 1 are isomorphic because they are the same if the children of A, B, and G, but not the other nodes, are swapped. Give a polynomial time algorithm to decide if two trees are isomorphic.</p><p> <img src="https://images.ptausercontent.com/37" alt="img"><br>Figure 1</p><h3 id="Format-of-functions"><a href="#Format-of-functions" class="headerlink" title="Format of functions:"></a>Format of functions:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Isomorphic</span><span class="params">( Tree T1, Tree T2 )</span></span>;</span><br></pre></td></tr></table></figure><p>where <code>Tree</code> is defined as the following:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree  Left;</span><br><span class="line">    Tree  Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The function is supposed to return 1 if <code>T1</code> and <code>T2</code> are indeed isomorphic, or 0 if not.</p><h3 id="Sample-program-of-judge"><a href="#Sample-program-of-judge" class="headerlink" title="Sample program of judge:"></a>Sample program of judge:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree  Left;</span><br><span class="line">    Tree  Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">BuildTree</span><span class="params">()</span></span>; <span class="comment">/* details omitted */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Isomorphic</span><span class="params">( Tree T1, Tree T2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree T1, T2;</span><br><span class="line">    T1 = <span class="built_in">BuildTree</span>();</span><br><span class="line">    T2 = <span class="built_in">BuildTree</span>();</span><br><span class="line">    <span class="built_in">printf</span>(“%d\n”, <span class="built_in">Isomorphic</span>(T1, T2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Your function will be put here */</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1-for-the-trees-shown-in-Figure-1"><a href="#Sample-Output-1-for-the-trees-shown-in-Figure-1" class="headerlink" title="Sample Output 1 (for the trees shown in Figure 1):"></a>Sample Output 1 (for the trees shown in Figure 1):</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2-for-the-trees-shown-in-Figure-2"><a href="#Sample-Output-2-for-the-trees-shown-in-Figure-2" class="headerlink" title="Sample Output 2 (for the trees shown in Figure 2):"></a>Sample Output 2 (for the trees shown in Figure 2):</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p><img src="https://images.ptausercontent.com/38" alt="img"><br>Figure2</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​    如果T1,T2都为空，则一定相等，如果其中只有一个不为空或者两个结点的值，则一定不等。</p><p>​    就是比较两个结点各自的左与左，右与右孩子；或者进行一个交换，比较两个结点各自的左与右，右与左孩子</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Isomorphic</span><span class="params">( Tree T1, Tree T2 )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T1 == <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T1 == <span class="literal">NULL</span> || T2 == <span class="literal">NULL</span> || T1 -&gt; Element != T2 -&gt; Element) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (Isomorphic(T1-&gt;Left,T2-&gt;Left)&amp;&amp;Isomorphic(T1-&gt;Right,T2-&gt;Right))||(Isomorphic(T1-&gt;Left,T2-&gt;Right)&amp;&amp;Isomorphic(T1-&gt;Right,T2-&gt;Left));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;Two trees, &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;, are &lt;strong&gt;isomorphic&lt;/strong&gt; if &lt;code&gt;T1&lt;/code&gt; can be transf</summary>
      
    
    
    
    
    <category term="周练习" scheme="http://wangxu1905.github.io/tags/%E5%91%A8%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>4-15 根据后序和中序遍历输出先序遍历 (15 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/24/4-15%20%E6%A0%B9%E6%8D%AE%E5%90%8E%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%20(15%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/24/4-15%20%E6%A0%B9%E6%8D%AE%E5%90%8E%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%20(15%20%E5%88%86)/</id>
    <published>2021-10-24T02:46:22.751Z</published>
    <updated>2021-10-24T02:47:13.380Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>本题要求根据给定的一棵二叉树的后序遍历和中序遍历结果，输出该树的先序遍历结果。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行给出正整数<em>N</em>(≤30)，是树中结点的个数。随后两行，每行给出<em>N</em>个整数，分别对应后序遍历和中序遍历结果，数字间以空格分隔。题目保证输入正确对应一棵二叉树。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出<code>Preorder: </code>以及该树的先序遍历结果。数字间有1个空格，行末不得有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2 3 1 5 7 6 4</span><br><span class="line">1 2 3 4 5 6 7结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Preorder: 4 1 3 2 6 5 7</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span> *<span class="title">BTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    BTree left,right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; post,in;</span><br><span class="line"><span class="comment">//利用递归，先从后序遍历中找到根节点，然后在中序遍历中找到该节点，分出左右子树来</span></span><br><span class="line"><span class="comment">//然后后序遍历根的上一个就是右子树的根，而做子树的根位置为根的位置减去右子树全部结点的个数</span></span><br><span class="line"><span class="function">BTree <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span>(pos = start ; pos &lt; end; ++pos)</span><br><span class="line">        <span class="keyword">if</span>(in[pos] == post[root])  <span class="keyword">break</span>;</span><br><span class="line">    BTree node = (BTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BtNode));</span><br><span class="line">    node -&gt; data = post[root];</span><br><span class="line">    node -&gt; left = <span class="built_in">BuildTree</span>(root - <span class="number">1</span> - end + pos,start,pos - <span class="number">1</span>);</span><br><span class="line">    node -&gt; right = <span class="built_in">BuildTree</span>(root - <span class="number">1</span>,pos + <span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BTree bt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!bt) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; bt -&gt; data;</span><br><span class="line">    <span class="built_in">PreOrder</span>(bt -&gt; left);</span><br><span class="line">    <span class="built_in">PreOrder</span>(bt -&gt; right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    post.<span class="built_in">resize</span>(N);</span><br><span class="line">    in.<span class="built_in">resize</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)</span><br><span class="line">        cin &gt;&gt; post[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)</span><br><span class="line">        cin &gt;&gt; in[i];</span><br><span class="line">    BTree bt = <span class="built_in">BuildTree</span>(N - <span class="number">1</span>,<span class="number">0</span>,N - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Preorder:&quot;</span> ;</span><br><span class="line">    <span class="built_in">PreOrder</span>(bt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;本题要求根据给定的一棵二叉树的后序遍历和中序遍历结果，输出该树的先序遍历结果。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式:&quot;&gt;&lt;/a&gt;输</summary>
      
    
    
    
    
    <category term="周练习" scheme="http://wangxu1905.github.io/tags/%E5%91%A8%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>4-14 还原二叉树</title>
    <link href="http://wangxu1905.github.io/2021/10/24/4-14%20%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wangxu1905.github.io/2021/10/24/4-14%20%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-10-24T02:22:51.436Z</published>
    <updated>2021-10-24T02:36:41.058Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>4-14 还原二叉树 (15 分)</p><p>给定一棵二叉树的先序遍历序列和中序遍历序列，要求计算该二叉树的高度。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入首先给出正整数N（≤50），为树中结点总数。下面两行先后给出先序和中序遍历序列，均是长度为N的不包含重复英文字母（区别大小写）的字符串。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出为一个整数，即该二叉树的高度。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">ABDFGHIEC</span><br><span class="line">FDHGIBEAC结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span> *<span class="title">BTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    BTree left,right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">string pre,in;<span class="comment">//存储先序和中序序列</span></span><br><span class="line"><span class="comment">//利用递归，先从先序遍历中找到根节点，然后在中序遍历中找到该节点，分出左右子树来</span></span><br><span class="line"><span class="comment">//然后先序遍历根的下一个就是左子树的根，而右子树的根位置为根的位置加上左子树全部结点的个数</span></span><br><span class="line"><span class="function">BTree <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span>(pos = start ; pos &lt; end; ++pos)</span><br><span class="line">        <span class="keyword">if</span>(in[pos] == pre[root])  <span class="keyword">break</span>;</span><br><span class="line">    BTree node = (BTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BtNode));</span><br><span class="line">    node -&gt; data = pre[root];</span><br><span class="line">    node -&gt; left = <span class="built_in">BuildTree</span>(root + <span class="number">1</span>,start,pos - <span class="number">1</span>);</span><br><span class="line">    node -&gt; right = <span class="built_in">BuildTree</span>(root + <span class="number">1</span> + pos - start,pos + <span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">(BTree bt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!bt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">GetHeight</span>(bt -&gt; left),<span class="built_in">GetHeight</span>(bt -&gt; right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">getline</span>(cin,pre);</span><br><span class="line">    <span class="built_in">getline</span>(cin,in);</span><br><span class="line">    BTree bt = <span class="built_in">BuildTree</span>(<span class="number">0</span>,<span class="number">0</span>,N - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">GetHeight</span>(bt) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;4-14 还原二叉树 (15 分)&lt;/p&gt;
&lt;p&gt;给定一棵二叉树的先序遍历序列和中序遍历序列，要求计算该二叉树的高度。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="周练习" scheme="http://wangxu1905.github.io/tags/%E5%91%A8%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>03-树1 树的同构 (25 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/22/03-%E6%A0%911%20%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/22/03-%E6%A0%911%20%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84%20(25%20%E5%88%86)/</id>
    <published>2021-10-22T12:33:12.912Z</published>
    <updated>2021-10-24T03:38:25.872Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p><table><thead><tr><th><img src="https://images.ptausercontent.com/0c8bbacf-d64e-4c6d-8d4e-1249e33fb0b1.jpg" alt="fig1.jpg"></th></tr></thead><tbody><tr><td>图1</td></tr><tr><td><img src="https://images.ptausercontent.com/29" alt="img"></td></tr><tr><td>图2</td></tr></tbody></table><p>现给定两棵树，请你判断它们是否是同构的。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数<em>N</em> (≤10)，即该树的结点数（此时假设结点从0到<em>N</em>−1编号）；随后<em>N</em>行，第<em>i</em>行对应编号第<em>i</em>个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p><h3 id="输入样例1（对应图1）："><a href="#输入样例1（对应图1）：" class="headerlink" title="输入样例1（对应图1）："></a>输入样例1（对应图1）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">A <span class="number">1</span> <span class="number">2</span></span><br><span class="line">B <span class="number">3</span> <span class="number">4</span></span><br><span class="line">C <span class="number">5</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">6</span> -</span><br><span class="line">G <span class="number">7</span> -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line"><span class="number">8</span></span><br><span class="line">G - <span class="number">4</span></span><br><span class="line">B <span class="number">7</span> <span class="number">6</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">5</span> <span class="number">1</span></span><br><span class="line">H - -</span><br><span class="line">C <span class="number">0</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">2</span> -结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输入样例2（对应图2）："><a href="#输入样例2（对应图2）：" class="headerlink" title="输入样例2（对应图2）："></a>输入样例2（对应图2）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">B <span class="number">5</span> <span class="number">7</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">0</span> <span class="number">3</span></span><br><span class="line">C <span class="number">6</span> -</span><br><span class="line">H - -</span><br><span class="line">D - -</span><br><span class="line">G <span class="number">4</span> -</span><br><span class="line">E <span class="number">1</span> -</span><br><span class="line"><span class="number">8</span></span><br><span class="line">D <span class="number">6</span> -</span><br><span class="line">B <span class="number">5</span> -</span><br><span class="line">E - -</span><br><span class="line">H - -</span><br><span class="line">C <span class="number">0</span> <span class="number">2</span></span><br><span class="line">G - <span class="number">3</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Tree left,right;</span><br><span class="line">    <span class="keyword">int</span> flag;  <span class="comment">//是否访问过</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>;  <span class="comment">//创建树的根节点</span></span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>;  <span class="comment">//构建一棵树</span></span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>;  <span class="comment">//在树中插入新的节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>;  <span class="comment">//检查树的节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T,<span class="keyword">int</span> N)</span></span>;  <span class="comment">//判断是否是同一棵二叉搜索树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span>;     <span class="comment">//将树的各个节点flag重置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span>;  <span class="comment">//释放树的空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,L;</span><br><span class="line">    Tree T;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        cin &gt;&gt; L;</span><br><span class="line">        T = <span class="built_in">MakeTree</span>(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L ; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Judge</span>(T,N))</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">ResetT</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FreeTree</span>(T);</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    Tree T = (Tree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(TreeNode));</span><br><span class="line">    T -&gt; v = V;</span><br><span class="line">    T -&gt; left = T -&gt; right = <span class="literal">NULL</span>;</span><br><span class="line">    T -&gt; flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    Tree T;</span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line">    cin &gt;&gt; V;</span><br><span class="line">    T = <span class="built_in">NewNode</span>(V);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N ; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; V;</span><br><span class="line">        T = <span class="built_in">Insert</span>(T,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) T = <span class="built_in">NewNode</span>(V);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(V &gt; T -&gt; v)</span><br><span class="line">            T -&gt; right = <span class="built_in">Insert</span>(T -&gt; right,V);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T -&gt; left = <span class="built_in">Insert</span>(T -&gt; left,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果flag为1，则当前节点已经访问过，要找的节点可能在左右子树，或者节点已经重复</span></span><br><span class="line">    <span class="keyword">if</span>(T -&gt; flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(V &lt; T -&gt; v)  <span class="keyword">return</span> <span class="built_in">check</span>(T -&gt; left,V);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(V &gt; T -&gt; v) <span class="keyword">return</span> <span class="built_in">check</span>(T -&gt; right,V);</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果没访问过，如果该节点正好是要找的节点，则flag设为1</span></span><br><span class="line">        <span class="keyword">if</span>(V == T -&gt; v)&#123;</span><br><span class="line">            T -&gt; flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为要把一个测试用例的全部数据读完，所以设置flag判断是否是同一棵，读完所有数据后，才返回0或者1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V,flag = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; V;</span><br><span class="line">    <span class="comment">//如果根节点不同，则直接flag = 1</span></span><br><span class="line">    <span class="keyword">if</span>(V != T -&gt; v) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    T -&gt; flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N ; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; V;</span><br><span class="line">        <span class="comment">//如果已经判断不是同一棵，则不用调用check函数</span></span><br><span class="line">        <span class="keyword">if</span>((!flag) &amp;&amp; (!<span class="built_in">check</span>(T,V)))</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; left)   <span class="built_in">ResetT</span>(T -&gt; left);</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; right)  <span class="built_in">ResetT</span>(T -&gt; right);</span><br><span class="line">    T -&gt; flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; left)   <span class="built_in">FreeTree</span>(T -&gt; left);</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; right)  <span class="built_in">FreeTree</span>(T -&gt; right);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。&lt;/</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>04-树4 是否是同一棵二叉搜索树</title>
    <link href="http://wangxu1905.github.io/2021/10/18/04-%E6%A0%914%20%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://wangxu1905.github.io/2021/10/18/04-%E6%A0%914%20%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2021-10-18T02:55:38.743Z</published>
    <updated>2021-10-24T03:23:58.878Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入包含若干组测试数据。每组数据的第1行给出两个正整数<em>N</em> (≤10)和<em>L</em>，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出<em>N</em>个以空格分隔的正整数，作为初始插入序列。随后<em>L</em>行，每行给出<em>N</em>个插入的元素，属于<em>L</em>个需要检查的序列。</p><p>简单起见，我们保证每个插入序列都是1到<em>N</em>的一个排列。当读到<em>N</em>为0时，标志输入结束，这组数据不要处理。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No结尾无空行</span><br></pre></td></tr></table></figure><p><strong>鸣谢青岛大学周强老师补充测试数据！</strong></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Tree left,right;</span><br><span class="line">    <span class="keyword">int</span> flag;  <span class="comment">//是否访问过</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>;  <span class="comment">//创建树的根节点</span></span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>;  <span class="comment">//构建一棵树</span></span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>;  <span class="comment">//在树中插入新的节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>;  <span class="comment">//检查树的节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T,<span class="keyword">int</span> N)</span></span>;  <span class="comment">//判断是否是同一棵二叉搜索树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span>;     <span class="comment">//将树的各个节点flag重置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span>;  <span class="comment">//释放树的空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,L;</span><br><span class="line">    Tree T;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        cin &gt;&gt; L;</span><br><span class="line">        T = <span class="built_in">MakeTree</span>(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L ; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Judge</span>(T,N))</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">ResetT</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FreeTree</span>(T);</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    Tree T = (Tree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(TreeNode));</span><br><span class="line">    T -&gt; v = V;</span><br><span class="line">    T -&gt; left = T -&gt; right = <span class="literal">NULL</span>;</span><br><span class="line">    T -&gt; flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    Tree T;</span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line">    cin &gt;&gt; V;</span><br><span class="line">    T = <span class="built_in">NewNode</span>(V);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N ; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; V;</span><br><span class="line">        T = <span class="built_in">Insert</span>(T,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) T = <span class="built_in">NewNode</span>(V);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(V &gt; T -&gt; v)</span><br><span class="line">            T -&gt; right = <span class="built_in">Insert</span>(T -&gt; right,V);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T -&gt; left = <span class="built_in">Insert</span>(T -&gt; left,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果flag为1，则当前节点已经访问过，要找的节点可能在左右子树，或者节点已经重复</span></span><br><span class="line">    <span class="keyword">if</span>(T -&gt; flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(V &lt; T -&gt; v)  <span class="keyword">return</span> <span class="built_in">check</span>(T -&gt; left,V);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(V &gt; T -&gt; v) <span class="keyword">return</span> <span class="built_in">check</span>(T -&gt; right,V);</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果没访问过，如果该节点正好是要找的节点，则flag设为1</span></span><br><span class="line">        <span class="keyword">if</span>(V == T -&gt; v)&#123;</span><br><span class="line">            T -&gt; flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为要把一个测试用例的全部数据读完，所以设置flag判断是否是同一棵，读完所有数据后，才返回0或者1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V,flag = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; V;</span><br><span class="line">    <span class="comment">//如果根节点不同，则直接flag = 1</span></span><br><span class="line">    <span class="keyword">if</span>(V != T -&gt; v) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    T -&gt; flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N ; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; V;</span><br><span class="line">        <span class="comment">//如果已经判断不是同一棵，则不用调用check函数</span></span><br><span class="line">        <span class="keyword">if</span>((!flag) &amp;&amp; (!<span class="built_in">check</span>(T,V)))</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; left)   <span class="built_in">ResetT</span>(T -&gt; left);</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; right)  <span class="built_in">ResetT</span>(T -&gt; right);</span><br><span class="line">    T -&gt; flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; left)   <span class="built_in">FreeTree</span>(T -&gt; left);</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; right)  <span class="built_in">FreeTree</span>(T -&gt; right);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>C++ string find()的返回值</title>
    <link href="http://wangxu1905.github.io/2021/10/18/C++%20string%20find()%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
    <id>http://wangxu1905.github.io/2021/10/18/C++%20string%20find()%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</id>
    <published>2021-10-18T02:49:56.505Z</published>
    <updated>2021-10-18T02:53:44.397Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = s.<span class="built_in">find</span>(<span class="string">&quot;o&quot;</span>);</span><br><span class="line">        cout &lt;&lt; index &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>能找到，则返回在字符串的第一个位置的下标</li><li>找不到的话返回-1</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    
    <category term="C++函数" scheme="http://wangxu1905.github.io/tags/C-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++ fill和memset</title>
    <link href="http://wangxu1905.github.io/2021/10/02/C++%20fill%E5%92%8Cmemset/"/>
    <id>http://wangxu1905.github.io/2021/10/02/C++%20fill%E5%92%8Cmemset/</id>
    <published>2021-10-02T13:18:29.279Z</published>
    <updated>2021-10-02T13:44:20.943Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><ul><li><p>memset 函数</p><ul><li>按照字节填充某字符</li><li>在头文件<cstring>中</cstring></li></ul></li><li><p> fill 函数</p></li><li><p>按照单元赋值，将一个区间的元素都赋同一个值</p></li><li><p>在命名空间std里</p></li><li><p>因为memset函数按照直接填充，所以一般memset只能用来填充char型数组，因为只有char型占一字节，如果填充int型数组，除了0和-1，其他的不能，因为只有00000000 = 0，-1同理，如果每一位都填充1，则11111111 = -1.</p></li><li><p>而fill 函数可以赋任何值</p><ul><li><p>赋值int数组：fill(arr , arr + n ,要赋的值)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[n];</span><br><span class="line">    <span class="built_in">fill</span>(arr, arr + n, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;   &quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给vector赋值：fill(v.begin(),v.end(),要赋的值)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">      <span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">          cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- memset的用法</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[n];</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;   &quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;memset 函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照字节填充某字符&lt;/li&gt;
&lt;li&gt;在头文件&lt;cstring&gt;中&lt;/cstring&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt; fill 函数&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="C++函数" scheme="http://wangxu1905.github.io/tags/C-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++ cin和getline</title>
    <link href="http://wangxu1905.github.io/2021/09/30/C++%20cin%E5%92%8Cgetline/"/>
    <id>http://wangxu1905.github.io/2021/09/30/C++%20cin%E5%92%8Cgetline/</id>
    <published>2021-09-30T03:16:55.445Z</published>
    <updated>2021-09-30T03:40:37.760Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>​    cin是在缓存区里把字符读走，会剩下\n在缓存区中，但getline对\n非常敏感，导致getline刚开始读取缓存区里直接读到\n就结束读入数据。</p><p>​    cin，流提取运算符根据它后面的变量类型读取数据，从非空白符号开始，遇到Enter、Space、Tab键时结束。</p><p>​    getline函数从istream中读取一行数据，当遇到”\n”时结束返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;变量n : &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串s : &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![屏幕截图 2021-09-30 113205](C:\Users\Lenovo\Desktop\屏幕截图 2021-09-30 113205.png)</p><p>例如上面，输入123后，123赋值给n，字符串读取缓冲区的\n直接结束。</p><p>可以在 cin &gt;&gt; n;后面加上cin.ignore();或者getchar();来解决</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;​    cin是在缓存区里把字符读走，会剩下\n在缓存区中，但getline对\n非常敏感，导致getline刚开始读取缓存区里直接读到\n就结束读入数据。&lt;/p&gt;
&lt;p&gt;​    cin，流提取运算符根据它后面的变量类型</summary>
      
    
    
    
    
    <category term="C++函数" scheme="http://wangxu1905.github.io/tags/C-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>迷宫的最短路径</title>
    <link href="http://wangxu1905.github.io/2021/09/23/%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>http://wangxu1905.github.io/2021/09/23/%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</id>
    <published>2021-09-23T12:47:07.391Z</published>
    <updated>2021-10-24T03:37:53.706Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>在一个m * n的迷宫中，0表示通路，1表示墙壁。左上角为迷宫的入口，右下角为迷宫的出口。求到达迷宫入口的最短路径。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    为了省去判断是否为迷宫边缘，可以把迷宫整体加一层强，变成（m + 2）* (n + 2)的迷宫，入口则变成了（1,1），出口为（m,n）.为了能够记录路径，我们可以记录当前的点的前驱点。</p><p>​    用结构体数组代替队列，以便进行打印路径。</p><p>​    我们从入口开始，进行试探。</p><p>​    从队头开始试探，只要有临近的格子能走就入队，然后队头出队，再从新的队头探索。一旦到达出口，就是最短路径，然后打印路径，因为没有去走多余的格子。就是直接试探当前点能走的临近的格子。</p><p>​    如果有多条路径可以到达终点，最短路径，其前驱的节点的数目少，则最先入队，所以只要谁最先判断成功是终点，谁就是最短路径。</p><p>​    为了防止走到重复节点，把走过的格子都赋值为-1即可。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 8</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; Item;</span><br><span class="line">Item mv[<span class="number">8</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[m + <span class="number">2</span>][n + <span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printpath</span><span class="params">(Node qu[], <span class="keyword">int</span> rear)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rear != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printpath</span>(qu,qu[rear].pre);</span><br><span class="line">        <span class="keyword">if</span>(qu[rear].x != m &amp;&amp; qu[rear].y != n)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) -&gt;&quot;</span>,qu[rear].x,qu[rear].y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>,qu[rear].x,qu[rear].y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node qu[m * n];</span><br><span class="line">    qu[front].x = <span class="number">1</span>;qu[front].y = <span class="number">1</span>;qu[front].pre = <span class="number">-1</span>;   <span class="comment">//记录入口</span></span><br><span class="line">    <span class="keyword">int</span> x, y, i, j;</span><br><span class="line">    <span class="keyword">while</span>(front &lt;= rear) &#123;</span><br><span class="line">        x = qu[front].x;y = qu[front].y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span> ; v &lt; <span class="number">8</span>; ++v) &#123;</span><br><span class="line">            i = x + mv[v].x;j = y + mv[v].y;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j] == <span class="number">0</span>) &#123;                            <span class="comment">//新点可到达的话，入队</span></span><br><span class="line">                arr[i][j] = <span class="number">-1</span>;</span><br><span class="line">                ++rear;</span><br><span class="line">                qu[rear].x = i;qu[rear].y = j;qu[rear].pre = front;</span><br><span class="line">                <span class="keyword">if</span>(i == m &amp;&amp; j == n) &#123;                  <span class="comment">//新的点如果是入口，则打印路径</span></span><br><span class="line">                    <span class="built_in">printpath</span>(qu, rear);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++front;            <span class="comment">//出队，继续试探一下个点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">path</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;在一个m * n的迷宫中，0表示通路，1表示墙壁。左上角为迷宫的入口，右下角为迷宫的出口。求到达迷宫入口的最短路径。&lt;/p&gt;
&lt;h2 id=&quot;算法思路&quot;&gt;&lt;a href=&quot;#算法思路&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="数据结构复习" scheme="http://wangxu1905.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="回溯法" scheme="http://wangxu1905.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>迷宫求解</title>
    <link href="http://wangxu1905.github.io/2021/09/23/%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/"/>
    <id>http://wangxu1905.github.io/2021/09/23/%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/</id>
    <published>2021-09-23T12:30:19.236Z</published>
    <updated>2021-10-24T03:41:48.106Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>在一个m * n的迷宫中，0表示通路，1表示墙壁。左上角为迷宫的入口，右下角为迷宫的出口。判断迷宫是否有解。</p><h2 id="算法思路（深度优先搜索）"><a href="#算法思路（深度优先搜索）" class="headerlink" title="算法思路（深度优先搜索）"></a>算法思路（深度优先搜索）</h2><p>​    为了省去判断是否为迷宫边缘，可以把迷宫整体加一层强，变成（m + 2）* (n + 2)的迷宫，入口则变成了（1,1），出口为（m,n）.</p><p>​    我们从入口开始，进行试探。</p><p>​    当前格子具有两种情况:</p><ol><li>它临近的格子可走，则将当前格子入栈，移动到新的格子上，继续试探。</li><li>它所有临近的格子不可走，则回到已经入栈的上一个格子，上一个格子出栈。继续试探。</li></ol><p>​    当前格子正是出口时，return 1,如果搜索完所有能到达的格子都无法到达出口时，return 0.    </p><p>​    为了防止走到重复节点，把走过的格子都赋值为-1即可。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 8</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;Item;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;Node;</span><br><span class="line">Item mv[<span class="number">8</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> vis[m + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> arr[m + <span class="number">2</span>][n + <span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;    <span class="comment">//深度优先搜索的代码</span></span><br><span class="line">    <span class="keyword">if</span>(x == m &amp;&amp; y == n)    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[x + mv[i].x][y + mv[i].y] == <span class="number">0</span> &amp;&amp; vis[x + mv[i].x][y + mv[i].y] == <span class="number">0</span>)&#123;</span><br><span class="line">            vis[x + mv[i].x][y + mv[i].y] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x + mv[i].x,y + mv[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> arr[][n + <span class="number">2</span>])</span></span>&#123;</span><br><span class="line">    stack&lt;Node&gt; s;</span><br><span class="line">    Node tmp;</span><br><span class="line">    <span class="keyword">int</span> x,y,d,i,j;</span><br><span class="line">    tmp.x = <span class="number">1</span>;tmp.y = <span class="number">1</span>;tmp.d = <span class="number">-1</span>;</span><br><span class="line">    s.<span class="built_in">push</span>(tmp);</span><br><span class="line">    <span class="keyword">while</span>(s.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        tmp = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        x = tmp.x;y = tmp.y;d = tmp.d + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(d &lt; <span class="number">8</span>)&#123;</span><br><span class="line">            i = x + mv[d].x;</span><br><span class="line">            j = y + mv[d].y;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                tmp = &#123;x,y,d&#125;;</span><br><span class="line">                s.<span class="built_in">push</span>(tmp);</span><br><span class="line">                x = i;y = j;arr[x][y] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(x == m &amp;&amp; y == n)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>    d = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ++d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    vis[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">path</span>(arr))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;在一个m * n的迷宫中，0表示通路，1表示墙壁。左上角为迷宫的入口，右下角为迷宫的出口。判断迷宫是否有解。&lt;/p&gt;
&lt;h2 id=&quot;算法思路（深度优先搜索）&quot;&gt;&lt;a href=&quot;#算法思路（深度优先搜索）&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="数据结构复习" scheme="http://wangxu1905.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="回溯法" scheme="http://wangxu1905.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单链表合并</title>
    <link href="http://wangxu1905.github.io/2021/09/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6/"/>
    <id>http://wangxu1905.github.io/2021/09/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6/</id>
    <published>2021-09-20T03:23:56.023Z</published>
    <updated>2021-09-20T03:33:52.415Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>设有两个单链表A、B，其中元素递增有序，编写算法将A、B归并成一个按元素值递减（允许有相同值）有序的链表C，要求用A、B的原结点形成，不能重新申请节点。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>利用A、B两表有序的特点，依次进行比较，将当前较小值取出，插入到C表的头部，得到的C表为递降有序。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">merge</span><span class="params">(LinkList A, LinkList B)</span> </span>&#123;</span><br><span class="line">    LinkList C;</span><br><span class="line">    LinkNode *p, *q, *s;</span><br><span class="line">    p = A -&gt; next;</span><br><span class="line">    q = B -&gt; next;</span><br><span class="line">    C = A;</span><br><span class="line">    C -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p -&gt; data &lt; q -&gt; data) &#123;</span><br><span class="line">            s = p;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            s -&gt; next = C -&gt; next;</span><br><span class="line">            C -&gt; next = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)  p = q;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        s = p;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        s -&gt; next = C -&gt; next;</span><br><span class="line">        C -&gt; next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;设有两个单链表A、B，其中元素递增有序，编写算法将A、B归并成一个按元素值递减（允许有相同值）有序的链表C，要求用A、B的原结点形成，不能重新申请节点。&lt;/p&gt;
&lt;h2 id=&quot;算法思路&quot;&gt;&lt;a href=&quot;#算法思路&quot; c</summary>
      
    
    
    
    
    <category term="数据结构复习" scheme="http://wangxu1905.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>单链表逆置</title>
    <link href="http://wangxu1905.github.io/2021/09/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE/"/>
    <id>http://wangxu1905.github.io/2021/09/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE/</id>
    <published>2021-09-20T03:20:55.150Z</published>
    <updated>2021-09-20T03:23:48.190Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>依次取出原链表的每个结点，并将其作为第一个节点进行头插法，指针p用来指向原表中的当前节点，p为空时结束</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(LinkList head)</span> </span>&#123;</span><br><span class="line">    LinkNode *p, *q;</span><br><span class="line">    p = head -&gt; next;</span><br><span class="line">    head -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        q -&gt; next = head -&gt; next;</span><br><span class="line">        head -&gt; next = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;算法思路&quot;&gt;&lt;a href=&quot;#算法思路&quot; class=&quot;headerlink&quot; title=&quot;算法思路&quot;&gt;&lt;/a&gt;算法思路&lt;/h2&gt;&lt;p&gt;依次取出原链表的每个结点，并将其作为第一个节点进行头插法，指针p用来指向原</summary>
      
    
    
    
    
    <category term="数据结构复习" scheme="http://wangxu1905.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>19. 删除链表的倒数第 N 个结点</title>
    <link href="http://wangxu1905.github.io/2021/09/19/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://wangxu1905.github.io/2021/09/19/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2021-09-19T08:35:52.832Z</published>
    <updated>2021-09-19T08:48:04.097Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"></p><blockquote><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：head = [1], n = 1<br>输出：[]</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：head = [1,2], n = 1<br>输出：[1]</p></blockquote><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 sz</li><li>1 &lt;= sz &lt;= 30</li><li>0 &lt;= Node.val &lt;= 100</li><li>1 &lt;= n &lt;= sz</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>定义快慢指针，快指针先移动k - 1步，然后快慢指针一起移动，当快指针移动到链表表尾时，慢指针移动到倒数第k的结点的前驱结点，然后让前驱结点指向下一结点的下一个节点，实现删除。</p><p>当链表长不足k时，返回慢指针的下一个节点，即删除第一个节点。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* left = head;</span><br><span class="line">        ListNode* right = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            right = right -&gt; next;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">nullptr</span>)   <span class="keyword">return</span> left -&gt; next;</span><br><span class="line">        <span class="keyword">while</span>(right -&gt; next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            right = right -&gt; next;</span><br><span class="line">            left = left -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        left -&gt; next = left -&gt; next -&gt; next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;进阶：你能尝试使用一趟扫描实现吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:</summary>
      
    
    
    
    
    <category term="双指针" scheme="http://wangxu1905.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
