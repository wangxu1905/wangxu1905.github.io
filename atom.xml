<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moon</title>
  
  
  <link href="http://wangxu1905.github.io/atom.xml" rel="self"/>
  
  <link href="http://wangxu1905.github.io/"/>
  <updated>2022-01-08T14:18:31.561Z</updated>
  <id>http://wangxu1905.github.io/</id>
  
  <author>
    <name>Moon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022 新生摸底测试题目集</title>
    <link href="http://wangxu1905.github.io/2022/01/08/2022%20%E6%96%B0%E7%94%9F%E6%91%B8%E5%BA%95%E6%B5%8B%E8%AF%95%E9%A2%98%E7%9B%AE%E9%9B%86/"/>
    <id>http://wangxu1905.github.io/2022/01/08/2022%20%E6%96%B0%E7%94%9F%E6%91%B8%E5%BA%95%E6%B5%8B%E8%AF%95%E9%A2%98%E7%9B%AE%E9%9B%86/</id>
    <published>2022-01-08T13:35:16.483Z</published>
    <updated>2022-01-08T14:18:31.561Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="7-1-加法求值-10-分"><a href="#7-1-加法求值-10-分" class="headerlink" title="7-1 加法求值 (10 分)"></a><strong>7-1 加法求值 (10 分)</strong></h2><p>给定一个表达式<em>A</em>+<em>B</em>,输出<em>A</em>+<em>B</em>的值</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>一个长度不超过9且大于等于3的字符串，且保证是合法的中缀表达式。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出A+B的值。</p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">111</span>+<span class="number">2222</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2333</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哎，自己就是一顿字符串截取，没想过这种方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>,&amp;a,&amp;c,&amp;b);</span><br><span class="line">    cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4-然后是几点-15-分"><a href="#7-4-然后是几点-15-分" class="headerlink" title="7-4 然后是几点 (15 分)"></a><strong>7-4 然后是几点 (15 分)</strong></h2><p>有时候人们用四位数字表示一个时间，比如 <code>1106</code> 表示 11 点零 6 分。现在，你的程序要根据起始时间和流逝的时间计算出终止时间。</p><p>读入两个数字，第一个数字以这样的四位数字表示当前时间，第二个数字表示分钟数，计算当前时间经过那么多分钟后是几点，结果也表示为四位数字。当小时为个位数时，没有前导的零，例如 5 点 30 分表示为 <code>530</code>；0 点 30 分表示为 <code>030</code>。注意，第二个数字表示的分钟数可能超过 60，也可能是负数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出 2 个整数，分别是四位数字表示的起始时间、以及流逝的分钟数，其间以空格分隔。注意：在起始时间中，当小时为个位数时，没有前导的零，即 5 点 30 分表示为 <code>530</code>；0 点 30 分表示为 <code>030</code>。流逝的分钟数可能超过 60，也可能是负数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出不多于四位数字表示的终止时间，当小时为个位数时，没有前导的零。题目保证起始时间和终止时间在同一天内。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1120</span> <span class="number">110</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1310</span></span><br></pre></td></tr></table></figure><p><strong>鸣谢燕山大学穆运峰老师、用户任钰补充数据！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大佬的思路确实有点意思，我的思路太直了</span></span><br><span class="line"><span class="comment">//大佬是先算一共有多少分钟，再转换回去，%03d是为了防止出现0点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur,pass;</span><br><span class="line">    cin &gt;&gt; cur &gt;&gt; pass;</span><br><span class="line">    cur = <span class="number">60</span> * (cur / <span class="number">100</span>) + cur % <span class="number">100</span> + pass;</span><br><span class="line">    cur = <span class="number">100</span> * (cur / <span class="number">60</span>) + cur % <span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%03d&quot;</span>,cur);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-5-凯撒密码-20-分"><a href="#7-5-凯撒密码-20-分" class="headerlink" title="7-5 凯撒密码 (20 分)"></a><strong>7-5 凯撒密码 (20 分)</strong></h2><p>为了防止信息被别人轻易窃取，需要把电码明文通过加密方式变换成为密文。输入一个以回车符为结束标志的字符串（少于80个字符），再输入一个整数offset，用凯撒密码将其加密后输出。恺撒密码是一种简单的替换加密技术，将明文中的所有字母都在字母表上偏移offset位后被替换成密文，当offset大于零时，表示向后偏移；当offset小于零时，表示向前偏移。</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第一行给出一个以回车结束的非空字符串（少于80个字符）；第二行输入一个整数offset。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出加密后的结果字符串。</p><h3 id="输入样例1-1"><a href="#输入样例1-1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello Hangzhou</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1-1"><a href="#输出样例1-1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jgnnq Jcpibjqw</span><br></pre></td></tr></table></figure><h3 id="输入样例2-1"><a href="#输入样例2-1" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=x+y</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2-1"><a href="#输出样例2-1" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z=w+x</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 重点是计算这个k，首先k先对26取余，转化成[-25,25]范围，然后再加26取余，这样就转化到了[0,25]的范围 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    k = (k % <span class="number">26</span> + <span class="number">26</span>) % <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            s[i] = <span class="string">&#x27;a&#x27;</span> + (s[i] - <span class="string">&#x27;a&#x27;</span> + k) % <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            s[i] = <span class="string">&#x27;A&#x27;</span> + (s[i] - <span class="string">&#x27;A&#x27;</span> + k ) % <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-7-取模运算-15-分"><a href="#7-7-取模运算-15-分" class="headerlink" title="7-7 取模运算 (15 分)"></a><strong>7-7 取模运算 (15 分)</strong></h2><p>给定两个数<em>a</em>,<em>b</em>,请输出<em>a</em> <em>m<strong>o</strong>d</em> <em>b</em></p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>输入仅有一行，每行包括两个数<em>a</em>(1≤<em>a</em>≤10^10^6),<em>b</em>(1≤<em>b</em>≤10^9).</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>输出 <em>a</em> <em>m<strong>o</strong>d</em> <em>b</em> 的值</p><h3 id="Sample-Input1"><a href="#Sample-Input1" class="headerlink" title="Sample Input1:"></a>Sample Input1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output1"><a href="#Sample-Output1" class="headerlink" title="Sample Output1:"></a>Sample Output1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Input2"><a href="#Sample-Input2" class="headerlink" title="Sample Input2:"></a>Sample Input2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output2"><a href="#Sample-Output2" class="headerlink" title="Sample Output2:"></a>Sample Output2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Input3"><a href="#Sample-Input3" class="headerlink" title="Sample Input3:"></a>Sample Input3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33333333333333333333333333333333</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output3"><a href="#Sample-Output3" class="headerlink" title="Sample Output3:"></a>Sample Output3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为只需要得到余数，所以只需要把高精度减法进行简化，只求余数即可</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod,res = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> &amp;c : s)</span><br><span class="line">        res = (res * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>) % mod;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-9-解密邀请码-20-分"><a href="#7-9-解密邀请码-20-分" class="headerlink" title="7-9 解密邀请码 (20 分)"></a><strong>7-9 解密邀请码 (20 分)</strong></h2><p>HBU开设了一门全网独一份的新课程，因此大家迫不及待的等待选课的到来以求选到该课程，但是在选择前需要输入课程的邀请码，任何申请该课程的同学都会收到一个神秘字符串，为了保障字符串的安全性以及自己的课程不被窃取，课程老师发明了一种压缩算法对邀请码中重复的部分进行了压缩，对于字符串中连续的m个相同字符串S将会压缩为<a href="m%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%941%3C=m%3C=200"><em>m</em>∣<em>S</em></a>，例如字符串HBUHBUHBU将会被压缩为[3∣<em>H<strong>B</strong>U</em>]，现在同学们收到了课程的邀请码字，你能帮助他们进行解密么？</p><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入一个字符串<em>S</em>(∣<em>S</em>∣≤50)，<em>S</em>展开后可能含有大写字母、小写字母与数字, 题目保证输入的字符串合法以及展开后的字符串长度不超过106且展开后的邀请码中不含∣</p><h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式:"></a>输出格式:</h3><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HB[<span class="number">3</span>|U[<span class="number">2</span>|HB]]U</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HBUHBHBUHBHBUHBHBU</span><br></pre></td></tr></table></figure><p>说明 HB[3|U[2|HB]]U−&gt;HB[3|UHBHB]U−&gt; HBUHBHBUHBHBUHBHBU</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这道题倒是比大佬的算法运算速度快，大佬的是用栈而且还是递归求解，我用的字符串的截取，从右向左扫描，最先扫描到的[,就是最内层的，然后截取字符串，按规则进行解密，然后重复上述过程，直到扫描不到[*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos1 = s.<span class="built_in">size</span>() - <span class="number">1</span>, pos2 = pos1, pos3 = pos1;</span><br><span class="line">        <span class="keyword">while</span>(pos1 &gt;= <span class="number">0</span> &amp;&amp; s[pos1] != <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[pos1] == <span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">                pos2 = pos1;</span><br><span class="line">            <span class="keyword">if</span>(s[pos1] == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                pos3 = pos1;</span><br><span class="line">            pos1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[pos1] == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">            string ptr = s.<span class="built_in">substr</span>(pos2 + <span class="number">1</span>, pos3 - pos2 - <span class="number">1</span>);</span><br><span class="line">            string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(pos1 + <span class="number">1</span>, pos2 - pos1 - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">                res += ptr;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos1, pos3 - pos1 + <span class="number">1</span>);</span><br><span class="line">            s.<span class="built_in">insert</span>(pos1, res);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-10-这真的算得出来吗？-20-分"><a href="#7-10-这真的算得出来吗？-20-分" class="headerlink" title="7-10 这真的算得出来吗？ (20 分)"></a><strong>7-10 这真的算得出来吗？ (20 分)</strong></h2><p>给定一个值<em>X</em>, 求出 </p><p><svg xmlns="http://www.w3.org/2000/svg" width="11.533ex" height="4.07ex" viewbox="0 -1149.5 5097.4 1799" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-2-TEX-SO-2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"/><path id="MJX-2-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-2-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/><path id="MJX-2-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-2-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-2-TEX-LO-230A" d="M224 -649V1150H275V-598H511V-649H224Z"/><path id="MJX-2-TEX-I-1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/><path id="MJX-2-TEX-LO-230B" d="M252 -598V1150H303V-649H16V-598H252Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mstyle"><g data-mml-node="munderover"><g data-mml-node="mo"><use xlink:href="#MJX-2-TEX-SO-2211"/></g><g data-mml-node="TeXAtom" transform="translate(1056, 477.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msup"><g data-mml-node="mn"><use xlink:href="#MJX-2-TEX-N-31"/><use xlink:href="#MJX-2-TEX-N-30" transform="translate(500, 0)"/></g><g data-mml-node="TeXAtom" transform="translate(1000, 393.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use xlink:href="#MJX-2-TEX-N-31"/><use xlink:href="#MJX-2-TEX-N-30" transform="translate(500, 0)"/><use xlink:href="#MJX-2-TEX-N-30" transform="translate(1000, 0)"/></g></g></g></g><g data-mml-node="TeXAtom" transform="translate(1056, -285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D458"/></g><g data-mml-node="mo" transform="translate(521, 0)"><use xlink:href="#MJX-2-TEX-N-3D"/></g><g data-mml-node="mn" transform="translate(1299, 0)"><use xlink:href="#MJX-2-TEX-N-30"/></g></g></g><g data-mml-node="mrow" transform="translate(2598.5, 0)"><g data-mml-node="mo"><use xlink:href="#MJX-2-TEX-LO-230A"/></g><g data-mml-node="mfrac" transform="translate(528, 0)"><g data-mml-node="mi" transform="translate(420.3, 394) scale(0.707)"><use xlink:href="#MJX-2-TEX-I-1D44B"/></g><g data-mml-node="msup" transform="translate(220, -464.9) scale(0.707)"><g data-mml-node="mn"><use xlink:href="#MJX-2-TEX-N-31"/><use xlink:href="#MJX-2-TEX-N-30" transform="translate(500, 0)"/></g><g data-mml-node="TeXAtom" transform="translate(1000, 393.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D458"/></g></g></g><rect width="1203" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1971, 0)"><use xlink:href="#MJX-2-TEX-LO-230B"/></g></g></g></g></g></g></svg></p><p>的值。</p><h3 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行输入一个整数<em>X</em>(1≤<em>X</em>≤10^100000).</p><h3 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出答案。</p><h3 id="输入样例1-2"><a href="#输入样例1-2" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1225</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1-2"><a href="#输出样例1-2" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1360</span></span><br></pre></td></tr></table></figure><p>解释：1360 = 1225 + 122 + 12 + 1 + 0 + 0 + … + 0</p><h3 id="输入样例2-2"><a href="#输入样例2-2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">99999</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2-2"><a href="#输出样例2-2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">111105</span></span><br></pre></td></tr></table></figure><h3 id="输入样例3"><a href="#输入样例3" class="headerlink" title="输入样例3:"></a>输入样例3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">314159265358979323846264338327950288419716939937510</span></span><br></pre></td></tr></table></figure><h3 id="输出样例3"><a href="#输出样例3" class="headerlink" title="输出样例3:"></a>输出样例3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">349065850398865915384738153697722542688574377708317</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*写这道题是真艰辛，原本开始位数，以为是高精度运算，结果一顿超时，后面优化着优化着，慢慢接近前缀和的形式，然后写出了前缀和，AC了，但是大佬的算法实在是太简洁了*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,cr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算所有位数的总和，即前缀和的最后一位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> &amp;c : s)</span><br><span class="line">        sum += c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">/*然后开始进行计算，余数单独存储，sum值不断减本位的值进行更新，用一个变量代替了一个n个大小的前缀和数组，实在是高*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        s[i] = (sum + cr) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        cr = (sum + cr) / <span class="number">10</span>;</span><br><span class="line">        sum -= t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后判断是不是要进位</span></span><br><span class="line">    cout &lt;&lt; (cr ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;&quot;</span>) &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;7-1-加法求值-10-分&quot;&gt;&lt;a href=&quot;#7-1-加法求值-10-分&quot; class=&quot;headerlink&quot; title=&quot;7-1 加法求值 (10 分)&quot;&gt;&lt;/a&gt;&lt;strong&gt;7-1 加法求值 (10</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>P1480 A/B Problem</title>
    <link href="http://wangxu1905.github.io/2022/01/08/P1480%20A%C3%B7B%20Problem/"/>
    <id>http://wangxu1905.github.io/2022/01/08/P1480%20A%C3%B7B%20Problem/</id>
    <published>2022-01-08T09:54:07.605Z</published>
    <updated>2022-01-08T10:11:38.325Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数 a,b，输出它们的商。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>两行，第一行是被除数，第二行是除数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，商的整数部分。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>0≤a≤10^5000，1≤b≤10^9。</p><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想：</strong></h2><p>​    看题干就是高精度。</p><p>​    高精度乘法需要考虑的问题：</p><ul><li>经典倒序存储，但是这次是从高位向低位进行除法计算，存储余数</li><li>余数加到下一位时需要先乘10再进行运算</li><li>最后处理前导0，和减法一样，最后至少要留下一位，比如0 / 2 = 0</li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp;a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> &amp;r)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">res</span><span class="params">(a.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() <span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        res[i] = (a[i] + r * <span class="number">10</span>) / b;</span><br><span class="line">        r= (a[i] + r * <span class="number">10</span>) % b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(res.<span class="built_in">back</span>() == <span class="number">0</span> &amp;&amp; res.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">toVector</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">res</span><span class="params">(s.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        res[pos++] =  s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string str1;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b,r;</span><br><span class="line">    cin &gt;&gt; str1 &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; a = <span class="built_in">toVector</span>(str1);</span><br><span class="line">    vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; c = <span class="built_in">div</span>(a,b,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        cout &lt;&lt; c[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种高精度除低精度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r 存储余数</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">( vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r )</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- ) &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>( r / b );</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// C存储由高位到低位</span></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> ( C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span> ) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;输入两个整数 a,b，输出它们的商。&lt;/p&gt;
&lt;h2 id=&quot;输入格式&quot;&gt;</summary>
      
    
    
    
    
    <category term="高精度" scheme="http://wangxu1905.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>P1303 A*B Problem</title>
    <link href="http://wangxu1905.github.io/2022/01/08/P1303%20A%C3%97B%20Problem/"/>
    <id>http://wangxu1905.github.io/2022/01/08/P1303%20A%C3%97B%20Problem/</id>
    <published>2022-01-08T09:43:39.136Z</published>
    <updated>2022-01-08T09:53:14.502Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求两数的积。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>两行，两个整数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数表示乘积。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>每个数字不超过 10^2000 ，需用高精。</p><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想：</strong></h2><p>​    看题干就是高精度。</p><p>​    高精度乘法需要考虑的问题：</p><ul><li>经典倒序存储，从低位向高位进行乘法计算，更新进位</li><li>考虑到空间复杂度，我们可以一边乘一边加，不需要算完所有的中间项，最后一起相加</li><li>进位溢出问题，a*b的最大位数为a的位数+b的位数，比如99* 99= 9801，我们可以先往多了开，最后一起处理前导0</li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a,vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(a.size() + b.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">            res[i + j] += a[i] * b[j];</span><br><span class="line">            res[i + j + <span class="number">1</span>] += res[i + j] / <span class="number">10</span>;</span><br><span class="line">            res[i + j] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(res.<span class="built_in">back</span>() == <span class="number">0</span> &amp;&amp; res.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">toVector</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(s.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        res[pos++] =  s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string str1,str2;</span><br><span class="line">    cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a = <span class="built_in">toVector</span>(str1);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; b = <span class="built_in">toVector</span>(str2);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c = <span class="built_in">mul</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        cout &lt;&lt; c[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是高精度乘高精度，下面这个是高精度*低精度（不过可以同样用上面的模板算）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">( vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b )</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>( t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span> ) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;求两数的积。&lt;/p&gt;
&lt;h2 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入</summary>
      
    
    
    
    
    <category term="高精度" scheme="http://wangxu1905.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>P2142 高精度减法</title>
    <link href="http://wangxu1905.github.io/2022/01/08/P2142%20%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/"/>
    <id>http://wangxu1905.github.io/2022/01/08/P2142%20%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/</id>
    <published>2022-01-08T08:13:04.269Z</published>
    <updated>2022-01-08T08:27:33.818Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>高精度减法。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>两个整数 a,b（第二个可能比第一个大）。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>结果（是负数要输出负号）。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><ul><li>20% 数据 a,b 在 long long 范围内；</li><li>100% 数据0&lt;a,b≤10^10086。</li></ul><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想：</strong></h2><p>​    看题干就是高精度。</p><p>​    高精度减法需要考虑的问题：</p><ul><li>结果为负数，我们无法用数组存储负号，我们指定a大于等于b，我们先判断a,b的大小，a小于b，那么a和b交换，一旦交换就输出一个负号<ul><li>位数不同时，谁的位数大谁大</li><li>位数相同时，从高位向低位比较，直到遇见不同位</li><li>如果完全相同，则a和b相等</li></ul></li><li>和加法一样，我们采取倒序存储，从低位向高位进行减法计算，更新借位</li><li>处理前导0，但这里需要注意，如果a和b相等，相减的结果数组全为0,但我们需要留下一位，所以删除的时候还需要判断c.size() &gt; 1</li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a,vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>())    <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span>(a[i] != b[i])    <span class="keyword">return</span> a[i] &gt; b[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a,vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">cmp</span>(a,b))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(a.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    b.<span class="built_in">resize</span>(a.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        c[i] += a[i] - b[i];</span><br><span class="line">        <span class="keyword">if</span>(c[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            c[i] += <span class="number">10</span>;</span><br><span class="line">            c[i + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">back</span>() == <span class="number">0</span> &amp;&amp; c.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        c.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">toVector</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(s.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        res[pos++] =  s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string str1,str2;</span><br><span class="line">    cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a = <span class="built_in">toVector</span>(str1);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; b = <span class="built_in">toVector</span>(str2);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c = <span class="built_in">sub</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        cout &lt;&lt; c[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sub的另一种写法（当然有很多中写法）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">( vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B )</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="comment">//  t表示借位，为0或1</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++ ) &#123;</span><br><span class="line">        t  = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> ( i &lt; B.<span class="built_in">size</span>() ) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>( (t+<span class="number">10</span>) % <span class="number">10</span> )</span><br><span class="line">        <span class="keyword">if</span>( t &lt; <span class="number">0</span> ) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉前导0</span></span><br><span class="line">    <span class="keyword">while</span> ( C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span> ) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;高精度减法。&lt;/p&gt;
&lt;h2 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入</summary>
      
    
    
    
    
    <category term="高精度" scheme="http://wangxu1905.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>出错记录</title>
    <link href="http://wangxu1905.github.io/2022/01/07/%E5%87%BA%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    <id>http://wangxu1905.github.io/2022/01/07/%E5%87%BA%E9%94%99%E8%AE%B0%E5%BD%95/</id>
    <published>2022-01-07T13:32:57.554Z</published>
    <updated>2022-01-07T14:08:12.253Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="1-建立堆"><a href="#1-建立堆" class="headerlink" title="1.建立堆"></a>1.建立堆</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++heapsize] = x;  <span class="comment">//先++，再赋值，所以是前缀++</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = heapsize; heap[i] &lt; heap[i / <span class="number">2</span>]; i /= <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">swap</span>(heap[i], heap[i / <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对于堆来说，和二叉排序树不一样，必须查找两个赋值，与其递归求解，还不入</span></span><br><span class="line"><span class="comment">顺序查找，哎，当时直接想到了递归，回头想想，还是顺序查找好*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= heapsize; ++i)</span><br><span class="line">        <span class="keyword">if</span>(heap[i] == x)    <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h4 id=&quot;1-建立堆&quot;&gt;&lt;a href=&quot;#1-建立堆&quot; class=&quot;headerlink&quot; title=&quot;1.建立堆&quot;&gt;&lt;/a&gt;1.建立堆&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table</summary>
      
    
    
    
    
    <category term="随便写点" scheme="http://wangxu1905.github.io/tags/%E9%9A%8F%E4%BE%BF%E5%86%99%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>C++ 其他类型转字符串</title>
    <link href="http://wangxu1905.github.io/2022/01/07/C++%20%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://wangxu1905.github.io/2022/01/07/C++%20%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-01-07T13:09:06.098Z</published>
    <updated>2022-01-07T13:28:13.387Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><pre><code>#### 1.to_string()</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1234</span>;</span><br><span class="line">string b = <span class="built_in">to_string</span>(a);</span><br></pre></td></tr></table></figure><h4 id="2-字符流stringstream"><a href="#2-字符流stringstream" class="headerlink" title="2.字符流stringstream"></a>2.字符流stringstream</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1234</span>;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss &lt;&lt; a;</span><br><span class="line">string b = ss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure><p>如果转多个加上str(“”)；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>,c = <span class="number">456</span>;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss &lt;&lt; a;</span><br><span class="line">string b = ss.<span class="built_in">str</span>();</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">ss.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">ss &lt;&lt; c;</span><br><span class="line">cout &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;pre&gt;&lt;code&gt;#### 1.to_string()
&lt;/code&gt;&lt;/pre&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    
    <category term="C++函数" scheme="http://wangxu1905.github.io/tags/C-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>P1601 A+B Problem（高精）</title>
    <link href="http://wangxu1905.github.io/2022/01/07/P1601%20A+B%20Problem%EF%BC%88%E9%AB%98%E7%B2%BE%EF%BC%89/"/>
    <id>http://wangxu1905.github.io/2022/01/07/P1601%20A+B%20Problem%EF%BC%88%E9%AB%98%E7%B2%BE%EF%BC%89/</id>
    <published>2022-01-07T12:13:22.094Z</published>
    <updated>2022-01-08T10:12:11.585Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>高精度加法，相当于a+b problem，<strong>不用考虑负数</strong>.</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>分两行输入。a,b≤10^500</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出只有一行，代表a+b的值</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输入 #2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1001</span></span><br><span class="line"><span class="number">9099</span></span><br></pre></td></tr></table></figure><p><strong>输出 #2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10100</span></span><br></pre></td></tr></table></figure><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想：</strong></h2><p>​    如果数据范围是10^500次方，显然即使是long long也得爆，所以有两种方法存储，一种是数组，一种是字符串，然后通过遍历模拟运算。</p><p>​    然后考虑计算会出现的问题</p><ul><li>首先，如果a和b位数不同时，根据竖式，低位要和低位对齐，但不管是字符串还是数组都是从高位开始依次读取，遍历的话，如果使用同一个指针进行遍历会出现以下情况</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"> + <span class="number">1</span> <span class="number">2</span></span><br><span class="line"> _________</span><br><span class="line"> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>显然这是不对的，所以按常规思路的话，使用两个指针分别遍历a和b，但显然挺复杂。</p><ul><li><p>其次是进位问题，第i位的值 = (a的第i位的值 + b的第i位的值 + 第i- 1进位) %10,第i位的进位 = (a的第i位的值 + b的第i位的值 + 第i- 1进位) /10</p></li><li><p>最后是最高位的进位，显然如果最高位需要进位的话，我们需要动态增加空间来存储最高位的进位</p><p>综合前面几点，我们可以采取倒序存储，即从低位到高位存储，然后如果位数不同可以向后补0，同时如果最高位进位，也比较好补位。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"> + <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> _________</span><br><span class="line"> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​    最后再讨论是用数组存还是字符串存，显然用数组存进行数值运算的话要比字符串要快，所以采用数组存。</p><p>总体要做的操作：</p><ul><li>首先读取两个字符串，然后把两个字符串倒序存入两个数组中，数组需要初始化为0（提前补0）</li><li>然后进行模拟运算，res可以开到a和b的最大位数，但可以把res的数组多开一位（计算方便），可以把进位直接赋值给下一位，然后计算下一位时，可以直接在已经计算进位的基础上加上a和b对应位置的值</li><li>最后，判断res的最后一位是否为0，为0的话删除，不为0的话，说明最高位有进位，不需要删除</li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a,vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(a.size() + <span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        res[i] += a[i] + b[i];</span><br><span class="line">        res[i + <span class="number">1</span>] = res[i] / <span class="number">10</span>;</span><br><span class="line">        res[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!res[res.<span class="built_in">size</span>() - <span class="number">1</span>])    res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string str1,str2;</span><br><span class="line">    cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">    <span class="keyword">int</span> maxsize = <span class="built_in">max</span>(str1.<span class="built_in">size</span>(),str2.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(maxsize,<span class="number">0</span>)</span>,<span class="title">b</span><span class="params">(maxsize,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = str1.<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        a[pos++] = str1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = str2.<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        b[pos++] = str2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res = <span class="built_in">add</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        cout &lt;&lt; res[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;高精度加法，相当于a+b problem，&lt;strong&gt;不用考虑负数&lt;/</summary>
      
    
    
    
    
    <category term="高精度" scheme="http://wangxu1905.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>P2574 XOR的艺术</title>
    <link href="http://wangxu1905.github.io/2022/01/06/P2574%20XOR%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <id>http://wangxu1905.github.io/2022/01/06/P2574%20XOR%E7%9A%84%E8%89%BA%E6%9C%AF/</id>
    <published>2022-01-06T12:26:18.098Z</published>
    <updated>2022-01-08T10:13:43.782Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中，他发现，这个游戏的伤害计算有一个规律，规律如下</p><ol><li>拥有一个伤害串，是一个长度为 n 的只含字符 <code>0</code> 和字符 <code>1</code> 的字符串。规定这个字符串的首字符是第一个字符，即下标从 11 开始。</li><li>给定一个范围[l, r]，伤害为伤害串的这个范围内中字符 <code>1</code> 的个数</li><li>会修改伤害串中的数值，修改的方法是把 [l, r] 中所有原来的字符 <code>0</code> 变成 <code>1</code>，将 <code>1</code> 变成 <code>0</code>。</li></ol><p>AKN 想知道一些时刻的伤害，请你帮助他求出这个伤害。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行有两个用空格隔开的整数，分别表示伤害串的长度 n，和操作的个数 m。</p><p>输入第二行是一个长度为 n的字符串 S，代表伤害串。</p><p>第 3 到第 (m + 2) 行，每行有三个用空格隔开的整数 op,l,r。代表第 i 次操作的方式和区间，规则是：</p><ul><li>若 op = 0，则表示将伤害串的 [l, r] 区间内的 <code>0</code> 变成 <code>1</code>，<code>1</code> 变成 <code>0</code>。</li><li>若 op = 1，则表示询问伤害串的 [l, r] 区间内有多少个字符 <code>1</code>。</li></ul><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每次询问，输出一行一个整数，代表区间内 <code>1</code> 的个数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">6</span></span><br><span class="line"><span class="number">1011101001</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><h4 id="样例输入输出-1-解释"><a href="#样例输入输出-1-解释" class="headerlink" title="样例输入输出 1 解释"></a>样例输入输出 1 解释</h4><p>原伤害串为 <code>1011101001</code>。</p><p>对于第一次操作，改变 [2, 4] 的字符，伤害串变为 <code>1100101001</code>。</p><p>对于第二次操作，查询 [1, 5] 内 <code>1</code> 的个数，共有 3 个。</p><p>对于第三次操作，改变 [3, 7] 的字符，伤害串变为 <code>1111010001</code>。</p><p>对于第四次操作，查询 [1, 10] 内 <code>1</code> 的个数，共有 6 个。</p><p>对于第五次操作，改变 [1, 4] 的字符，伤害串变为 <code>0000010001</code>。</p><p>对于第六次操作，查询 [2, 6] 内 <code>1</code> 的个数，共有 1 个。</p><h4 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h4><p>对于 10% 的数据，保证 n,m≤10。</p><p>另有 30% 的数据，保证 n,m≤2×10^3。</p><p>对于 100% 的数据，保证 2≤n,m≤2×10^5，0≤op≤1，1≤l≤r≤n，S 中只含字符 <code>0</code> 和字符 <code>1</code>。</p><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想：</strong></h2><p>​    采用线段树，然后因为字符串只有0和1，所以一个子串中有多少个1，直接这个子串的0和1相加的总和就是1的个数，所以线段树维护的是区间和。</p><p>​    当op = 0时，0和1相互变化，所以新的区间和变为区间长度-原区间和，可以用懒标记下传。经过两次0和1的相互变化相当于没有变化。所以lazytag对1异或即可，因为0和1异或是1,1和1异或是0，可以通过位运算进行懒标记0和1的变化。</p><p>​    还有用了ios::sync_with_stdio(false);之后确实快，原本900+ms,缩短到了600+ms。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> pre,lazytag;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn + <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        t[p].pre = s[l] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t[p].lazytag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> ,l ,mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">    t[p].pre = t[p &lt;&lt; <span class="number">1</span>].pre + t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].lazytag)&#123;</span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span>].pre = (t[p &lt;&lt; <span class="number">1</span>].r - t[p &lt;&lt; <span class="number">1</span>].l + <span class="number">1</span>) - t[p &lt;&lt; <span class="number">1</span>].pre;</span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].pre = (t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].r - t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l + <span class="number">1</span>) - t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].pre;</span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span>].lazytag ^= <span class="number">1</span>;</span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazytag ^= <span class="number">1</span>;</span><br><span class="line">        t[p].lazytag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre = (t[p].r - t[p].l + <span class="number">1</span>) - t[p].pre;</span><br><span class="line">        t[p].lazytag ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change</span>(p &lt;&lt; <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)      <span class="built_in">change</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,x,y);</span><br><span class="line">    t[p].pre = t[p &lt;&lt; <span class="number">1</span>].pre + t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)  <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    ans += <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)      ans += <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag,x,y;</span><br><span class="line">        cin &gt;&gt; flag &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(!flag)    <span class="built_in">change</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        <span class="keyword">else</span>        cout &lt;&lt; <span class="built_in">ask</span>(<span class="number">1</span>,x,y) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中</summary>
      
    
    
    
    
    <category term="线段树" scheme="http://wangxu1905.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>提高程序效率的位运算</title>
    <link href="http://wangxu1905.github.io/2022/01/05/%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E6%95%88%E7%8E%87%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://wangxu1905.github.io/2022/01/05/%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E6%95%88%E7%8E%87%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2022-01-05T13:02:43.822Z</published>
    <updated>2022-01-05T13:08:55.311Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><ul><li>如果树的父亲结点为n,则左孩子结点为n &lt;&lt; 1,右孩子为 n &lt;&lt; 1 | 1;</li><li>二分查找mid = (left + right) &gt;&gt; 1;</li><li>还有自己写scanf函数读取整数值来提高运行效率（tql）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;ul&gt;
&lt;li&gt;如果树的父亲结点为n,则左孩子结点为n &amp;lt;&amp;lt; 1,右孩子为 n &amp;lt;&amp;lt; 1 | 1;&lt;/li&gt;
&lt;li&gt;二分查找mid = (left + right) &amp;gt;&amp;gt; 1;&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="位运算" scheme="http://wangxu1905.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>P3373 【模板】线段树 2</title>
    <link href="http://wangxu1905.github.io/2022/01/05/P3373%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%202/"/>
    <id>http://wangxu1905.github.io/2022/01/05/P3373%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%202/</id>
    <published>2022-01-05T12:45:25.154Z</published>
    <updated>2022-01-08T10:14:27.518Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面三种操作：</p><ul><li>将某区间每一个数乘上 x</li><li>将某区间每一个数加上 x</li><li>求出某区间每一个数的和</li></ul><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含三个整数 n,m,p，分别表示该数列数字的个数、操作的总个数和模数。</p><p>第二行包含 n个用空格分隔的整数，其中第 i个数字表示数列第 i项的初始值。</p><p>接下来 m 行每行包含若干个整数，表示一个操作，具体如下：</p><p>操作 1： 格式：<code>1 x y k</code> 含义：将区间 [x,y][<em>x</em>,<em>y</em>] 内每个数乘上 k</p><p>操作 2： 格式：<code>2 x y k</code> 含义：将区间 [x,y][<em>x</em>,<em>y</em>] 内每个数加上 k</p><p>操作 3： 格式：<code>3 x y</code> 含义：输出区间 [x,y][<em>x</em>,<em>y</em>] 内每个数的和对 p 取模所得的结果</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 3 的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">38</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>【数据范围】</p><p>对于 30% 的数据：n≤8，m≤10<br>对于 70% 的数据：n≤10^3，m≤10^4<br>对于 100% 的数据：n≤10^5，m≤10^5</p><p>除样例外，p = 571373</p><p>（数据已经过加强^_^）</p><p>样例说明：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/2255.png" alt="img"></p><p>故输出应为 17、2（40 mod 38=2 ）</p><h2 id="锹黑板："><a href="#锹黑板：" class="headerlink" title="锹黑板："></a><strong>锹黑板：</strong></h2><p>首先我们回忆一下线段树１的加法标记<strong>他其实是打在父亲节点上的标记儿子加多少的</strong>，打完标记的同时父亲的sum其实已经加上了add * len</p><p>那我们回到这道题我们发现题目要求在加数的同时<strong>还要区间乘</strong></p><p>比如现在有3个数1,2,3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">1</span>~<span class="number">3</span>(<span class="number">1</span>)</span><br><span class="line">         /     \</span><br><span class="line">    <span class="number">1</span>~<span class="number">2</span>(<span class="number">2</span>)      <span class="number">3</span>(<span class="number">3</span>)</span><br><span class="line">   /      \</span><br><span class="line"><span class="number">1</span>(<span class="number">4</span>)      <span class="number">2</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>我们先给1~3加上2</strong>,画个小小小小的图，<strong>节点后面的括号代表节点下标</strong></p><p>所以</p><p>t[1].add += 2;</p><p>t[1].sum+=( (3 - 1) + 1) * 2;</p><p><strong>我们再给1~3乘上3</strong></p><p>所以</p><p>t[1].mu *= 3;</p><p><strong>我们再给1~3加上4，那是不是先加再乘</strong></p><p>t[1].add += 4;</p><p>obviously我们发现不能先加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">操作<span class="number">2</span>之后的式子是:</span><br><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>)*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>)*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>)*<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>如果直接加:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">式子是:</span><br><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>+<span class="number">4</span>)*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>+<span class="number">4</span>)*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>+<span class="number">4</span>)*<span class="number">3</span>;</span><br><span class="line">   =(a[<span class="number">1</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>*<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>我们发现这和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>+(a[<span class="number">2</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>+(a[<span class="number">3</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>并不等价</p><p>而要等价必须这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>+<span class="number">4</span>/<span class="number">3</span>)*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>+<span class="number">4</span>/<span class="number">3</span>)*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>+<span class="number">4</span>/<span class="number">3</span>)*<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><strong>我们发现这样就成了实数运算了,还有可能除成无限小数</strong></p><p>而先乘后加:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=(a[<span class="number">1</span>]*<span class="number">3</span>+<span class="number">2</span>*<span class="number">3</span>+<span class="number">4</span>)+(a[<span class="number">2</span>]*<span class="number">3</span>+<span class="number">2</span>*<span class="number">3</span>+<span class="number">4</span>)+(a[<span class="number">3</span>]*<span class="number">3</span>+<span class="number">2</span>*<span class="number">3</span>+<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"><span class="keyword">int</span> a[maxn + <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre,add,mul;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn + <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;t[p].r = r;</span><br><span class="line">    t[p].add = <span class="number">0</span>;t[p].mul = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        t[p].pre = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> , l , mid);</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">    t[p].pre = (t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 根据先乘后加的优先度，儿子的值 = 此刻儿子的值*爸爸乘法的lazytag +儿子的区间长度*爸爸加法的lazytag */</span></span><br><span class="line">    t[p * <span class="number">2</span>].pre = (t[p * <span class="number">2</span>].pre * t[p].mul + t[p].add * (t[p * <span class="number">2</span>].r - t[p * <span class="number">2</span>].l + <span class="number">1</span>)) % mod;</span><br><span class="line">    t[p * <span class="number">2</span> + <span class="number">1</span>].pre = (t[p * <span class="number">2</span> + <span class="number">1</span>].pre * t[p].mul + t[p].add * (t[p * <span class="number">2</span> + <span class="number">1</span>].r - t[p * <span class="number">2</span> + <span class="number">1</span>].l + <span class="number">1</span>)) % mod;</span><br><span class="line">    <span class="comment">//维护lazytag</span></span><br><span class="line">    t[p * <span class="number">2</span>].mul = (t[p * <span class="number">2</span>].mul * t[p].mul) % mod;</span><br><span class="line">    t[p * <span class="number">2</span> + <span class="number">1</span>].mul = (t[p * <span class="number">2</span> + <span class="number">1</span>].mul * t[p].mul) % mod;</span><br><span class="line">    t[p * <span class="number">2</span>].add = (t[p * <span class="number">2</span>].add * t[p].mul + t[p].add) % mod;</span><br><span class="line">    t[p * <span class="number">2</span> + <span class="number">1</span>].add = (t[p * <span class="number">2</span> + <span class="number">1</span>].add * t[p].mul + t[p].add) % mod;</span><br><span class="line">    <span class="comment">//父节点的lazytag初始哈</span></span><br><span class="line">    t[p].mul = <span class="number">1</span>;</span><br><span class="line">    t[p].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="comment">//被覆盖的话</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre = (t[p].pre * z) % mod;</span><br><span class="line">        t[p].mul = (t[p].mul * z) % mod;</span><br><span class="line">        t[p].add = (t[p].add * z) % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有被覆盖，则下传lazytag</span></span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change1</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change1</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    t[p].pre = (t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加法，和乘法同理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change2</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre = (t[p].pre + (<span class="keyword">long</span> <span class="keyword">long</span>)z * (t[p].r - t[p].l + <span class="number">1</span>)) % mod;</span><br><span class="line">        t[p].add = (t[p].add + z) % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change2</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change2</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    t[p].pre = (t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)  <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    ans += <span class="built_in">ask</span>(p * <span class="number">2</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       ans += <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> q,x,y,k;</span><br><span class="line">        cin &gt;&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            <span class="built_in">change1</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(q == <span class="number">2</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            <span class="built_in">change2</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">ask</span>(<span class="number">1</span>,x,y) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如题，已知一个数列，你需要进行下面三种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将</summary>
      
    
    
    
    
    <category term="线段树" scheme="http://wangxu1905.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>P3372 【模板】线段树 1</title>
    <link href="http://wangxu1905.github.io/2022/01/05/P3372%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%201/"/>
    <id>http://wangxu1905.github.io/2022/01/05/P3372%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%201/</id>
    <published>2022-01-05T11:55:30.887Z</published>
    <updated>2022-01-08T10:14:56.527Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li>将某区间每一个数加上 k。</li><li>求出某区间每一个数的和。</li></ol><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 n, m，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 n个用空格分隔的整数，其中第 i 个数字表示数列第 i项的初始值。</p><p>接下来 m 行每行包含 3或 4 个整数，表示一个操作，具体如下：</p><ol><li><code>1 x y k</code>：将区间 [x, y][<em>x</em>,<em>y</em>] 内每个数加上 k。</li><li><code>2 x y</code>：输出区间 [x, y][<em>x</em>,<em>y</em>] 内每个数的和。</li></ol><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 2 的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>对于 30% 的数据：n≤8，m≤10。<br>对于 70% 的数据：n≤10^3，m≤10^4。<br>对于 100% 的数据：1≤n,m≤10^5。</p><p>保证任意时刻数列中任意元素的和在 [−2^63,2^63) 内。</p><p><strong>【样例解释】</strong></p><p><img src="https://cdn.luogu.com.cn/upload/pic/2251.png" alt="img"></p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    看题干就知道线段树，线段树可以维护区间加，区间查找等操作，其余还有区间乘，区间最大值，甚至最大子段和等操作。</p><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h4 id="1-线段树的存储"><a href="#1-线段树的存储" class="headerlink" title="1.线段树的存储"></a>1.线段树的存储</h4><p>采用结构体存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn + <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre,add;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn + <span class="number">2</span>];</span><br></pre></td></tr></table></figure><h4 id="2-建树"><a href="#2-建树" class="headerlink" title="2.建树"></a>2.建树</h4><p>所谓建树，就是把数组a[1 - n]放到线段树中</p><p>在线段树中，对于一个区间(编号为p),它的左儿子为2 * p,右儿子为2 * p + 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;t[p].r = r; <span class="comment">//存储该节点维护的区间范围</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;<span class="comment">//如果区间只有一个数，则直接赋值</span></span><br><span class="line">        t[p].pre = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则维护的值等于左儿子加右儿子</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> , l , mid);</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-懒标记"><a href="#3-懒标记" class="headerlink" title="3.懒标记"></a>3.懒标记</h4><p>​    懒标记的精髓就是打标计和下传操作，由于要做的操作是区间加一个数，所以不妨在区间进行修改时为该区间打上一个标记，就不必再修改它的儿子所维护的区间，等到要是用该节结点儿子维护的值，再将懒标记下放即可，可以省下很多时间，对于每次区间修改和查询，将懒标记下传，可以节省很多时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add)&#123; <span class="comment">//如果懒标记不为0，就将其下传，修改左右儿子维护的值</span></span><br><span class="line">        t[p * <span class="number">2</span>].pre += t[p].add * (t[p * <span class="number">2</span>].r - t[p * <span class="number">2</span>].l + <span class="number">1</span>);</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].pre += t[p].add * (t[p * <span class="number">2</span> + <span class="number">1</span>].r - t[p * <span class="number">2</span> + <span class="number">1</span>].l + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//为该结点的左右儿子打上标记</span></span><br><span class="line">        t[p * <span class="number">2</span>].add += t[p].add;</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].add += t[p].add;</span><br><span class="line">        <span class="comment">//下传之后将该结点的懒标记清0</span></span><br><span class="line">        t[p].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-区间修改"><a href="#4-区间修改" class="headerlink" title="4.区间修改"></a>4.区间修改</h4><p>​    考虑到将一个区间加上一个数，我们可以从根结点不断向下查找，当发现我们要修改的区间覆盖了当前结点时，我们就把这个区间修改，并打上懒标记（由于懒标记的存在，我们就不必再修改它的儿子结点），否则下传懒标记，继续向下找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123; <span class="comment">//被覆盖的话，就对其进行修改</span></span><br><span class="line">        t[p].pre += (<span class="keyword">long</span> <span class="keyword">long</span>)z * (t[p].r - t[p].l + <span class="number">1</span>);</span><br><span class="line">        t[p].add += z;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*如果发现没有被覆盖，那么继续向下找，考虑儿子所维护的区间可能因为懒标记的存在而没有修改，因此懒标记下放*/</span></span><br><span class="line">    <span class="built_in">spread</span>(p); </span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果要修改的区间覆盖了左儿子，就修改左儿子，右儿子同理</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    <span class="comment">//最终维护的值等于左儿子值加右儿子值</span></span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-区间查询"><a href="#5-区间查询" class="headerlink" title="5.区间查询"></a>5.区间查询</h4><p>​    考虑询问一个区间的和，依旧是从根结点向下查找，当发现结点被覆盖时，就返回维护的值，否则下传懒标记，查询左右儿子，累加答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果被覆盖，就返回维护的值</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)  <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    <span class="comment">//下传懒标记，并查询左右儿子</span></span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    ans += <span class="built_in">ask</span>(p * <span class="number">2</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       ans += <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn + <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre,add;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn + <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        t[p].pre = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> , l , mid);</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add)&#123;</span><br><span class="line">        t[p * <span class="number">2</span>].pre += t[p].add * (t[p * <span class="number">2</span>].r - t[p * <span class="number">2</span>].l + <span class="number">1</span>);</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].pre += t[p].add * (t[p * <span class="number">2</span> + <span class="number">1</span>].r - t[p * <span class="number">2</span> + <span class="number">1</span>].l + <span class="number">1</span>);</span><br><span class="line">        t[p * <span class="number">2</span>].add += t[p].add;</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].add += t[p].add;</span><br><span class="line">        t[p].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre += (<span class="keyword">long</span> <span class="keyword">long</span>)z * (t[p].r - t[p].l + <span class="number">1</span>);</span><br><span class="line">        t[p].add += z;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)  <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    ans += <span class="built_in">ask</span>(p * <span class="number">2</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       ans += <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> q,x,y,z;</span><br><span class="line">        cin &gt;&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">ask</span>(<span class="number">1</span>,x,y) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如题，已知一个数列，你需要进行下面两种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将</summary>
      
    
    
    
    
    <category term="线段树" scheme="http://wangxu1905.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>42. 接雨水</title>
    <link href="http://wangxu1905.github.io/2022/01/05/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>http://wangxu1905.github.io/2022/01/05/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/</id>
    <published>2022-01-05T02:26:06.613Z</published>
    <updated>2022-01-08T10:15:36.261Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><blockquote><p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：height = [4,2,0,3,2,5]<br>输出：9</p></blockquote><p><strong>提示：</strong></p><ul><li>n == height.length</li><li>1 &lt;= n &lt;= 2 * 104</li><li>0 &lt;= height[i] &lt;= 105</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a><strong>方法一：动态规划</strong></h3><p>​    根据木桶原理，左右两个柱子，最后能存多少雨水，取决于最短的板子，所以可以从左到右遍历一遍，求得从左到该位置的最长的板子，从右到左遍历，求得从右到该位置的最长的板子。</p><p>​    计算完左右最长的板子后，然后再遍历一遍，该柱子能否存储雨水，取决于左右最长柱子中的最短柱子和该柱子的差。</p><p><img src="https://assets.leetcode-cn.com/solution-static/42/1.png"></p><h4 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>,<span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        left[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        right[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            left[i] = <span class="built_in">max</span>(left[i - <span class="number">1</span>],height[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            right[i] = <span class="built_in">max</span>(right[i + <span class="number">1</span>],height[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            ans += <span class="built_in">min</span>(left[i],right[i]) - height[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)，计算left，right和雨水量需要遍历三次</li><li>空间复杂度：O(n)，创建两个长度为n的数组存储left和right</li></ul><h3 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a><strong>方法二：单调栈</strong></h3><p>​    维护一个单调栈，单调栈存储的是下标，满足从栈底到栈顶的下标对应的数组 height 中的元素递减。</p><p>​    从左到右遍历数组，如果栈内至少有两个元素，记栈顶元素为 top，top 的下面一个元素是 left，则一定有 height[left] ≥ height[top]。如果 height[i]&gt;height[top]，则得到一个可以接雨水的区域，该区域的宽度是i−left−1，高度是 min(height[left],height[i])−height[top]，根据宽度和高度即可计算得到该区域能接的雨水量。</p><p>​    为了得到 left，需要将 top 出栈。在对top 计算能接的雨水量之后，left 变成新的 top，重复上述操作，直到栈变为空，或者栈顶下标对应的height 中的元素大于或等于height[i]。</p><h4 id="实现代码：-1"><a href="#实现代码：-1" class="headerlink" title="实现代码："></a>实现代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,n = height.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="keyword">int</span> top = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">int</span> curWidth = i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> curHeight = <span class="built_in">min</span>(height[left],height[i]) - height[top];</span><br><span class="line">                ans += curHeight * curWidth;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)，其中 n 是数组height 的长度。从 0 到 n−1 的每个下标最多只会入栈和出栈各一次。</li><li>空间复杂度：O(n)，主要取决于栈空间</li></ul><h3 id="方法三：双指针"><a href="#方法三：双指针" class="headerlink" title="方法三：双指针"></a><strong>方法三：双指针</strong></h3><p>​    和动态规划一样，只不过用双指针代替求左右最长板子的两个数组。</p><p>​    维护两个指针left和right，以及两个变量leftMax和rightMax,在移动过程中更新leftMax和rightMax。</p><p>​    当两个指针没有相遇时，进行如下操作：</p><ul><li>使用height[left]和height[right]的值更新leftMax和rightMax</li><li>如果height[left] &lt; height[right]，则必有leftMax &lt; rightMax，下标left能接的雨水量等于leftMax - height[left]，然后left向右移动一位</li><li>如果height[left] &gt;= height[right]，则必有leftMax &gt;= rightMax，下标right能接的雨水量等于rightMax - height[right]，然后right向左移动一位</li></ul><p>当两个指针相遇时，即可得到能接的雨水总量。</p><h4 id="实现代码：-2"><a href="#实现代码：-2" class="headerlink" title="实现代码："></a>实现代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,left = <span class="number">0</span>,right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>,rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            leftMax = <span class="built_in">max</span>(leftMax,height[left]);</span><br><span class="line">            rightMax = <span class="built_in">max</span>(rightMax,height[right]);</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                ans += leftMax - height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += rightMax - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(n)，其中 n 是数组height 的长度。两个指针的移动总次数不超过 n。</p></li><li><p>空间复杂度：O(1)，只需要使用常数的额外空间。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 个非负整数表示每个宽度为 &lt;code&gt;1&lt;/code&gt; 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="双指针" scheme="http://wangxu1905.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="动态规划" scheme="http://wangxu1905.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="单调栈" scheme="http://wangxu1905.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>P3368 【模板】树状数组 2</title>
    <link href="http://wangxu1905.github.io/2022/01/04/P3368%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%202/"/>
    <id>http://wangxu1905.github.io/2022/01/04/P3368%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%202/</id>
    <published>2022-01-04T09:56:28.308Z</published>
    <updated>2022-01-08T10:15:09.032Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li>将某区间每一个数数加上 x；</li><li>求出某一个数的值。</li></ol><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 N、M，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 N个用空格分隔的整数，其中第 i个数字表示数列第 i项的初始值。</p><p>接下来 M行每行包含 2 或 4个整数，表示一个操作，具体如下：</p><p>操作 1： 格式：<code>1 x y k</code> 含义：将区间 [x,y][<em>x</em>,<em>y</em>] 内每个数加上 k；</p><p>操作 2： 格式：<code>2 x</code> 含义：输出第 x个数的值。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 2的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><h4 id="样例-1-解释："><a href="#样例-1-解释：" class="headerlink" title="样例 1 解释："></a>样例 1 解释：</h4><p><img src="https://cdn.luogu.com.cn/upload/pic/2258.png" alt="img"></p><p>故输出结果为 6、10。</p><hr><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 30% 的数据：N≤8,M≤10;</p><p>对于 70% 的数据：N≤ 10000,M≤10000;</p><p>对于 100%的数据：1 ≤ N, M≤ 500000，1 ≤ x, y ≤n，保证任意时刻序列中任意元素的绝对值都不大于 2^30。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, m, tree[<span class="number">500100</span>], input[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k &amp; -k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">        tree[x] += k;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">        ans += tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; input[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y, z;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="built_in">add</span>(x, z);</span><br><span class="line">            <span class="built_in">add</span>(y + <span class="number">1</span>, -z);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; input[x] + <span class="built_in">search</span>(x) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如题，已知一个数列，你需要进行下面两种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将</summary>
      
    
    
    
    
    <category term="树状数组" scheme="http://wangxu1905.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>P3374 【模板】树状数组 1</title>
    <link href="http://wangxu1905.github.io/2022/01/04/P3374%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%201/"/>
    <id>http://wangxu1905.github.io/2022/01/04/P3374%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%201/</id>
    <published>2022-01-04T09:51:30.230Z</published>
    <updated>2022-01-08T10:15:25.631Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面两种操作：</p><ul><li>将某一个数加上 x</li><li>求出某区间每一个数的和</li></ul><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数 n,m，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 n个用空格分隔的整数，其中第 i 个数字表示数列第 i项的初始值。</p><p>接下来 m行每行包含 3个整数，表示一个操作，具体如下：</p><ul><li><code>1 x k</code> 含义：将第 x个数加上 k</li><li><code>2 x y</code> 含义：输出区间 [x,y][<em>x</em>,<em>y</em>] 内每个数的和</li></ul><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 2的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>【数据范围】</p><p>对于 30%30% 的数据，1 ≤ n ≤ 8，1≤ m ≤ 10；<br>对于 70%70% 的数据，1≤ n,m ≤ 10^4；<br>对于 100%100% 的数据，1≤ n,m ≤ 5×10^5。</p><p>样例说明：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/2256.png" alt="img"></p><p>故输出结果14、16</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,tree[<span class="number">2000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k &amp; -k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n)&#123;</span><br><span class="line">        tree[x] += k;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        ans += tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">add</span>(i,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">add</span>(b,c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">2</span>)</span><br><span class="line">            cout &lt;&lt; <span class="built_in">sum</span>(c) - <span class="built_in">sum</span>(b - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如题，已知一个数列，你需要进行下面两种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将某</summary>
      
    
    
    
    
    <category term="树状数组" scheme="http://wangxu1905.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>P2880 [USACO07JAN]Balanced Lineup G</title>
    <link href="http://wangxu1905.github.io/2022/01/04/P2880%20[USACO07JAN]Balanced%20Lineup%20G/"/>
    <id>http://wangxu1905.github.io/2022/01/04/P2880%20[USACO07JAN]Balanced%20Lineup%20G/</id>
    <published>2022-01-04T09:47:03.190Z</published>
    <updated>2022-01-08T10:15:48.994Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>For the daily milking, Farmer John’s N cows (1 ≤ N ≤ 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height.</p><p>Farmer John has made a list of Q (1 ≤ Q ≤ 180,000) potential groups of cows and their heights (1 ≤ height ≤ 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group.</p><p>每天,农夫 John 的 n(1\le n\le 5\times 10^4)<em>n</em>(1≤<em>n</em>≤5×104) 头牛总是按同一序列排队。</p><p>有一天, John 决定让一些牛们玩一场飞盘比赛。他准备找一群在队列中位置连续的牛来进行比赛。但是为了避免水平悬殊，牛的身高不应该相差太大。John 准备了 q(1\le q\le 1.8\times10^5)<em>q</em>(1≤<em>q</em>≤1.8×105) 个可能的牛的选择和所有牛的身高 h_i(1\le h_i\le 10^6,1\le i\le n)<em>h**i</em>(1≤<em>h**i</em>≤106,1≤<em>i</em>≤<em>n</em>)。他想知道每一组里面最高和最低的牛的身高差。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Line 1: Two space-separated integers, N and Q.</p><p>Lines 2..N+1: Line i+1 contains a single integer that is the height of cow i</p><p>Lines N+2..N+Q+1: Two integers A and B (1 ≤ A ≤ B ≤ N), representing the range of cows from A to B inclusive.</p><p>第一行两个数 n,q。</p><p>接下来 n行，每行一个数 h_i。</p><p>再接下来 q行，每行两个整数 a 和 b，表示询问第 a头牛到第 b头牛里的最高和最低的牛的身高差。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>Lines 1..Q: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range.</p><p>输出共 q行，对于每一组询问，输出每一组中最高和最低的牛的身高差。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>​    因为涉及到区间最值查询，可以用ST表实现（现在还没看懂），先贴上代码再说</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//lxy数组用于求最大值，hrb数组用于求最小值</span></span><br><span class="line"><span class="keyword">int</span> n,m,lxy[<span class="number">180010</span>][<span class="number">22</span>],hrb[<span class="number">180010</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ST</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="built_in">log2</span>(r - l + <span class="number">1</span>),x,y;</span><br><span class="line">    x = <span class="built_in">max</span>(lxy[l][s],lxy[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]);    <span class="comment">//区间最大</span></span><br><span class="line">    y = <span class="built_in">min</span>(hrb[l][s],hrb[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]);  <span class="comment">//区间最小</span></span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; lxy[i][<span class="number">0</span>];</span><br><span class="line">        hrb[i][<span class="number">0</span>] = lxy[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">21</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k + (<span class="number">1</span> &lt;&lt; i) &lt;= n + <span class="number">1</span>; ++k)&#123;</span><br><span class="line">            lxy[k][i] = <span class="built_in">max</span>(lxy[k][i - <span class="number">1</span>],lxy[k + (<span class="number">1</span> &lt;&lt;(i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">            hrb[k][i] = <span class="built_in">min</span>(hrb[k][i - <span class="number">1</span>],hrb[k + (<span class="number">1</span> &lt;&lt;(i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">ST</span>(l,r) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;For the daily milking, Farmer John’s N</summary>
      
    
    
    
    
    <category term="ST表" scheme="http://wangxu1905.github.io/tags/ST%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>7-9 重排链表 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/03/7-9%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/03/7-9%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%20(25%20%E5%88%86)/</id>
    <published>2022-01-03T13:26:35.327Z</published>
    <updated>2022-01-03T13:32:36.298Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定一个单链表 <em>L</em>1→<em>L</em>2→⋯→<em>L**n</em>−1→<em>L**n</em>，请编写程序将链表重新排列为 <em>L**n</em>→<em>L</em>1→<em>L**n</em>−1→<em>L</em>2→⋯。例如：给定<em>L</em>为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数<em>N</em> (≤105)。结点的地址是5位非负整数，NULL地址用−1表示。</p><p>接下来有<em>N</em>行，每行格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中<code>Address</code>是结点地址；<code>Data</code>是该结点保存的数据，为不超过105的正整数；<code>Next</code>是下一结点的地址。题目保证给出的链表上至少有两个结点。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00100</span> <span class="number">6</span></span><br><span class="line"><span class="number">00000</span> <span class="number">4</span> <span class="number">99999</span></span><br><span class="line"><span class="number">00100</span> <span class="number">1</span> <span class="number">12309</span></span><br><span class="line"><span class="number">68237</span> <span class="number">6</span> <span class="number">-1</span></span><br><span class="line"><span class="number">33218</span> <span class="number">3</span> <span class="number">00000</span></span><br><span class="line"><span class="number">99999</span> <span class="number">5</span> <span class="number">68237</span></span><br><span class="line"><span class="number">12309</span> <span class="number">2</span> <span class="number">33218</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">68237</span> <span class="number">6</span> <span class="number">00100</span></span><br><span class="line"><span class="number">00100</span> <span class="number">1</span> <span class="number">99999</span></span><br><span class="line"><span class="number">99999</span> <span class="number">5</span> <span class="number">12309</span></span><br><span class="line"><span class="number">12309</span> <span class="number">2</span> <span class="number">00000</span></span><br><span class="line"><span class="number">00000</span> <span class="number">4</span> <span class="number">33218</span></span><br><span class="line"><span class="number">33218</span> <span class="number">3</span> <span class="number">-1</span>结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> node_data[<span class="number">100001</span>],node_next[<span class="number">100001</span>];</span><br><span class="line">    <span class="keyword">int</span> head,n;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    cin &gt;&gt; head &gt;&gt; n;</span><br><span class="line">    <span class="comment">//初始化静态链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        node_data[a] = b;</span><br><span class="line">        node_next[a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历一遍链表，将各个结点的地址进行记录</span></span><br><span class="line">    <span class="keyword">int</span> h = head;</span><br><span class="line">    <span class="keyword">while</span>(h != <span class="number">-1</span>)&#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(h);</span><br><span class="line">        h = node_next[h];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是一个坑，对应一个测试点，因为会出现有多个结点为next都为-1，即不在该链表上的结点，所以要重新算一下长度</span></span><br><span class="line">    <span class="keyword">int</span> num = v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">address</span><span class="params">(num)</span></span>;</span><br><span class="line">    <span class="comment">//按题目要求，对链表结点进行重新排序</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>,high = num - <span class="number">1</span>,k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        address[k++] = v[high--];</span><br><span class="line">        address[k++] = v[low++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low == high) address[k] = v[low];</span><br><span class="line">    <span class="comment">//输出即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> add = address[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,add,node_data[add],address[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1\n&quot;</span>,address[num - <span class="number">1</span>],node_data[address[num - <span class="number">1</span>]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定一个单链表 &lt;em&gt;L&lt;/em&gt;1→&lt;em&gt;L&lt;/em&gt;2→⋯→&lt;em&gt;L**n&lt;/em&gt;−1→&lt;em&gt;L**n&lt;/em&gt;，请编写程序将链表重新排列为 &lt;em&gt;L**n&lt;/em&gt;→&lt;em&gt;L&lt;/em&gt;1→&lt;em&gt;L**n</summary>
      
    
    
    
    
    <category term="静态链表" scheme="http://wangxu1905.github.io/tags/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>7-6 最长对称子串 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/03/7-6%20%E6%9C%80%E9%95%BF%E5%AF%B9%E7%A7%B0%E5%AD%90%E4%B8%B2%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/03/7-6%20%E6%9C%80%E9%95%BF%E5%AF%B9%E7%A7%B0%E5%AD%90%E4%B8%B2%20(25%20%E5%88%86)/</id>
    <published>2022-01-03T12:28:33.225Z</published>
    <updated>2022-01-03T13:23:16.290Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定<code>Is PAT&amp;TAP symmetric?</code>，最长对称子串为<code>s PAT&amp;TAP s</code>，于是你应该输出11。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出长度不超过1000的非空字符串。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出最长对称子串的长度。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Is PAT&amp;TAP symmetric?</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>​    采用中心扩散法，主要是Manacher 算法一看就很复杂，不想学，中心扩散法的基本原理就是以每个元素作为中心，向左右两边扩散，如果无法继续扩散，此时和最大长度比较。</p><p>​    而字符串元素的个数分为奇数和偶数</p><ul><li>奇数：由中间一个字符作为中心进行扩散，对称轴为中间这个字符</li><li>偶数：由中间两个字符作为中心进行扩散，对称轴夹在两个字符中间</li></ul><p>力扣相关题：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5.最长回文子串</a></p><p>力扣视频链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/">最长回文子串</a></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(low &gt;= <span class="number">0</span> &amp;&amp; high &lt; s.<span class="built_in">size</span>() &amp;&amp; s[low] == s[high])&#123;</span><br><span class="line">        low--;</span><br><span class="line">        high++;</span><br><span class="line">    &#125;</span><br><span class="line">    maxlen = <span class="built_in">max</span>(maxlen,high - low - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="built_in">Judge</span>(i,i);</span><br><span class="line">        <span class="built_in">Judge</span>(i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxlen &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定&lt;code&gt;Is PAT&amp;amp;TAP symmetric?&lt;/code&gt;，最长对称子串为&lt;code&gt;s PAT&amp;amp;TAP s&lt;/code&gt;，于是你应该输出</summary>
      
    
    
    
    
    <category term="字符串" scheme="http://wangxu1905.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>C++ STL vector的find实现</title>
    <link href="http://wangxu1905.github.io/2022/01/03/C++%20STL%20vector%E7%9A%84find%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wangxu1905.github.io/2022/01/03/C++%20STL%20vector%E7%9A%84find%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-01-03T12:25:28.555Z</published>
    <updated>2022-01-03T12:27:54.456Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>不同于map（map有find方法），vector本身是没有find这一方法，其find是依靠algorithm来实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">        ve.<span class="built_in">push_back</span>(i);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(ve.<span class="built_in">begin</span>(), ve.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != ve.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;can not find&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;不同于map（map有find方法），vector本身是没有find这一方法，其find是依靠algorithm来实现的。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    
    <category term="C++函数" scheme="http://wangxu1905.github.io/tags/C-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++ sync_with_stdio和cin.tie(0),cout.tie(0)</title>
    <link href="http://wangxu1905.github.io/2022/01/03/C++%20sync_with_stdio%E5%92%8Ccin.tie(0),cout.tie(0)/"/>
    <id>http://wangxu1905.github.io/2022/01/03/C++%20sync_with_stdio%E5%92%8Ccin.tie(0),cout.tie(0)/</id>
    <published>2022-01-03T12:13:33.014Z</published>
    <updated>2022-01-03T12:19:56.699Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="1-ios-sync-with-stdio-false-的作用"><a href="#1-ios-sync-with-stdio-false-的作用" class="headerlink" title="1.ios::sync_with_stdio(false)的作用"></a>1.ios::sync_with_stdio(false)的作用</h3><p><strong>如果要关闭同步流ios::sync_with_stdio(false)来提高cin输入速度，就不能与getchar()混用，但是getchar()可以换成cin.get()！</strong></p><p>  作用是取消缓冲区同步，例如printf(),scanf()是C函数，而cin,cout是C++函数，这些函数需要用到各自的缓冲区，为了防止各自的缓冲区错位，C++默认将C函数和C++函数的缓冲区同步。 它的原理是使本该同步的输入输出流分开，就是让C的输入输出流和C++的输入输出流分开。</p><p>​        如果在此时用getchar(),读取的指挥室C语言的缓冲区，而不影响C++的缓冲区。所以应该采用cin.get()（效果等同于getchar(),但读取的是C++的缓冲区）</p><h3 id="2-tie"><a href="#2-tie" class="headerlink" title="2.tie"></a>2.tie</h3><p>tie是将两个<a href="https://so.csdn.net/so/search?q=stream">stream</a>绑定的函数，空参数的话返回当前的输出流指针。<br>在默认的情况下cin绑定的是cout，每次执行 &lt;&lt; 操作符的时候都要调用flush，这样会增加IO负担。可以通过tie(0)（0表示NULL）来解除cin与cout的绑定，进一步加快执行效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="3-ACM应用"><a href="#3-ACM应用" class="headerlink" title="3.ACM应用"></a>3.ACM应用</h3><p>在ACM里，经常出现数据集超大造成 cin TLE的情况。这时候大部分人认为这是cin的效率不及scanf的错，甚至还上升到C语言和C++语言的执行效率层面的无聊争论。其实像上文所说，这只是C++为了兼容而采取的保守措施。我们可以在IO之前将stdio解除绑定，这样做了之后要注意不要同时混用cout和printf之类。</p><p>在默认的情况下cin绑定的是cout，每次执行 &lt;&lt; 操作符的时候都要调用flush，这样会增加IO负担。可以通过tie(0)（0表示NULL）来解除cin与cout的绑定，进一步加快执行效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;1-ios-sync-with-stdio-false-的作用&quot;&gt;&lt;a href=&quot;#1-ios-sync-with-stdio-false-的作用&quot; class=&quot;headerlink&quot; title=&quot;1.ios</summary>
      
    
    
    
    
    <category term="C++函数" scheme="http://wangxu1905.github.io/tags/C-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++ 字符串补0,setw和setfill</title>
    <link href="http://wangxu1905.github.io/2022/01/03/C++%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A50,setw%E5%92%8Csetfill/"/>
    <id>http://wangxu1905.github.io/2022/01/03/C++%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A50,setw%E5%92%8Csetfill/</id>
    <published>2022-01-03T12:00:35.239Z</published>
    <updated>2022-01-03T12:05:19.975Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>为了实现字符串补0，所以使用set和setfill</p><ul><li>setw(5) ：设置字符串宽度，这里设置5字符</li><li>setfill(‘0’) ：设置填充字符，这里设置填充 0</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; s &lt;&lt; endl;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出： 00123</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;为了实现字符串补0，所以使用set和setfill&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;setw(5) ：设置字符串宽度，这里设置5字符&lt;/li&gt;
&lt;li&gt;setfill(‘0’) ：设置填充字符，这里设置填充 0&lt;/li&gt;
&lt;/ul</summary>
      
    
    
    
    
    <category term="C++函数" scheme="http://wangxu1905.github.io/tags/C-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
</feed>
