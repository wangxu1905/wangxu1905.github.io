<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moon</title>
  
  
  <link href="http://wangxu1905.github.io/atom.xml" rel="self"/>
  
  <link href="http://wangxu1905.github.io/"/>
  <updated>2021-10-24T03:36:25.176Z</updated>
  <id>http://wangxu1905.github.io/</id>
  
  <author>
    <name>Moon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>05-树8 File Transfer (25 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/24/05-%E6%A0%918%20File%20Transfer%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/24/05-%E6%A0%918%20File%20Transfer%20(25%20%E5%88%86)/</id>
    <published>2021-10-24T03:31:45.583Z</published>
    <updated>2021-10-24T03:36:25.176Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each test case, the first line contains <em>N</em> (2≤<em>N</em>≤104), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and <em>N</em>. Then in the following lines, the input is given in the format:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I c1 c2  </span><br></pre></td></tr></table></figure><p>where <code>I</code> stands for inputting a connection between <code>c1</code> and <code>c2</code>; or</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C c1 c2    </span><br></pre></td></tr></table></figure><p>where <code>C</code> stands for checking if it is possible to transfer files between <code>c1</code> and <code>c2</code>; or</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S</span><br></pre></td></tr></table></figure><p>where <code>S</code> stands for stopping this case.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each <code>C</code> case, print in one line the word “yes” or “no” if it is possible or impossible to transfer files between <code>c1</code> and <code>c2</code>, respectively. At the end of each case, print in one line “The network is connected.” if there is a path between any pair of computers; or “There are <code>k</code> components.” where <code>k</code> is the number of connected components in this network.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">C <span class="number">3</span> <span class="number">2</span></span><br><span class="line">I <span class="number">3</span> <span class="number">2</span></span><br><span class="line">C <span class="number">1</span> <span class="number">5</span></span><br><span class="line">I <span class="number">4</span> <span class="number">5</span></span><br><span class="line">I <span class="number">2</span> <span class="number">4</span></span><br><span class="line">C <span class="number">3</span> <span class="number">5</span></span><br><span class="line">S</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">There are <span class="number">2</span> components.</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">C <span class="number">3</span> <span class="number">2</span></span><br><span class="line">I <span class="number">3</span> <span class="number">2</span></span><br><span class="line">C <span class="number">1</span> <span class="number">5</span></span><br><span class="line">I <span class="number">4</span> <span class="number">5</span></span><br><span class="line">I <span class="number">2</span> <span class="number">4</span></span><br><span class="line">C <span class="number">3</span> <span class="number">5</span></span><br><span class="line">I <span class="number">1</span> <span class="number">3</span></span><br><span class="line">C <span class="number">1</span> <span class="number">5</span></span><br><span class="line">S</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">The network is connected.</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialization</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++i)</span><br><span class="line">        s[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到根节点，并且压缩路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[x] &lt; <span class="number">0</span>)    <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> s[x] = <span class="built_in">Find</span>(s[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过根节点的数组确定这棵树的结点总数，然后把结点少的接到结点多的树上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> Root1,<span class="keyword">int</span> Root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[Root2] &lt; s[Root1])&#123;</span><br><span class="line">        s[Root2] += s[Root1];</span><br><span class="line">        s[Root1] = Root2;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s[Root1] += s[Root2];</span><br><span class="line">        s[Root2] = Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果两个结点不属于同一个集合，则进行合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input_connection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    <span class="keyword">int</span> Root1 = <span class="built_in">Find</span>(u),Root2 = <span class="built_in">Find</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(Root1 != Root2)</span><br><span class="line">        <span class="built_in">Union</span>(Root1,Root2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查两个结点是否属于同一个集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Check_connection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    <span class="keyword">int</span> Root1 = <span class="built_in">Find</span>(u),Root2 = <span class="built_in">Find</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(Root1 != Root2)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查有几个集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Check_network</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">if</span>(s[i] &lt; <span class="number">0</span>)    ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The network is connected.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot; components.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">Initialization</span>();</span><br><span class="line">    <span class="keyword">char</span> in;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        cin &gt;&gt; in;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(in)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span> : <span class="built_in">Input_connection</span>();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span> : <span class="built_in">Check_connection</span>();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span> : <span class="built_in">Check_network</span>();<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(in != <span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;We have a network of computers and a list of bi-directional connections. Each of these connections allows a file</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
    <category term="并查集" scheme="http://wangxu1905.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>05-树7 堆中的路径 (25 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/24/05-%E6%A0%917%20%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/24/05-%E6%A0%917%20%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%20(25%20%E5%88%86)/</id>
    <published>2021-10-24T03:26:11.752Z</published>
    <updated>2021-10-24T03:29:29.380Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>将一系列给定数字插入一个初始为空的小顶堆<code>H[]</code>。随后对任意给定的下标<code>i</code>，打印从<code>H[i]</code>到根结点的路径。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>每组测试第1行包含2个正整数<em>N</em>和<em>M</em>(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的<em>N</em>个要被插入一个初始为空的小顶堆的整数。最后一行给出<em>M</em>个下标。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对输入中给出的每个下标<code>i</code>，在一行中输出从<code>H[i]</code>到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">46</span> <span class="number">23</span> <span class="number">26</span> <span class="number">24</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">24</span> <span class="number">23</span> <span class="number">10</span></span><br><span class="line"><span class="number">46</span> <span class="number">23</span> <span class="number">10</span></span><br><span class="line"><span class="number">26</span> <span class="number">10</span>结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> heap[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> heap_size;<span class="comment">//1~heap_size</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">()</span></span>&#123;</span><br><span class="line">    heap_size = <span class="number">0</span>;</span><br><span class="line">    heap[<span class="number">0</span>] = <span class="number">-100001</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> X)</span></span>&#123;</span><br><span class="line">    heap[++heap_size] = X;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = heap_size;heap[i] &lt; heap[i / <span class="number">2</span>]; i /= <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">swap</span>(heap[i],heap[i / <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">look_heap</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &gt; <span class="number">1</span>; i /= <span class="number">2</span>)</span><br><span class="line">        cout &lt;&lt; heap[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; heap[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,M,t;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">Create</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">Insert</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">look_heap</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;将一系列给定数字插入一个初始为空的小顶堆&lt;code&gt;H[]&lt;/code&gt;。随后对任意给定的下标&lt;code&gt;i&lt;/code&gt;，打印从&lt;code&gt;H[i]&lt;/code&gt;到根结点的路径。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>04-树6 Complete Binary Search Tree (30 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/24/04-%E6%A0%916%20Complete%20Binary%20Search%20Tree%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/24/04-%E6%A0%916%20Complete%20Binary%20Search%20Tree%20(30%20%E5%88%86)/</id>
    <published>2021-10-24T03:19:53.077Z</published>
    <updated>2021-10-24T03:22:30.325Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p><ul><li><p>The left subtree of a node contains only nodes with keys less than the node’s key.</p></li><li><p>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</p></li><li><p>Both the left and right subtrees must also be binary search trees.</p></li></ul><p>A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p><p>Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤1000). Then <em>N</em> distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">8</span> <span class="number">1</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">0</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; AVL,CBT;</span><br><span class="line"><span class="keyword">int</span> N,root = <span class="number">1</span>,pos = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//递归建树，不断深入左子树，然后从小到大开始建立结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build_CBT</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root &gt; N)    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * root;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//递归，按照左根右，从小到大的顺序建树</span></span><br><span class="line">        <span class="built_in">Build_CBT</span>(left);</span><br><span class="line">        CBT[root] = AVL[pos++];</span><br><span class="line">        <span class="built_in">Build_CBT</span>(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    AVL = vector&lt;<span class="keyword">int</span>&gt; (N,<span class="number">0</span>);</span><br><span class="line">    CBT = vector&lt;<span class="keyword">int</span>&gt; (N + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        cin &gt;&gt; AVL[i];</span><br><span class="line">    <span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(AVL.<span class="built_in">begin</span>(),AVL.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">Build_CBT</span>(root);</span><br><span class="line">    cout &lt;&lt; CBT[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N ; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; CBT[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:&lt;/p&gt;
&lt;ul&gt;
</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>4-11 Isomorphic (10 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/24/4-11%20Isomorphic%20(10%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/24/4-11%20Isomorphic%20(10%20%E5%88%86)/</id>
    <published>2021-10-24T02:51:34.117Z</published>
    <updated>2021-10-24T03:02:13.450Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>Two trees, <code>T1</code> and <code>T2</code>, are <strong>isomorphic</strong> if <code>T1</code> can be transformed into <code>T2</code> by swapping left and right children of (some of the) nodes in <code>T1</code>. For instance, the two trees in Figure 1 are isomorphic because they are the same if the children of A, B, and G, but not the other nodes, are swapped. Give a polynomial time algorithm to decide if two trees are isomorphic.</p><p> <img src="https://images.ptausercontent.com/37" alt="img"><br>Figure 1</p><h3 id="Format-of-functions"><a href="#Format-of-functions" class="headerlink" title="Format of functions:"></a>Format of functions:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Isomorphic</span><span class="params">( Tree T1, Tree T2 )</span></span>;</span><br></pre></td></tr></table></figure><p>where <code>Tree</code> is defined as the following:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree  Left;</span><br><span class="line">    Tree  Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The function is supposed to return 1 if <code>T1</code> and <code>T2</code> are indeed isomorphic, or 0 if not.</p><h3 id="Sample-program-of-judge"><a href="#Sample-program-of-judge" class="headerlink" title="Sample program of judge:"></a>Sample program of judge:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree  Left;</span><br><span class="line">    Tree  Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">BuildTree</span><span class="params">()</span></span>; <span class="comment">/* details omitted */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Isomorphic</span><span class="params">( Tree T1, Tree T2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree T1, T2;</span><br><span class="line">    T1 = <span class="built_in">BuildTree</span>();</span><br><span class="line">    T2 = <span class="built_in">BuildTree</span>();</span><br><span class="line">    <span class="built_in">printf</span>(“%d\n”, <span class="built_in">Isomorphic</span>(T1, T2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Your function will be put here */</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1-for-the-trees-shown-in-Figure-1"><a href="#Sample-Output-1-for-the-trees-shown-in-Figure-1" class="headerlink" title="Sample Output 1 (for the trees shown in Figure 1):"></a>Sample Output 1 (for the trees shown in Figure 1):</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2-for-the-trees-shown-in-Figure-2"><a href="#Sample-Output-2-for-the-trees-shown-in-Figure-2" class="headerlink" title="Sample Output 2 (for the trees shown in Figure 2):"></a>Sample Output 2 (for the trees shown in Figure 2):</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p><img src="https://images.ptausercontent.com/38" alt="img"><br>Figure2</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​    如果T1,T2都为空，则一定相等，如果其中只有一个不为空或者两个结点的值，则一定不等。</p><p>​    就是比较两个结点各自的左与左，右与右孩子；或者进行一个交换，比较两个结点各自的左与右，右与左孩子</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Isomorphic</span><span class="params">( Tree T1, Tree T2 )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T1 == <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T1 == <span class="literal">NULL</span> || T2 == <span class="literal">NULL</span> || T1 -&gt; Element != T2 -&gt; Element) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (Isomorphic(T1-&gt;Left,T2-&gt;Left)&amp;&amp;Isomorphic(T1-&gt;Right,T2-&gt;Right))||(Isomorphic(T1-&gt;Left,T2-&gt;Right)&amp;&amp;Isomorphic(T1-&gt;Right,T2-&gt;Left));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;Two trees, &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;, are &lt;strong&gt;isomorphic&lt;/strong&gt; if &lt;code&gt;T1&lt;/code&gt; can be transf</summary>
      
    
    
    
    
    <category term="周练习" scheme="http://wangxu1905.github.io/tags/%E5%91%A8%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>4-15 根据后序和中序遍历输出先序遍历 (15 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/24/4-15%20%E6%A0%B9%E6%8D%AE%E5%90%8E%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%20(15%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/24/4-15%20%E6%A0%B9%E6%8D%AE%E5%90%8E%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BE%93%E5%87%BA%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%20(15%20%E5%88%86)/</id>
    <published>2021-10-24T02:46:22.751Z</published>
    <updated>2021-10-24T02:47:13.380Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>本题要求根据给定的一棵二叉树的后序遍历和中序遍历结果，输出该树的先序遍历结果。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行给出正整数<em>N</em>(≤30)，是树中结点的个数。随后两行，每行给出<em>N</em>个整数，分别对应后序遍历和中序遍历结果，数字间以空格分隔。题目保证输入正确对应一棵二叉树。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出<code>Preorder: </code>以及该树的先序遍历结果。数字间有1个空格，行末不得有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2 3 1 5 7 6 4</span><br><span class="line">1 2 3 4 5 6 7结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Preorder: 4 1 3 2 6 5 7</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span> *<span class="title">BTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    BTree left,right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; post,in;</span><br><span class="line"><span class="comment">//利用递归，先从后序遍历中找到根节点，然后在中序遍历中找到该节点，分出左右子树来</span></span><br><span class="line"><span class="comment">//然后后序遍历根的上一个就是右子树的根，而做子树的根位置为根的位置减去右子树全部结点的个数</span></span><br><span class="line"><span class="function">BTree <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span>(pos = start ; pos &lt; end; ++pos)</span><br><span class="line">        <span class="keyword">if</span>(in[pos] == post[root])  <span class="keyword">break</span>;</span><br><span class="line">    BTree node = (BTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BtNode));</span><br><span class="line">    node -&gt; data = post[root];</span><br><span class="line">    node -&gt; left = <span class="built_in">BuildTree</span>(root - <span class="number">1</span> - end + pos,start,pos - <span class="number">1</span>);</span><br><span class="line">    node -&gt; right = <span class="built_in">BuildTree</span>(root - <span class="number">1</span>,pos + <span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BTree bt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!bt) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; bt -&gt; data;</span><br><span class="line">    <span class="built_in">PreOrder</span>(bt -&gt; left);</span><br><span class="line">    <span class="built_in">PreOrder</span>(bt -&gt; right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    post.<span class="built_in">resize</span>(N);</span><br><span class="line">    in.<span class="built_in">resize</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)</span><br><span class="line">        cin &gt;&gt; post[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;++i)</span><br><span class="line">        cin &gt;&gt; in[i];</span><br><span class="line">    BTree bt = <span class="built_in">BuildTree</span>(N - <span class="number">1</span>,<span class="number">0</span>,N - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Preorder:&quot;</span> ;</span><br><span class="line">    <span class="built_in">PreOrder</span>(bt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;本题要求根据给定的一棵二叉树的后序遍历和中序遍历结果，输出该树的先序遍历结果。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式:&quot;&gt;&lt;/a&gt;输</summary>
      
    
    
    
    
    <category term="周练习" scheme="http://wangxu1905.github.io/tags/%E5%91%A8%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>4-14 还原二叉树</title>
    <link href="http://wangxu1905.github.io/2021/10/24/4-14%20%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wangxu1905.github.io/2021/10/24/4-14%20%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-10-24T02:22:51.436Z</published>
    <updated>2021-10-24T02:36:41.058Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>4-14 还原二叉树 (15 分)</p><p>给定一棵二叉树的先序遍历序列和中序遍历序列，要求计算该二叉树的高度。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入首先给出正整数N（≤50），为树中结点总数。下面两行先后给出先序和中序遍历序列，均是长度为N的不包含重复英文字母（区别大小写）的字符串。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出为一个整数，即该二叉树的高度。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">ABDFGHIEC</span><br><span class="line">FDHGIBEAC结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span> *<span class="title">BTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    BTree left,right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">string pre,in;<span class="comment">//存储先序和中序序列</span></span><br><span class="line"><span class="comment">//利用递归，先从先序遍历中找到根节点，然后在中序遍历中找到该节点，分出左右子树来</span></span><br><span class="line"><span class="comment">//然后先序遍历根的下一个就是左子树的根，而右子树的根位置为根的位置加上左子树全部结点的个数</span></span><br><span class="line"><span class="function">BTree <span class="title">BuildTree</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span>(pos = start ; pos &lt; end; ++pos)</span><br><span class="line">        <span class="keyword">if</span>(in[pos] == pre[root])  <span class="keyword">break</span>;</span><br><span class="line">    BTree node = (BTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BtNode));</span><br><span class="line">    node -&gt; data = pre[root];</span><br><span class="line">    node -&gt; left = <span class="built_in">BuildTree</span>(root + <span class="number">1</span>,start,pos - <span class="number">1</span>);</span><br><span class="line">    node -&gt; right = <span class="built_in">BuildTree</span>(root + <span class="number">1</span> + pos - start,pos + <span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">(BTree bt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!bt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">GetHeight</span>(bt -&gt; left),<span class="built_in">GetHeight</span>(bt -&gt; right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">getline</span>(cin,pre);</span><br><span class="line">    <span class="built_in">getline</span>(cin,in);</span><br><span class="line">    BTree bt = <span class="built_in">BuildTree</span>(<span class="number">0</span>,<span class="number">0</span>,N - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">GetHeight</span>(bt) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;4-14 还原二叉树 (15 分)&lt;/p&gt;
&lt;p&gt;给定一棵二叉树的先序遍历序列和中序遍历序列，要求计算该二叉树的高度。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="周练习" scheme="http://wangxu1905.github.io/tags/%E5%91%A8%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>03-树1 树的同构 (25 分)</title>
    <link href="http://wangxu1905.github.io/2021/10/22/03-%E6%A0%911%20%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2021/10/22/03-%E6%A0%911%20%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84%20(25%20%E5%88%86)/</id>
    <published>2021-10-22T12:33:12.912Z</published>
    <updated>2021-10-24T03:38:25.872Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p><table><thead><tr><th><img src="https://images.ptausercontent.com/0c8bbacf-d64e-4c6d-8d4e-1249e33fb0b1.jpg" alt="fig1.jpg"></th></tr></thead><tbody><tr><td>图1</td></tr><tr><td><img src="https://images.ptausercontent.com/29" alt="img"></td></tr><tr><td>图2</td></tr></tbody></table><p>现给定两棵树，请你判断它们是否是同构的。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数<em>N</em> (≤10)，即该树的结点数（此时假设结点从0到<em>N</em>−1编号）；随后<em>N</em>行，第<em>i</em>行对应编号第<em>i</em>个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p><h3 id="输入样例1（对应图1）："><a href="#输入样例1（对应图1）：" class="headerlink" title="输入样例1（对应图1）："></a>输入样例1（对应图1）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">A <span class="number">1</span> <span class="number">2</span></span><br><span class="line">B <span class="number">3</span> <span class="number">4</span></span><br><span class="line">C <span class="number">5</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">6</span> -</span><br><span class="line">G <span class="number">7</span> -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line"><span class="number">8</span></span><br><span class="line">G - <span class="number">4</span></span><br><span class="line">B <span class="number">7</span> <span class="number">6</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">5</span> <span class="number">1</span></span><br><span class="line">H - -</span><br><span class="line">C <span class="number">0</span> -</span><br><span class="line">D - -</span><br><span class="line">E <span class="number">2</span> -结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输入样例2（对应图2）："><a href="#输入样例2（对应图2）：" class="headerlink" title="输入样例2（对应图2）："></a>输入样例2（对应图2）：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">B <span class="number">5</span> <span class="number">7</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">0</span> <span class="number">3</span></span><br><span class="line">C <span class="number">6</span> -</span><br><span class="line">H - -</span><br><span class="line">D - -</span><br><span class="line">G <span class="number">4</span> -</span><br><span class="line">E <span class="number">1</span> -</span><br><span class="line"><span class="number">8</span></span><br><span class="line">D <span class="number">6</span> -</span><br><span class="line">B <span class="number">5</span> -</span><br><span class="line">E - -</span><br><span class="line">H - -</span><br><span class="line">C <span class="number">0</span> <span class="number">2</span></span><br><span class="line">G - <span class="number">3</span></span><br><span class="line">F - -</span><br><span class="line">A <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Tree left,right;</span><br><span class="line">    <span class="keyword">int</span> flag;  <span class="comment">//是否访问过</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>;  <span class="comment">//创建树的根节点</span></span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>;  <span class="comment">//构建一棵树</span></span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>;  <span class="comment">//在树中插入新的节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>;  <span class="comment">//检查树的节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T,<span class="keyword">int</span> N)</span></span>;  <span class="comment">//判断是否是同一棵二叉搜索树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span>;     <span class="comment">//将树的各个节点flag重置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span>;  <span class="comment">//释放树的空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,L;</span><br><span class="line">    Tree T;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        cin &gt;&gt; L;</span><br><span class="line">        T = <span class="built_in">MakeTree</span>(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L ; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Judge</span>(T,N))</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">ResetT</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FreeTree</span>(T);</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    Tree T = (Tree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(TreeNode));</span><br><span class="line">    T -&gt; v = V;</span><br><span class="line">    T -&gt; left = T -&gt; right = <span class="literal">NULL</span>;</span><br><span class="line">    T -&gt; flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    Tree T;</span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line">    cin &gt;&gt; V;</span><br><span class="line">    T = <span class="built_in">NewNode</span>(V);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N ; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; V;</span><br><span class="line">        T = <span class="built_in">Insert</span>(T,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) T = <span class="built_in">NewNode</span>(V);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(V &gt; T -&gt; v)</span><br><span class="line">            T -&gt; right = <span class="built_in">Insert</span>(T -&gt; right,V);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T -&gt; left = <span class="built_in">Insert</span>(T -&gt; left,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果flag为1，则当前节点已经访问过，要找的节点可能在左右子树，或者节点已经重复</span></span><br><span class="line">    <span class="keyword">if</span>(T -&gt; flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(V &lt; T -&gt; v)  <span class="keyword">return</span> <span class="built_in">check</span>(T -&gt; left,V);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(V &gt; T -&gt; v) <span class="keyword">return</span> <span class="built_in">check</span>(T -&gt; right,V);</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果没访问过，如果该节点正好是要找的节点，则flag设为1</span></span><br><span class="line">        <span class="keyword">if</span>(V == T -&gt; v)&#123;</span><br><span class="line">            T -&gt; flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为要把一个测试用例的全部数据读完，所以设置flag判断是否是同一棵，读完所有数据后，才返回0或者1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V,flag = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; V;</span><br><span class="line">    <span class="comment">//如果根节点不同，则直接flag = 1</span></span><br><span class="line">    <span class="keyword">if</span>(V != T -&gt; v) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    T -&gt; flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N ; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; V;</span><br><span class="line">        <span class="comment">//如果已经判断不是同一棵，则不用调用check函数</span></span><br><span class="line">        <span class="keyword">if</span>((!flag) &amp;&amp; (!<span class="built_in">check</span>(T,V)))</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; left)   <span class="built_in">ResetT</span>(T -&gt; left);</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; right)  <span class="built_in">ResetT</span>(T -&gt; right);</span><br><span class="line">    T -&gt; flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; left)   <span class="built_in">FreeTree</span>(T -&gt; left);</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; right)  <span class="built_in">FreeTree</span>(T -&gt; right);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。&lt;/</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>04-树4 是否是同一棵二叉搜索树</title>
    <link href="http://wangxu1905.github.io/2021/10/18/04-%E6%A0%914%20%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://wangxu1905.github.io/2021/10/18/04-%E6%A0%914%20%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2021-10-18T02:55:38.743Z</published>
    <updated>2021-10-24T03:23:58.878Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入包含若干组测试数据。每组数据的第1行给出两个正整数<em>N</em> (≤10)和<em>L</em>，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出<em>N</em>个以空格分隔的正整数，作为初始插入序列。随后<em>L</em>行，每行给出<em>N</em>个插入的元素，属于<em>L</em>个需要检查的序列。</p><p>简单起见，我们保证每个插入序列都是1到<em>N</em>的一个排列。当读到<em>N</em>为0时，标志输入结束，这组数据不要处理。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No结尾无空行</span><br></pre></td></tr></table></figure><p><strong>鸣谢青岛大学周强老师补充测试数据！</strong></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Tree left,right;</span><br><span class="line">    <span class="keyword">int</span> flag;  <span class="comment">//是否访问过</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>;  <span class="comment">//创建树的根节点</span></span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>;  <span class="comment">//构建一棵树</span></span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>;  <span class="comment">//在树中插入新的节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>;  <span class="comment">//检查树的节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T,<span class="keyword">int</span> N)</span></span>;  <span class="comment">//判断是否是同一棵二叉搜索树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span>;     <span class="comment">//将树的各个节点flag重置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span>;  <span class="comment">//释放树的空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,L;</span><br><span class="line">    Tree T;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        cin &gt;&gt; L;</span><br><span class="line">        T = <span class="built_in">MakeTree</span>(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L ; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Judge</span>(T,N))</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">ResetT</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FreeTree</span>(T);</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    Tree T = (Tree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(TreeNode));</span><br><span class="line">    T -&gt; v = V;</span><br><span class="line">    T -&gt; left = T -&gt; right = <span class="literal">NULL</span>;</span><br><span class="line">    T -&gt; flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    Tree T;</span><br><span class="line">    <span class="keyword">int</span> V;</span><br><span class="line">    cin &gt;&gt; V;</span><br><span class="line">    T = <span class="built_in">NewNode</span>(V);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N ; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; V;</span><br><span class="line">        T = <span class="built_in">Insert</span>(T,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) T = <span class="built_in">NewNode</span>(V);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(V &gt; T -&gt; v)</span><br><span class="line">            T -&gt; right = <span class="built_in">Insert</span>(T -&gt; right,V);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T -&gt; left = <span class="built_in">Insert</span>(T -&gt; left,V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果flag为1，则当前节点已经访问过，要找的节点可能在左右子树，或者节点已经重复</span></span><br><span class="line">    <span class="keyword">if</span>(T -&gt; flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(V &lt; T -&gt; v)  <span class="keyword">return</span> <span class="built_in">check</span>(T -&gt; left,V);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(V &gt; T -&gt; v) <span class="keyword">return</span> <span class="built_in">check</span>(T -&gt; right,V);</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果没访问过，如果该节点正好是要找的节点，则flag设为1</span></span><br><span class="line">        <span class="keyword">if</span>(V == T -&gt; v)&#123;</span><br><span class="line">            T -&gt; flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为要把一个测试用例的全部数据读完，所以设置flag判断是否是同一棵，读完所有数据后，才返回0或者1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V,flag = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; V;</span><br><span class="line">    <span class="comment">//如果根节点不同，则直接flag = 1</span></span><br><span class="line">    <span class="keyword">if</span>(V != T -&gt; v) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    T -&gt; flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N ; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; V;</span><br><span class="line">        <span class="comment">//如果已经判断不是同一棵，则不用调用check函数</span></span><br><span class="line">        <span class="keyword">if</span>((!flag) &amp;&amp; (!<span class="built_in">check</span>(T,V)))</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; left)   <span class="built_in">ResetT</span>(T -&gt; left);</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; right)  <span class="built_in">ResetT</span>(T -&gt; right);</span><br><span class="line">    T -&gt; flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; left)   <span class="built_in">FreeTree</span>(T -&gt; left);</span><br><span class="line">    <span class="keyword">if</span>(T -&gt; right)  <span class="built_in">FreeTree</span>(T -&gt; right);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入</summary>
      
    
    
    
    
    <category term="浙大慕课" scheme="http://wangxu1905.github.io/tags/%E6%B5%99%E5%A4%A7%E6%85%95%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>C++ string find()的返回值</title>
    <link href="http://wangxu1905.github.io/2021/10/18/C++%20string%20find()%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
    <id>http://wangxu1905.github.io/2021/10/18/C++%20string%20find()%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</id>
    <published>2021-10-18T02:49:56.505Z</published>
    <updated>2021-10-18T02:53:44.397Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = s.<span class="built_in">find</span>(<span class="string">&quot;o&quot;</span>);</span><br><span class="line">        cout &lt;&lt; index &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>能找到，则返回在字符串的第一个位置的下标</li><li>找不到的话返回-1</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    
    <category term="C++函数" scheme="http://wangxu1905.github.io/tags/C-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++ fill和memset</title>
    <link href="http://wangxu1905.github.io/2021/10/02/C++%20fill%E5%92%8Cmemset/"/>
    <id>http://wangxu1905.github.io/2021/10/02/C++%20fill%E5%92%8Cmemset/</id>
    <published>2021-10-02T13:18:29.279Z</published>
    <updated>2021-10-02T13:44:20.943Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><ul><li><p>memset 函数</p><ul><li>按照字节填充某字符</li><li>在头文件<cstring>中</cstring></li></ul></li><li><p> fill 函数</p></li><li><p>按照单元赋值，将一个区间的元素都赋同一个值</p></li><li><p>在命名空间std里</p></li><li><p>因为memset函数按照直接填充，所以一般memset只能用来填充char型数组，因为只有char型占一字节，如果填充int型数组，除了0和-1，其他的不能，因为只有00000000 = 0，-1同理，如果每一位都填充1，则11111111 = -1.</p></li><li><p>而fill 函数可以赋任何值</p><ul><li><p>赋值int数组：fill(arr , arr + n ,要赋的值)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[n];</span><br><span class="line">    <span class="built_in">fill</span>(arr, arr + n, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;   &quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给vector赋值：fill(v.begin(),v.end(),要赋的值)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">      <span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">          cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- memset的用法</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[n];</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;   &quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;memset 函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照字节填充某字符&lt;/li&gt;
&lt;li&gt;在头文件&lt;cstring&gt;中&lt;/cstring&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt; fill 函数&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="C++函数" scheme="http://wangxu1905.github.io/tags/C-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++ cin和getline</title>
    <link href="http://wangxu1905.github.io/2021/09/30/C++%20cin%E5%92%8Cgetline/"/>
    <id>http://wangxu1905.github.io/2021/09/30/C++%20cin%E5%92%8Cgetline/</id>
    <published>2021-09-30T03:16:55.445Z</published>
    <updated>2021-09-30T03:40:37.760Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>​    cin是在缓存区里把字符读走，会剩下\n在缓存区中，但getline对\n非常敏感，导致getline刚开始读取缓存区里直接读到\n就结束读入数据。</p><p>​    cin，流提取运算符根据它后面的变量类型读取数据，从非空白符号开始，遇到Enter、Space、Tab键时结束。</p><p>​    getline函数从istream中读取一行数据，当遇到”\n”时结束返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;变量n : &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串s : &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![屏幕截图 2021-09-30 113205](C:\Users\Lenovo\Desktop\屏幕截图 2021-09-30 113205.png)</p><p>例如上面，输入123后，123赋值给n，字符串读取缓冲区的\n直接结束。</p><p>可以在 cin &gt;&gt; n;后面加上cin.ignore();或者getchar();来解决</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;​    cin是在缓存区里把字符读走，会剩下\n在缓存区中，但getline对\n非常敏感，导致getline刚开始读取缓存区里直接读到\n就结束读入数据。&lt;/p&gt;
&lt;p&gt;​    cin，流提取运算符根据它后面的变量类型</summary>
      
    
    
    
    
    <category term="C++函数" scheme="http://wangxu1905.github.io/tags/C-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>迷宫的最短路径</title>
    <link href="http://wangxu1905.github.io/2021/09/23/%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>http://wangxu1905.github.io/2021/09/23/%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</id>
    <published>2021-09-23T12:47:07.391Z</published>
    <updated>2021-10-24T03:37:53.706Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>在一个m * n的迷宫中，0表示通路，1表示墙壁。左上角为迷宫的入口，右下角为迷宫的出口。求到达迷宫入口的最短路径。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    为了省去判断是否为迷宫边缘，可以把迷宫整体加一层强，变成（m + 2）* (n + 2)的迷宫，入口则变成了（1,1），出口为（m,n）.为了能够记录路径，我们可以记录当前的点的前驱点。</p><p>​    用结构体数组代替队列，以便进行打印路径。</p><p>​    我们从入口开始，进行试探。</p><p>​    从队头开始试探，只要有临近的格子能走就入队，然后队头出队，再从新的队头探索。一旦到达出口，就是最短路径，然后打印路径，因为没有去走多余的格子。就是直接试探当前点能走的临近的格子。</p><p>​    如果有多条路径可以到达终点，最短路径，其前驱的节点的数目少，则最先入队，所以只要谁最先判断成功是终点，谁就是最短路径。</p><p>​    为了防止走到重复节点，把走过的格子都赋值为-1即可。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 8</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; Item;</span><br><span class="line">Item mv[<span class="number">8</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[m + <span class="number">2</span>][n + <span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printpath</span><span class="params">(Node qu[], <span class="keyword">int</span> rear)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rear != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printpath</span>(qu,qu[rear].pre);</span><br><span class="line">        <span class="keyword">if</span>(qu[rear].x != m &amp;&amp; qu[rear].y != n)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) -&gt;&quot;</span>,qu[rear].x,qu[rear].y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>,qu[rear].x,qu[rear].y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node qu[m * n];</span><br><span class="line">    qu[front].x = <span class="number">1</span>;qu[front].y = <span class="number">1</span>;qu[front].pre = <span class="number">-1</span>;   <span class="comment">//记录入口</span></span><br><span class="line">    <span class="keyword">int</span> x, y, i, j;</span><br><span class="line">    <span class="keyword">while</span>(front &lt;= rear) &#123;</span><br><span class="line">        x = qu[front].x;y = qu[front].y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span> ; v &lt; <span class="number">8</span>; ++v) &#123;</span><br><span class="line">            i = x + mv[v].x;j = y + mv[v].y;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j] == <span class="number">0</span>) &#123;                            <span class="comment">//新点可到达的话，入队</span></span><br><span class="line">                arr[i][j] = <span class="number">-1</span>;</span><br><span class="line">                ++rear;</span><br><span class="line">                qu[rear].x = i;qu[rear].y = j;qu[rear].pre = front;</span><br><span class="line">                <span class="keyword">if</span>(i == m &amp;&amp; j == n) &#123;                  <span class="comment">//新的点如果是入口，则打印路径</span></span><br><span class="line">                    <span class="built_in">printpath</span>(qu, rear);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++front;            <span class="comment">//出队，继续试探一下个点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">path</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;在一个m * n的迷宫中，0表示通路，1表示墙壁。左上角为迷宫的入口，右下角为迷宫的出口。求到达迷宫入口的最短路径。&lt;/p&gt;
&lt;h2 id=&quot;算法思路&quot;&gt;&lt;a href=&quot;#算法思路&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="数据结构复习" scheme="http://wangxu1905.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="回溯法" scheme="http://wangxu1905.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>迷宫求解</title>
    <link href="http://wangxu1905.github.io/2021/09/23/%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/"/>
    <id>http://wangxu1905.github.io/2021/09/23/%E8%BF%B7%E5%AE%AB%E6%B1%82%E8%A7%A3/</id>
    <published>2021-09-23T12:30:19.236Z</published>
    <updated>2021-10-24T03:41:48.106Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>在一个m * n的迷宫中，0表示通路，1表示墙壁。左上角为迷宫的入口，右下角为迷宫的出口。判断迷宫是否有解。</p><h2 id="算法思路（深度优先搜索）"><a href="#算法思路（深度优先搜索）" class="headerlink" title="算法思路（深度优先搜索）"></a>算法思路（深度优先搜索）</h2><p>​    为了省去判断是否为迷宫边缘，可以把迷宫整体加一层强，变成（m + 2）* (n + 2)的迷宫，入口则变成了（1,1），出口为（m,n）.</p><p>​    我们从入口开始，进行试探。</p><p>​    当前格子具有两种情况:</p><ol><li>它临近的格子可走，则将当前格子入栈，移动到新的格子上，继续试探。</li><li>它所有临近的格子不可走，则回到已经入栈的上一个格子，上一个格子出栈。继续试探。</li></ol><p>​    当前格子正是出口时，return 1,如果搜索完所有能到达的格子都无法到达出口时，return 0.    </p><p>​    为了防止走到重复节点，把走过的格子都赋值为-1即可。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 8</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;Item;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;Node;</span><br><span class="line">Item mv[<span class="number">8</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> vis[m + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> arr[m + <span class="number">2</span>][n + <span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;    <span class="comment">//深度优先搜索的代码</span></span><br><span class="line">    <span class="keyword">if</span>(x == m &amp;&amp; y == n)    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[x + mv[i].x][y + mv[i].y] == <span class="number">0</span> &amp;&amp; vis[x + mv[i].x][y + mv[i].y] == <span class="number">0</span>)&#123;</span><br><span class="line">            vis[x + mv[i].x][y + mv[i].y] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x + mv[i].x,y + mv[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> arr[][n + <span class="number">2</span>])</span></span>&#123;</span><br><span class="line">    stack&lt;Node&gt; s;</span><br><span class="line">    Node tmp;</span><br><span class="line">    <span class="keyword">int</span> x,y,d,i,j;</span><br><span class="line">    tmp.x = <span class="number">1</span>;tmp.y = <span class="number">1</span>;tmp.d = <span class="number">-1</span>;</span><br><span class="line">    s.<span class="built_in">push</span>(tmp);</span><br><span class="line">    <span class="keyword">while</span>(s.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        tmp = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        x = tmp.x;y = tmp.y;d = tmp.d + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(d &lt; <span class="number">8</span>)&#123;</span><br><span class="line">            i = x + mv[d].x;</span><br><span class="line">            j = y + mv[d].y;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                tmp = &#123;x,y,d&#125;;</span><br><span class="line">                s.<span class="built_in">push</span>(tmp);</span><br><span class="line">                x = i;y = j;arr[x][y] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(x == m &amp;&amp; y == n)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>    d = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ++d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    vis[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">path</span>(arr))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;在一个m * n的迷宫中，0表示通路，1表示墙壁。左上角为迷宫的入口，右下角为迷宫的出口。判断迷宫是否有解。&lt;/p&gt;
&lt;h2 id=&quot;算法思路（深度优先搜索）&quot;&gt;&lt;a href=&quot;#算法思路（深度优先搜索）&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="数据结构复习" scheme="http://wangxu1905.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="回溯法" scheme="http://wangxu1905.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单链表合并</title>
    <link href="http://wangxu1905.github.io/2021/09/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6/"/>
    <id>http://wangxu1905.github.io/2021/09/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6/</id>
    <published>2021-09-20T03:23:56.023Z</published>
    <updated>2021-09-20T03:33:52.415Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>设有两个单链表A、B，其中元素递增有序，编写算法将A、B归并成一个按元素值递减（允许有相同值）有序的链表C，要求用A、B的原结点形成，不能重新申请节点。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>利用A、B两表有序的特点，依次进行比较，将当前较小值取出，插入到C表的头部，得到的C表为递降有序。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">merge</span><span class="params">(LinkList A, LinkList B)</span> </span>&#123;</span><br><span class="line">    LinkList C;</span><br><span class="line">    LinkNode *p, *q, *s;</span><br><span class="line">    p = A -&gt; next;</span><br><span class="line">    q = B -&gt; next;</span><br><span class="line">    C = A;</span><br><span class="line">    C -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p -&gt; data &lt; q -&gt; data) &#123;</span><br><span class="line">            s = p;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            s -&gt; next = C -&gt; next;</span><br><span class="line">            C -&gt; next = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)  p = q;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        s = p;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        s -&gt; next = C -&gt; next;</span><br><span class="line">        C -&gt; next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;设有两个单链表A、B，其中元素递增有序，编写算法将A、B归并成一个按元素值递减（允许有相同值）有序的链表C，要求用A、B的原结点形成，不能重新申请节点。&lt;/p&gt;
&lt;h2 id=&quot;算法思路&quot;&gt;&lt;a href=&quot;#算法思路&quot; c</summary>
      
    
    
    
    
    <category term="数据结构复习" scheme="http://wangxu1905.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>单链表逆置</title>
    <link href="http://wangxu1905.github.io/2021/09/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE/"/>
    <id>http://wangxu1905.github.io/2021/09/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE/</id>
    <published>2021-09-20T03:20:55.150Z</published>
    <updated>2021-09-20T03:23:48.190Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>依次取出原链表的每个结点，并将其作为第一个节点进行头插法，指针p用来指向原表中的当前节点，p为空时结束</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(LinkList head)</span> </span>&#123;</span><br><span class="line">    LinkNode *p, *q;</span><br><span class="line">    p = head -&gt; next;</span><br><span class="line">    head -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">        q -&gt; next = head -&gt; next;</span><br><span class="line">        head -&gt; next = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;算法思路&quot;&gt;&lt;a href=&quot;#算法思路&quot; class=&quot;headerlink&quot; title=&quot;算法思路&quot;&gt;&lt;/a&gt;算法思路&lt;/h2&gt;&lt;p&gt;依次取出原链表的每个结点，并将其作为第一个节点进行头插法，指针p用来指向原</summary>
      
    
    
    
    
    <category term="数据结构复习" scheme="http://wangxu1905.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>19. 删除链表的倒数第 N 个结点</title>
    <link href="http://wangxu1905.github.io/2021/09/19/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://wangxu1905.github.io/2021/09/19/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/</id>
    <published>2021-09-19T08:35:52.832Z</published>
    <updated>2021-09-19T08:48:04.097Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"></p><blockquote><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：head = [1], n = 1<br>输出：[]</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：head = [1,2], n = 1<br>输出：[1]</p></blockquote><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 sz</li><li>1 &lt;= sz &lt;= 30</li><li>0 &lt;= Node.val &lt;= 100</li><li>1 &lt;= n &lt;= sz</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>定义快慢指针，快指针先移动k - 1步，然后快慢指针一起移动，当快指针移动到链表表尾时，慢指针移动到倒数第k的结点的前驱结点，然后让前驱结点指向下一结点的下一个节点，实现删除。</p><p>当链表长不足k时，返回慢指针的下一个节点，即删除第一个节点。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* left = head;</span><br><span class="line">        ListNode* right = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            right = right -&gt; next;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">nullptr</span>)   <span class="keyword">return</span> left -&gt; next;</span><br><span class="line">        <span class="keyword">while</span>(right -&gt; next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            right = right -&gt; next;</span><br><span class="line">            left = left -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        left -&gt; next = left -&gt; next -&gt; next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;进阶：你能尝试使用一趟扫描实现吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:</summary>
      
    
    
    
    
    <category term="双指针" scheme="http://wangxu1905.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>678. 有效的括号字符串</title>
    <link href="http://wangxu1905.github.io/2021/09/12/678.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://wangxu1905.github.io/2021/09/12/678.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-09-12T07:36:27.936Z</published>
    <updated>2021-09-12T07:52:04.649Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><ol><li>任何左括号 <strong>(</strong> 必须有相应的右括号 **)**。</li><li>任何右括号 <strong>)</strong> 必须有相应的左括号 <strong>(</strong> 。</li><li>左括号 <strong>(</strong> 必须在对应的右括号之前 **)**。</li><li>*****可以被视为单个右括号 <strong>)</strong> ，或单个左括号 <strong>(</strong> ，或一个空字符串。</li><li>一个空字符串也被视为有效字符串。</li></ol><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parenthesis-string">https://leetcode-cn.com/problems/valid-parenthesis-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>示例 1：</strong></p><blockquote><p>输入: “()”<br>输出: True</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入: “(*)”<br>输出: True</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入: “(*))”<br>输出: True</p></blockquote><p><strong>注意：</strong></p><ul><li>字符串大小将在 [1，100] 范围内。</li></ul><h2 id="题解（贪心）"><a href="#题解（贪心）" class="headerlink" title="题解（贪心）"></a>题解（贪心）</h2><p>从左到右遍历字符串，遍历过程中，未匹配的左括号数量可能会出现如下变化：</p><ul><li>如果遇到左括号，则未匹配的左括号数量加 1；</li><li>如果遇到右括号，则需要有一个左括号和右括号匹配，因此未匹配的左括号数量减 1；</li><li>如果遇到星号，由于星号可以看成左括号、右括号或空字符串，因此未匹配的左括号数量可能加 1、减 1 或不变。</li></ul><p>基于上述结论，可以在遍历过程中维护未匹配的左括号数量可能的最小值和最大值，根据遍历到的字符更新最小值和最大值：</p><ul><li>如果遇到左括号，则将最小值和最大值分别加 1；</li><li>如果遇到右括号，则将最小值和最大值分别减 1；</li><li>如果遇到星号，则将最小值减 1，将最大值加 1。</li></ul><p>任何情况下，未匹配的左括号数量必须非负，因此当最大值变成负数时，说明没有左括号可以和右括号匹配，返回 false。</p><p>当最小值为 0 时，不应将最小值继续减少，以确保最小值非负。</p><p>遍历结束时，所有的左括号都应和右括号匹配，因此只有当最小值为 0 时，字符串 s才是有效的括号字符串。</p><p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/valid-parenthesis-string/solution/you-xiao-de-gua-hao-zi-fu-chuan-by-leetc-osi3/">https://leetcode-cn.com/problems/valid-parenthesis-string/solution/you-xiao-de-gua-hao-zi-fu-chuan-by-leetc-osi3/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。    </p><h2 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkValidString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lmin = <span class="number">0</span>,lmax = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                ++lmin;</span><br><span class="line">                ++lmax;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                --lmax;</span><br><span class="line">                lmin = <span class="built_in">max</span>(lmin - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(lmax &lt; <span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ++lmax;</span><br><span class="line">                lmin = <span class="built_in">max</span>(lmin - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lmin == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>​    <strong>时间复杂度：</strong>O(n)</p><p>​    <strong>空间复杂度：</strong>O(1)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任何左括号 &lt;strong&gt;(&lt;/strong&gt; 必须有相应的右括号 **)*</summary>
      
    
    
    
    
    <category term="贪心" scheme="http://wangxu1905.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>881. 救生艇</title>
    <link href="http://wangxu1905.github.io/2021/08/26/881.%20%E6%95%91%E7%94%9F%E8%89%87/"/>
    <id>http://wangxu1905.github.io/2021/08/26/881.%20%E6%95%91%E7%94%9F%E8%89%87/</id>
    <published>2021-08-26T07:59:08.880Z</published>
    <updated>2021-08-26T08:05:16.612Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。</p><p>返回载到每一个人所需的最小船数。(保证每个人都能被船载)。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/boats-to-save-people">https://leetcode-cn.com/problems/boats-to-save-people</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：people = [1,2], limit = 3<br>输出：1<br>解释：1 艘船载 (1, 2)</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：people = [3,2,2,1], limit = 3<br>输出：3<br>解释：3 艘船分别载 (1, 2), (2) 和 (3)</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：people = [3,5,3,4], limit = 5<br>输出：4<br>解释：4 艘船分别载 (3), (3), (4), (5)</p></blockquote><p><strong>提示：</strong></p><ul><li>1 &lt;= people.length &lt;= 50000</li><li>1 &lt;= people[i] &lt;= limit &lt;= 30000</li></ul><h2 id="题解（贪心）"><a href="#题解（贪心）" class="headerlink" title="题解（贪心）"></a>题解（贪心）</h2><p>​    由于一条船最多做两个人，首先考虑体重最小的和最高的，如果两个人能做一条船，则是最优做法，这样把求解范围缩小到 n - 2,如果体重和超过限制，则没有人能和最重的人做一条船，则最重的单独做一条船，把求解范围缩小到 n - 1</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRescueBoats</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; people, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = people.<span class="built_in">size</span>() - <span class="number">1</span>,cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(people[left] + people[right] &lt;= limit)</span><br><span class="line">                ++left;</span><br><span class="line">            --right;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。&lt;/p&gt;
&lt;p&gt;每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。&lt;/p&gt;
&lt;p&gt;返回载到每一个人所需的最小船数。(保证每个</summary>
      
    
    
    
    
    <category term="贪心算法" scheme="http://wangxu1905.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>802. 找到最终的安全状态</title>
    <link href="http://wangxu1905.github.io/2021/08/05/802.%20%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/"/>
    <id>http://wangxu1905.github.io/2021/08/05/802.%20%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/</id>
    <published>2021-08-05T00:51:50.710Z</published>
    <updated>2021-08-05T01:43:27.172Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。</p><p>对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。</p><p>返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。</p><p>该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-eventual-safe-states">https://leetcode-cn.com/problems/find-eventual-safe-states</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>示例 1：</strong></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png"></p><blockquote><p>输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]]<br>输出：[2,4,5,6]<br>解释：示意图如上。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]<br>输出：[4]</p></blockquote><p><strong>提示：</strong></p><ul><li>n == graph.length</li><li>1 &lt;= n &lt;= 104</li><li>0 &lt;= graph[i].length &lt;= n</li><li>graph[i] 按严格递增顺序排列。</li><li>图中可能包含自环。</li><li>图中边的数目在范围 [1, 4 * 104] 内</li></ul><h2 id="题解（DFS、三色标记）"><a href="#题解（DFS、三色标记）" class="headerlink" title="题解（DFS、三色标记）"></a>题解（DFS、三色标记）</h2><p>​    若起始节点在一个环内，或者能到达一个环，则这个节点是不安全的。否则，该节点是安全的。</p><p>​    我们可以使用深度优先搜索来找环，并在深度优先搜索时，用三种颜色对节点进标记，标记的规则如下：</p><ul><li>白色（用0表示）：该节点尚未被访问</li><li>灰色（用1表示）：该节点位于递归栈中，或者在某个环上</li><li>黑色（用2表示）：该节点搜索完毕，是一个安全节点。</li></ul><p>​    当我们首次访问一个节点时，将其标记为灰色，并继续搜索与其相连的节点。</p><p>​    如果在搜索过程中遇到了一个灰色节点，则说明找到了一个环，此时退出搜索，栈中的节点仍保持为灰色，这一做法可以将[找到了环]这一信息传递到栈中的所有节点上。</p><p>​    如果搜索过程中没有遇到灰色节点，则说明没有遇到环，那么递归返回前，我们将其标记由灰色改为黑色，即表示它是一个安全的节点。</p><h2 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">eventualSafeNodes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">color</span><span class="params">(n)</span></span>; </span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>)&gt; safe = [&amp;](<span class="keyword">int</span> x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[x] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> color[x] == <span class="number">2</span>;</span><br><span class="line">            color[x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y : graph[x])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">safe</span>(y))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            color[x] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">safe</span>(i))</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度：O(n+m)，其中 n 是图中的点数，m 是图中的边数。</p></li><li><p>空间复杂度：O(n)，存储节点颜色以及递归栈的开销均为 O(n)</p></li></ul><h2 id="题解（拓扑排序）"><a href="#题解（拓扑排序）" class="headerlink" title="题解（拓扑排序）"></a>题解（拓扑排序）</h2><p>​    根据题意，若一个节点没有出边，则该节点是安全的；若一个节点出边相连的点都是安全的，则该节点是安全的。</p><p>​    根据这一性质，我们可以将图中所有边反向，得到一个反图，然后在反图上进行拓扑排序。</p><p>​    具体来说，首先得到反图rg及其入度数组indeg。将所有入度为0的点加入队列，然后不断取出队首数组，将其出边相连的点的入度减一，若该点入度减一后为0，则该点加入队列，如此循环至队列为空。循环结束后，所有入度为0的节点均为安全的。我们遍历入度数组，并将入度为0的点加入答案数组。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">eventualSafeNodes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">rg</span>(n);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">indeg</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j : graph[i])&#123;</span><br><span class="line">                rg[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            indeg[i] = graph[i].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indeg[i] == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> it : rg[t])&#123;</span><br><span class="line">                <span class="keyword">if</span>(--indeg[it] == <span class="number">0</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indeg[i] == <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度：O(n+m)，其中 n 是图中的点数，m 是图中的边数。</p></li><li><p>空间复杂度：O(n+m)。需要 O(n+m) 的空间记录反图。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。&lt;/p&gt;
&lt;p&gt;对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然</summary>
      
    
    
    
    
    <category term="DFS" scheme="http://wangxu1905.github.io/tags/DFS/"/>
    
    <category term="三色标记" scheme="http://wangxu1905.github.io/tags/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/"/>
    
    <category term="拓扑排序" scheme="http://wangxu1905.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>581. 最短无序连续子数组</title>
    <link href="http://wangxu1905.github.io/2021/08/03/581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://wangxu1905.github.io/2021/08/03/581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2021-08-03T01:09:17.116Z</published>
    <updated>2021-08-03T03:33:30.340Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 最短 子数组，并输出它的长度。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray">https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [2,6,4,8,10,9,15]<br>输出：5<br>解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [1,2,3,4]<br>输出：0</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：nums = [1]<br>输出：0</p></blockquote><p><strong>提示：</strong></p><ul><li>1 &lt;= nums.length &lt;= 104</li><li>-105 &lt;= nums[i] &lt;= 105</li></ul><h2 id="题解（双指针）"><a href="#题解（双指针）" class="headerlink" title="题解（双指针）"></a>题解（双指针）</h2><p>​        将数组分成三部分numsA,numsB,numsC，然后对numsB进行排序，使整体数组有序，即整体排序后numsA和numsC不变。我们只要找到numsB，返回其长度即可。<br>      我们创建数组nums的拷贝t,然后对其排序，分别从左和右进行比较，找到第一个不相同的位置，确定numsB的左边界和右边界，返回numsB的长度。<br>      特别地，当原数组有序时，numB的长度为0，直接返回结果。</p><h2 id="实现代码：（双指针）"><a href="#实现代码：（双指针）" class="headerlink" title="实现代码：（双指针）"></a>实现代码：（双指针）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_sorted</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>())) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; t = nums;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(t[left] == nums[left])</span><br><span class="line">            ++left;</span><br><span class="line">        <span class="keyword">while</span>(t[right] == nums[right])</span><br><span class="line">            --right;</span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>​    <strong>时间复杂度：</strong>O(nlogn)，其中 n 为给定数组的长度。我们需要 O(nlogn) 的时间进行排序，以及 O(n) 的时间遍历数组，因此总时间复杂度为O(nlogn)。</p><p>​    <strong>空间复杂度：</strong>O(n)，其中 n为给定数组的长度。我们需要额外的一个数组保存排序后的数组t.</p><h2 id="题解（一次遍历）"><a href="#题解（一次遍历）" class="headerlink" title="题解（一次遍历）"></a>题解（一次遍历）</h2><p>​    假设numsB在nums中对应区间为 [left,right],注意到numsB和numsC的任意一个数都大于等于numsA中任意一个数，因此有numsA中每一个数都满足：</p><p>​    numsⅰ ≤ min numsj (i + 1 ≤  j  ≤  n  - 1 )</p><p>我们可以从大到小枚举 i，用minn记录民 numsj(i + 1 ≤  j  ≤  n  - 1)。每次移动i,都可以O（1）地更新minn。这样最后一个使得不等式成立的i即为left.</p><p>​    同理，我们可以用类似的方法确定right。我们可以通过一次循环同时完成左右边界的计算。</p><p>​    特别地，当原数组有序时，numB的长度为0，直接返回结果。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxn = INT_MIN, right = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> minn = INT_MAX, left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxn &gt; nums[i])</span><br><span class="line">                right = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                maxn = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(minn &lt; nums[n - <span class="number">1</span> - i])</span><br><span class="line">                left = n - <span class="number">1</span> -i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                minn = nums[n - <span class="number">1</span> - i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right == <span class="number">-1</span> ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>​    <strong>时间复杂度：</strong>O(n)，其中 n 是给定数组的长度，我们仅需要遍历该数组一次。</p><p>​    <strong>空间复杂度：</strong>O(1)。我们只需要常数的空间保存若干变量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。&lt;/p&gt;
&lt;p&gt;请你找出符合题意的 最短 子数组，并输出它的长度。&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetC</summary>
      
    
    
    
    
    <category term="双指针" scheme="http://wangxu1905.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
