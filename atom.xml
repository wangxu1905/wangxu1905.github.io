<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moon</title>
  
  
  <link href="http://wangxu1905.github.io/atom.xml" rel="self"/>
  
  <link href="http://wangxu1905.github.io/"/>
  <updated>2022-01-10T13:08:18.918Z</updated>
  <id>http://wangxu1905.github.io/</id>
  
  <author>
    <name>Moon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>P1616 疯狂的采药</title>
    <link href="http://wangxu1905.github.io/2022/01/10/P1616%20%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF/"/>
    <id>http://wangxu1905.github.io/2022/01/10/P1616%20%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF/</id>
    <published>2022-01-10T03:21:18.747Z</published>
    <updated>2022-01-10T13:08:18.918Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>此题为纪念 LiYuxiang 而生。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是 LiYuxiang，你能完成这个任务吗？</p><p>此题和原题的不同点：</p><ol><li><p>每种草药可以无限制地疯狂采摘。</p></li><li><p>药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！</p></li></ol><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第一行有两个整数，分别代表总共能够用来采药的时间 t<em>t</em> 和代表山洞里的草药的数目 m。</p><p>第 2 到第 (m + 1)行，每行两个整数，第 (i + 1)行的整数 a_i, b_i分别表示采摘第 i 种草药的时间和该草药的价值。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">70</span> <span class="number">3</span></span><br><span class="line"><span class="number">71</span> <span class="number">100</span></span><br><span class="line"><span class="number">69</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">140</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul><li>对于 30% 的数据，保证m≤10^3 。</li><li>对于 100% 的数据，保证 1≤m≤10^4， 1≤t≤10^7，且 1≤m×t≤10^7， 1≤a_i,b_i≤10^4。</li></ul><h2 id="算法思路（动态规划）"><a href="#算法思路（动态规划）" class="headerlink" title="算法思路（动态规划）"></a>算法思路（动态规划）</h2><p>经典完全背包问题</p><p>OI梗：**==十年 OI 一场空，不开 long long 见祖宗。==**</p><p>这题用二维dp数组，开出来太大了（也可以试试滚动数组），所以只能用一维dp</p><p>完全背包问题和0-1背包问题的递推式不同是，完全背包问题它放进物品的时候，是考虑它的同一行，而不是上一行，因为考虑的是同一行，所以遍历的时候可以进行顺序遍历，同时当j &lt; w[i]的时候，d[j]是不会发生改变的，因为装不进去，所以该从w[i]开始遍历</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">10000001</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">10001</span>], v[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t, m;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = w[i]; j &lt;= t; ++j)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j - w[i]] + v[i],dp[j]);</span><br><span class="line">    cout &lt;&lt; dp[t] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目背景&quot;&gt;&lt;a href=&quot;#题目背景&quot; class=&quot;headerlink&quot; title=&quot;题目背景&quot;&gt;&lt;/a&gt;题目背景&lt;/h2&gt;&lt;p&gt;此题为纪念 LiYuxiang 而生。&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;</summary>
      
    
    
    
    
    <category term="dp" scheme="http://wangxu1905.github.io/tags/dp/"/>
    
    <category term="完全背包" scheme="http://wangxu1905.github.io/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>P1048 [NOIP2005 普及组] 采药</title>
    <link href="http://wangxu1905.github.io/2022/01/10/P1048%20[NOIP2005%20%E6%99%AE%E5%8F%8A%E7%BB%84]%20%E9%87%87%E8%8D%AF/"/>
    <id>http://wangxu1905.github.io/2022/01/10/P1048%20[NOIP2005%20%E6%99%AE%E5%8F%8A%E7%BB%84]%20%E9%87%87%E8%8D%AF/</id>
    <published>2022-01-10T02:33:03.506Z</published>
    <updated>2022-01-10T12:56:05.694Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是辰辰，你能完成这个任务吗？</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有 2 个整数 T（1≤T≤1000）和 M（1≤M≤100），用一个空格隔开，T 代表总共能够用来采药的时间，M 代表山洞里的草药的数目。</p><p>接下来的 M 行每行包括两个在 1 到 100 之间（包括 1 和 100）的整数，分别表示采摘某株草药的时间和这株草药的价值。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出在规定的时间内可以采到的草药的最大总价值。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">70 3</span><br><span class="line">71 100</span><br><span class="line">69 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p><strong>【数据范围】</strong></p><ul><li>对于 30% 的数据，M≤10；</li><li>对于全部的数据，M≤100。</li></ul><p><strong>【题目来源】</strong></p><p>NOIP 2005 普及组第三题</p><h2 id="算法思路（动态规划）"><a href="#算法思路（动态规划）" class="headerlink" title="算法思路（动态规划）"></a>算法思路（动态规划）</h2><p>​    经典0-1背包问题</p><h4 id="1-二维dp数组"><a href="#1-二维dp数组" class="headerlink" title="1.二维dp数组"></a>1.二维dp数组</h4><p>dp[i][j]代表前i个物品，容量为j的情况下的能选择的最大价值，</p><p>于是我们有如下递推式：dp[0][j] = 0</p><p><svg xmlns="http://www.w3.org/2000/svg" width="58.472ex" height="5.428ex" viewbox="0 -1449.5 25844.7 2399" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-640-TEX-I-1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/><path id="MJX-640-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/><path id="MJX-640-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-640-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path id="MJX-640-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/><path id="MJX-640-TEX-I-1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/><path id="MJX-640-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-640-TEX-S3-7B" d="M618 -943L612 -949H582L568 -943Q472 -903 411 -841T332 -703Q327 -682 327 -653T325 -350Q324 -28 323 -18Q317 24 301 61T264 124T221 171T179 205T147 225T132 234Q130 238 130 250Q130 255 130 258T131 264T132 267T134 269T139 272T144 275Q207 308 256 367Q310 436 323 519Q324 529 325 851Q326 1124 326 1154T332 1205Q369 1358 566 1443L582 1450H612L618 1444V1429Q618 1413 616 1411L608 1406Q599 1402 585 1393T552 1372T515 1343T479 1305T449 1257T429 1200Q425 1180 425 1152T423 851Q422 579 422 549T416 498Q407 459 388 424T346 364T297 318T250 284T214 264T197 254L188 251L205 242Q290 200 345 138T416 3Q421 -18 421 -48T423 -349Q423 -397 423 -472Q424 -677 428 -694Q429 -697 429 -699Q434 -722 443 -743T465 -782T491 -816T519 -845T548 -868T574 -886T595 -899T610 -908L616 -910Q618 -912 618 -928V-943Z"/><path id="MJX-640-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/><path id="MJX-640-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-640-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-640-TEX-N-3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/><path id="MJX-640-TEX-I-1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/><path id="MJX-640-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path id="MJX-640-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/><path id="MJX-640-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/><path id="MJX-640-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-640-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/><path id="MJX-640-TEX-I-1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/><path id="MJX-640-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-640-TEX-I-1D451"/></g><g data-mml-node="mi" transform="translate(520, 0)"><use xlink:href="#MJX-640-TEX-I-1D45D"/></g><g data-mml-node="mo" transform="translate(1023, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(1301, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(1646, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(1924, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(2202, 0)"><use xlink:href="#MJX-640-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(2614, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(3169.8, 0)"><use xlink:href="#MJX-640-TEX-N-3D"/></g><g data-mml-node="mrow" transform="translate(4225.6, 0)"><g data-mml-node="mo"><use xlink:href="#MJX-640-TEX-S3-7B"/></g><g data-mml-node="mtable" transform="translate(750, 0)"><g data-mml-node="mtr" transform="translate(0, 600)"><g data-mml-node="mtd"><g data-mml-node="mi"><use xlink:href="#MJX-640-TEX-I-1D451"/></g><g data-mml-node="mi" transform="translate(520, 0)"><use xlink:href="#MJX-640-TEX-I-1D45D"/></g><g data-mml-node="mo" transform="translate(1023, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(1301, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(1868.2, 0)"><use xlink:href="#MJX-640-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(2868.4, 0)"><use xlink:href="#MJX-640-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(3368.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(3646.4, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(3924.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(4336.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(4614.4, 0)"><use xlink:href="#MJX-640-TEX-N-2C"/></g><g data-mml-node="mo" transform="translate(5059.1, 0)"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">当</text></g><g data-mml-node="mi" transform="translate(6220.9, 0)"><use xlink:href="#MJX-640-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(6910.7, 0)"><use xlink:href="#MJX-640-TEX-N-3C"/></g><g data-mml-node="mi" transform="translate(7966.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D464"/></g><g data-mml-node="mo" transform="translate(8682.4, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(8960.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(9305.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g></g></g><g data-mml-node="mtr" transform="translate(0, -600)"><g data-mml-node="mtd"><g data-mml-node="mi"><use xlink:href="#MJX-640-TEX-I-1D45A"/></g><g data-mml-node="mi" transform="translate(878, 0)"><use xlink:href="#MJX-640-TEX-I-1D44E"/></g><g data-mml-node="mi" transform="translate(1407, 0)"><use xlink:href="#MJX-640-TEX-I-1D465"/></g><g data-mml-node="mo" transform="translate(1979, 0)"><use xlink:href="#MJX-640-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(2368, 0)"><use xlink:href="#MJX-640-TEX-I-1D451"/></g><g data-mml-node="mi" transform="translate(2888, 0)"><use xlink:href="#MJX-640-TEX-I-1D45D"/></g><g data-mml-node="mo" transform="translate(3391, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(3669, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(4236.2, 0)"><use xlink:href="#MJX-640-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(5236.4, 0)"><use xlink:href="#MJX-640-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(5736.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(6014.4, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(6292.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(6704.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(6982.4, 0)"><use xlink:href="#MJX-640-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(7427.1, 0)"><use xlink:href="#MJX-640-TEX-I-1D451"/></g><g data-mml-node="mi" transform="translate(7947.1, 0)"><use xlink:href="#MJX-640-TEX-I-1D45D"/></g><g data-mml-node="mo" transform="translate(8450.1, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(8728.1, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(9295.3, 0)"><use xlink:href="#MJX-640-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(10295.6, 0)"><use xlink:href="#MJX-640-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(10795.6, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(11073.6, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(11351.6, 0)"><use xlink:href="#MJX-640-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(11985.8, 0)"><use xlink:href="#MJX-640-TEX-N-2212"/></g><g data-mml-node="mi" transform="translate(12986, 0)"><use xlink:href="#MJX-640-TEX-I-1D464"/></g><g data-mml-node="mo" transform="translate(13702, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(13980, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(14325, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(14603, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(15103.2, 0)"><use xlink:href="#MJX-640-TEX-N-2B"/></g><g data-mml-node="mi" transform="translate(16103.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D463"/></g><g data-mml-node="mo" transform="translate(16588.4, 0)"><use xlink:href="#MJX-640-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(16866.4, 0)"><use xlink:href="#MJX-640-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(17211.4, 0)"><use xlink:href="#MJX-640-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(17489.4, 0)"><use xlink:href="#MJX-640-TEX-N-29"/></g><g data-mml-node="mo" transform="translate(17878.4, 0)"><use xlink:href="#MJX-640-TEX-N-2C"/></g><g data-mml-node="mo" transform="translate(18323.1, 0)"><use xlink:href="#MJX-640-TEX-N-28"/></g><g data-mml-node="mo" transform="translate(18712.1, 0)"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">其</text><text data-variant="normal" transform="translate(884, 0) matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">他</text></g><g data-mml-node="mo" transform="translate(20480.1, 0)"><use xlink:href="#MJX-640-TEX-N-29"/></g></g></g></g><g data-mml-node="mo" transform="translate(21619.1, 0)"/></g></g></g></svg></p><ul><li>当容量小于w[i]，那么说明放不下第i件物品，则前i种物品的最大价值和前i-1种最大物品价值的情况相同，即dp[i][j] = dp[i-1][j]</li><li>当能装下，则要给第i件物品留下足够的空间，对应前i-1种物品，容量为j-w[i]的最大价值加上v[i]，然后和dp[i-1][j]比较取最大，即                       dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])</li></ul><h4 id="2-一维dp数组"><a href="#2-一维dp数组" class="headerlink" title="2.一维dp数组"></a>2.一维dp数组</h4><p>我们从上面二维数组可以看出，dp[i][j]只与它的上一行dp[i-1]有关，所以可以用改用一维数组，因为当前值和它的上一行有关，所以进行遍历的时候要反向遍历</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">101</span>], v[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t, m;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; w[i])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j - w[i]] + v[i], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m][t] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">101</span>], v[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t, m;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = t;j &gt;= <span class="number">1</span>; --j)</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= w[i])</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j - w[i]] +v[i]);</span><br><span class="line">    cout &lt;&lt; dp[t] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最</summary>
      
    
    
    
    
    <category term="dp" scheme="http://wangxu1905.github.io/tags/dp/"/>
    
    <category term="01背包" scheme="http://wangxu1905.github.io/tags/01%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>202112-2 序列查询新解</title>
    <link href="http://wangxu1905.github.io/2022/01/09/202112-2%20%E5%BA%8F%E5%88%97%E6%9F%A5%E8%AF%A2%E6%96%B0%E8%A7%A3/"/>
    <id>http://wangxu1905.github.io/2022/01/09/202112-2%20%E5%BA%8F%E5%88%97%E6%9F%A5%E8%AF%A2%E6%96%B0%E8%A7%A3/</id>
    <published>2022-01-09T03:05:49.338Z</published>
    <updated>2022-01-09T08:45:39.507Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="http://r.photo.store.qq.com/psc?/V12Ria3720LYpY/45NBuzDIW489QBoVep5mcfXJYuzIUsn09Rc0llLBgfU5f6DfDevaua.kXbvFHC0f0dETEmM1OrMBOaC2NtSrd9TsxVsIPThj1xVD8jrUVWg!/r"></p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>用样例一来进行解释</p><p>A = [0,2,5,8],n = 3,N = 10,r = 2</p><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>f(i)</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>3</td><td>3</td></tr><tr><td>g(i)</td><td>0</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>4</td><td>4</td></tr><tr><td>sum(i)</td><td>0</td><td>0</td><td>1</td><td>2</td><td>4</td><td>6</td><td>9</td><td>12</td><td>16</td><td>20</td></tr><tr><td>|g(i) - f(i)|</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>根据亲身体验，哎，遍历一遍i铁定超时，所以换个思路</p><p>将遍历i改为遍历f(i)，这样的话也就不用开数组保存f(i)的值了，因为f(i)的范围为[0,n],这是可以事先已知的。</p><p>以f(i) = 0为例，g(i)此时为{0,0},要求|g(i) - f(i)|，只需要让f(i)的区间和 - g(i)的区间和即可，f(i)的区间和可以直接区间长度*f(i)的值，g(i)的值需要把g(i)看成r个等差数列即可，因为g(i) = {0,0,1,1,2,2,3,3,4,4},可以看成由2（r）个等差数列组成的数列，则它的求前i项和的公式为</p><p><svg xmlns="http://www.w3.org/2000/svg" width="46.463ex" height="6.749ex" viewbox="0 -1717.4 20536.7 2983.1" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-428-TEX-LO-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"/><path id="MJX-428-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-428-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-428-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/><path id="MJX-428-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path id="MJX-428-TEX-I-1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/><path id="MJX-428-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-428-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/><path id="MJX-428-TEX-I-1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path id="MJX-428-TEX-N-D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/><path id="MJX-428-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/><path id="MJX-428-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-428-TEX-N-2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"/><path id="MJX-428-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/><path id="MJX-428-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-428-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-428-TEX-N-25" d="M465 605Q428 605 394 614T340 632T319 641Q332 608 332 548Q332 458 293 403T202 347Q145 347 101 402T56 548Q56 637 101 693T202 750Q241 750 272 719Q359 642 464 642Q580 642 650 732Q662 748 668 749Q670 750 673 750Q682 750 688 743T693 726Q178 -47 170 -52Q166 -56 160 -56Q147 -56 142 -45Q137 -36 142 -27Q143 -24 363 304Q469 462 525 546T581 630Q528 605 465 605ZM207 385Q235 385 263 427T292 548Q292 617 267 664T200 712Q193 712 186 709T167 698T147 668T134 615Q132 595 132 548V527Q132 436 165 403Q183 385 203 385H207ZM500 146Q500 234 544 290T647 347Q699 347 737 292T776 146T737 0T646 -56Q590 -56 545 0T500 146ZM651 -18Q679 -18 707 24T736 146Q736 215 711 262T644 309Q637 309 630 306T611 295T591 265T578 212Q577 200 577 146V124Q577 -18 647 -18H651Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="munderover"><g data-mml-node="mo"><use xlink:href="#MJX-428-TEX-LO-2211"/></g><g data-mml-node="TeXAtom" transform="translate(86, -1107.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-428-TEX-I-1D458"/></g><g data-mml-node="mo" transform="translate(521, 0)"><use xlink:href="#MJX-428-TEX-N-3D"/></g><g data-mml-node="mn" transform="translate(1299, 0)"><use xlink:href="#MJX-428-TEX-N-30"/></g></g><g data-mml-node="TeXAtom" transform="translate(600, 1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-428-TEX-I-1D456"/></g></g></g><g data-mml-node="mi" transform="translate(1610.7, 0)"><use xlink:href="#MJX-428-TEX-I-1D454"/></g><g data-mml-node="mo" transform="translate(2087.7, 0)"><use xlink:href="#MJX-428-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(2476.7, 0)"><use xlink:href="#MJX-428-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(2821.7, 0)"><use xlink:href="#MJX-428-TEX-N-29"/></g><g data-mml-node="mo" transform="translate(3488.4, 0)"><use xlink:href="#MJX-428-TEX-N-3D"/></g><g data-mml-node="mi" transform="translate(4544.2, 0)"><use xlink:href="#MJX-428-TEX-I-1D45F"/></g><g data-mml-node="mo" transform="translate(5217.4, 0)"><use xlink:href="#MJX-428-TEX-N-D7"/></g><g data-mml-node="mstyle" transform="translate(6217.7, 0)"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220, 589.5) scale(0.707)"><g data-mml-node="mo"><use xlink:href="#MJX-428-TEX-N-28"/></g><g data-mml-node="mfrac" transform="translate(389, 0)"><g data-mml-node="mrow" transform="translate(220, 398) scale(0.707)"><g data-mml-node="mi"><use xlink:href="#MJX-428-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(345, 0)"><use xlink:href="#MJX-428-TEX-N-2B"/></g><g data-mml-node="mn" transform="translate(1123, 0)"><use xlink:href="#MJX-428-TEX-N-31"/></g></g><g data-mml-node="mi" transform="translate(634.4, -345) scale(0.707)"><use xlink:href="#MJX-428-TEX-I-1D45F"/></g><rect width="1347.6" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1976.6, 0)"><use xlink:href="#MJX-428-TEX-N-29"/></g><g data-mml-node="mo" transform="translate(2365.6, 0)"><use xlink:href="#MJX-428-TEX-N-2217"/></g><g data-mml-node="mo" transform="translate(2865.6, 0)"><use xlink:href="#MJX-428-TEX-N-28"/></g><g data-mml-node="mfrac" transform="translate(3254.6, 0)"><g data-mml-node="mrow" transform="translate(220, 398) scale(0.707)"><g data-mml-node="mi"><use xlink:href="#MJX-428-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(345, 0)"><use xlink:href="#MJX-428-TEX-N-2B"/></g><g data-mml-node="mn" transform="translate(1123, 0)"><use xlink:href="#MJX-428-TEX-N-31"/></g></g><g data-mml-node="mi" transform="translate(634.4, -345) scale(0.707)"><use xlink:href="#MJX-428-TEX-I-1D45F"/></g><rect width="1347.6" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(4842.3, 0)"><use xlink:href="#MJX-428-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(5620.3, 0)"><use xlink:href="#MJX-428-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(6120.3, 0)"><use xlink:href="#MJX-428-TEX-N-29"/></g></g><g data-mml-node="mn" transform="translate(2344.6, -345) scale(0.707)"><use xlink:href="#MJX-428-TEX-N-32"/></g><rect width="4802.7" height="60" x="120" y="220"/></g></g><g data-mml-node="mo" transform="translate(11482.6, 0)"><use xlink:href="#MJX-428-TEX-N-2B"/></g><g data-mml-node="mo" transform="translate(12482.9, 0)"><use xlink:href="#MJX-428-TEX-N-28"/></g><g data-mml-node="mo" transform="translate(12871.9, 0)"><use xlink:href="#MJX-428-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(13260.9, 0)"><use xlink:href="#MJX-428-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(14083.1, 0)"><use xlink:href="#MJX-428-TEX-N-2B"/></g><g data-mml-node="mn" transform="translate(15083.3, 0)"><use xlink:href="#MJX-428-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(15583.3, 0)"><use xlink:href="#MJX-428-TEX-N-29"/></g><g data-mml-node="mi" transform="translate(15972.3, 0)"><use xlink:href="#MJX-428-TEX-N-25"/></g><g data-mml-node="mi" transform="translate(16805.3, 0)"><use xlink:href="#MJX-428-TEX-I-1D45F"/></g><g data-mml-node="mo" transform="translate(17256.3, 0)"><use xlink:href="#MJX-428-TEX-N-29"/></g><g data-mml-node="mo" transform="translate(17867.5, 0)"><use xlink:href="#MJX-428-TEX-N-D7"/></g><g data-mml-node="mo" transform="translate(18867.7, 0)"><use xlink:href="#MJX-428-TEX-N-28"/></g><g data-mml-node="mfrac" transform="translate(19256.7, 0)"><g data-mml-node="mi" transform="translate(273, 676)"><use xlink:href="#MJX-428-TEX-I-1D456"/></g><g data-mml-node="mi" transform="translate(220, -686)"><use xlink:href="#MJX-428-TEX-I-1D45F"/></g><rect width="651" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(20147.7, 0)"><use xlink:href="#MJX-428-TEX-N-29"/></g></g></g></svg></p><p>当然，f(i)对应的g(i)区间存在三种情况</p><ul><li>g(i)的值都大于等于f(i)</li><li>g(i)的值都小于等于f(i)</li><li>g(i)中既有比f(i)小的，也有比f(i)大的</li></ul><p>前两种情况比较好算，只需要f(i)减去g(i)的区间和取绝对值即可，对于第三种，就需要把g(i)分成两部分，一部分都比f(i)小，一部分都比f(i)大，然后等同于前两种情况。</p><p>例如当f(i) = 1时，我们可以g(i)分为{1,1}和{2}两部分，然后分别计算求和</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,N,r;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt; <span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> r * ((i + <span class="number">1</span>) / r) * ((i + <span class="number">1</span>) / r - <span class="number">1</span>) / <span class="number">2</span> + (i + <span class="number">1</span>) % r * (i / r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">cal</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> fi,<span class="keyword">long</span> <span class="keyword">long</span> left,<span class="keyword">long</span> <span class="keyword">long</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">sum</span>(right) - <span class="built_in">sum</span>(left - <span class="number">1</span>) - fi * (right - left + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; N;</span><br><span class="line">    r = N / (n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> arr[n + <span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    arr[n + <span class="number">1</span>] = N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> fi = <span class="number">0</span>; fi &lt;= n; ++fi)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> left = arr[fi],right = arr[fi + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(left / r &gt;= fi || right / r &lt;= fi)   res += <span class="built_in">cal</span>(fi,left,right);</span><br><span class="line">        <span class="keyword">else</span>    res += <span class="built_in">cal</span>(fi,left,r * fi) + <span class="built_in">cal</span>(fi,r * fi + <span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;http://r.photo.store.qq.com/psc?/V12Ria3720LYpY/45NBuzDIW489QBoVep5mcfXJYuzIUsn09Rc0llLBgfU5f6DfDevaua</summary>
      
    
    
    
    
    <category term="CSP" scheme="http://wangxu1905.github.io/tags/CSP/"/>
    
    <category term="前缀和" scheme="http://wangxu1905.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="分治" scheme="http://wangxu1905.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>2022 新生摸底测试题目集</title>
    <link href="http://wangxu1905.github.io/2022/01/08/2022%20%E6%96%B0%E7%94%9F%E6%91%B8%E5%BA%95%E6%B5%8B%E8%AF%95%E9%A2%98%E7%9B%AE%E9%9B%86/"/>
    <id>http://wangxu1905.github.io/2022/01/08/2022%20%E6%96%B0%E7%94%9F%E6%91%B8%E5%BA%95%E6%B5%8B%E8%AF%95%E9%A2%98%E7%9B%AE%E9%9B%86/</id>
    <published>2022-01-08T13:35:16.483Z</published>
    <updated>2022-01-08T14:18:31.561Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="7-1-加法求值-10-分"><a href="#7-1-加法求值-10-分" class="headerlink" title="7-1 加法求值 (10 分)"></a><strong>7-1 加法求值 (10 分)</strong></h2><p>给定一个表达式<em>A</em>+<em>B</em>,输出<em>A</em>+<em>B</em>的值</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>一个长度不超过9且大于等于3的字符串，且保证是合法的中缀表达式。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出A+B的值。</p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">111</span>+<span class="number">2222</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2333</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哎，自己就是一顿字符串截取，没想过这种方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>,&amp;a,&amp;c,&amp;b);</span><br><span class="line">    cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4-然后是几点-15-分"><a href="#7-4-然后是几点-15-分" class="headerlink" title="7-4 然后是几点 (15 分)"></a><strong>7-4 然后是几点 (15 分)</strong></h2><p>有时候人们用四位数字表示一个时间，比如 <code>1106</code> 表示 11 点零 6 分。现在，你的程序要根据起始时间和流逝的时间计算出终止时间。</p><p>读入两个数字，第一个数字以这样的四位数字表示当前时间，第二个数字表示分钟数，计算当前时间经过那么多分钟后是几点，结果也表示为四位数字。当小时为个位数时，没有前导的零，例如 5 点 30 分表示为 <code>530</code>；0 点 30 分表示为 <code>030</code>。注意，第二个数字表示的分钟数可能超过 60，也可能是负数。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出 2 个整数，分别是四位数字表示的起始时间、以及流逝的分钟数，其间以空格分隔。注意：在起始时间中，当小时为个位数时，没有前导的零，即 5 点 30 分表示为 <code>530</code>；0 点 30 分表示为 <code>030</code>。流逝的分钟数可能超过 60，也可能是负数。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出不多于四位数字表示的终止时间，当小时为个位数时，没有前导的零。题目保证起始时间和终止时间在同一天内。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1120</span> <span class="number">110</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1310</span></span><br></pre></td></tr></table></figure><p><strong>鸣谢燕山大学穆运峰老师、用户任钰补充数据！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大佬的思路确实有点意思，我的思路太直了</span></span><br><span class="line"><span class="comment">//大佬是先算一共有多少分钟，再转换回去，%03d是为了防止出现0点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur,pass;</span><br><span class="line">    cin &gt;&gt; cur &gt;&gt; pass;</span><br><span class="line">    cur = <span class="number">60</span> * (cur / <span class="number">100</span>) + cur % <span class="number">100</span> + pass;</span><br><span class="line">    cur = <span class="number">100</span> * (cur / <span class="number">60</span>) + cur % <span class="number">60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%03d&quot;</span>,cur);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-5-凯撒密码-20-分"><a href="#7-5-凯撒密码-20-分" class="headerlink" title="7-5 凯撒密码 (20 分)"></a><strong>7-5 凯撒密码 (20 分)</strong></h2><p>为了防止信息被别人轻易窃取，需要把电码明文通过加密方式变换成为密文。输入一个以回车符为结束标志的字符串（少于80个字符），再输入一个整数offset，用凯撒密码将其加密后输出。恺撒密码是一种简单的替换加密技术，将明文中的所有字母都在字母表上偏移offset位后被替换成密文，当offset大于零时，表示向后偏移；当offset小于零时，表示向前偏移。</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第一行给出一个以回车结束的非空字符串（少于80个字符）；第二行输入一个整数offset。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出加密后的结果字符串。</p><h3 id="输入样例1-1"><a href="#输入样例1-1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello Hangzhou</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1-1"><a href="#输出样例1-1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jgnnq Jcpibjqw</span><br></pre></td></tr></table></figure><h3 id="输入样例2-1"><a href="#输入样例2-1" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=x+y</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2-1"><a href="#输出样例2-1" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z=w+x</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 重点是计算这个k，首先k先对26取余，转化成[-25,25]范围，然后再加26取余，这样就转化到了[0,25]的范围 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    k = (k % <span class="number">26</span> + <span class="number">26</span>) % <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            s[i] = <span class="string">&#x27;a&#x27;</span> + (s[i] - <span class="string">&#x27;a&#x27;</span> + k) % <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            s[i] = <span class="string">&#x27;A&#x27;</span> + (s[i] - <span class="string">&#x27;A&#x27;</span> + k ) % <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-7-取模运算-15-分"><a href="#7-7-取模运算-15-分" class="headerlink" title="7-7 取模运算 (15 分)"></a><strong>7-7 取模运算 (15 分)</strong></h2><p>给定两个数<em>a</em>,<em>b</em>,请输出<em>a</em> <em>m<strong>o</strong>d</em> <em>b</em></p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>输入仅有一行，每行包括两个数<em>a</em>(1≤<em>a</em>≤10^10^6),<em>b</em>(1≤<em>b</em>≤10^9).</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>输出 <em>a</em> <em>m<strong>o</strong>d</em> <em>b</em> 的值</p><h3 id="Sample-Input1"><a href="#Sample-Input1" class="headerlink" title="Sample Input1:"></a>Sample Input1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output1"><a href="#Sample-Output1" class="headerlink" title="Sample Output1:"></a>Sample Output1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Input2"><a href="#Sample-Input2" class="headerlink" title="Sample Input2:"></a>Sample Input2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output2"><a href="#Sample-Output2" class="headerlink" title="Sample Output2:"></a>Sample Output2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Input3"><a href="#Sample-Input3" class="headerlink" title="Sample Input3:"></a>Sample Input3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33333333333333333333333333333333</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output3"><a href="#Sample-Output3" class="headerlink" title="Sample Output3:"></a>Sample Output3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为只需要得到余数，所以只需要把高精度减法进行简化，只求余数即可</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod,res = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> &amp;c : s)</span><br><span class="line">        res = (res * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>) % mod;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-9-解密邀请码-20-分"><a href="#7-9-解密邀请码-20-分" class="headerlink" title="7-9 解密邀请码 (20 分)"></a><strong>7-9 解密邀请码 (20 分)</strong></h2><p>HBU开设了一门全网独一份的新课程，因此大家迫不及待的等待选课的到来以求选到该课程，但是在选择前需要输入课程的邀请码，任何申请该课程的同学都会收到一个神秘字符串，为了保障字符串的安全性以及自己的课程不被窃取，课程老师发明了一种压缩算法对邀请码中重复的部分进行了压缩，对于字符串中连续的m个相同字符串S将会压缩为<a href="m%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%941%3C=m%3C=200"><em>m</em>∣<em>S</em></a>，例如字符串HBUHBUHBU将会被压缩为[3∣<em>H<strong>B</strong>U</em>]，现在同学们收到了课程的邀请码字，你能帮助他们进行解密么？</p><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入一个字符串<em>S</em>(∣<em>S</em>∣≤50)，<em>S</em>展开后可能含有大写字母、小写字母与数字, 题目保证输入的字符串合法以及展开后的字符串长度不超过106且展开后的邀请码中不含∣</p><h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式:"></a>输出格式:</h3><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HB[<span class="number">3</span>|U[<span class="number">2</span>|HB]]U</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HBUHBHBUHBHBUHBHBU</span><br></pre></td></tr></table></figure><p>说明 HB[3|U[2|HB]]U−&gt;HB[3|UHBHB]U−&gt; HBUHBHBUHBHBUHBHBU</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这道题倒是比大佬的算法运算速度快，大佬的是用栈而且还是递归求解，我用的字符串的截取，从右向左扫描，最先扫描到的[,就是最内层的，然后截取字符串，按规则进行解密，然后重复上述过程，直到扫描不到[*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos1 = s.<span class="built_in">size</span>() - <span class="number">1</span>, pos2 = pos1, pos3 = pos1;</span><br><span class="line">        <span class="keyword">while</span>(pos1 &gt;= <span class="number">0</span> &amp;&amp; s[pos1] != <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[pos1] == <span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">                pos2 = pos1;</span><br><span class="line">            <span class="keyword">if</span>(s[pos1] == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                pos3 = pos1;</span><br><span class="line">            pos1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[pos1] == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">            string ptr = s.<span class="built_in">substr</span>(pos2 + <span class="number">1</span>, pos3 - pos2 - <span class="number">1</span>);</span><br><span class="line">            string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(pos1 + <span class="number">1</span>, pos2 - pos1 - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">                res += ptr;</span><br><span class="line">            s.<span class="built_in">erase</span>(pos1, pos3 - pos1 + <span class="number">1</span>);</span><br><span class="line">            s.<span class="built_in">insert</span>(pos1, res);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-10-这真的算得出来吗？-20-分"><a href="#7-10-这真的算得出来吗？-20-分" class="headerlink" title="7-10 这真的算得出来吗？ (20 分)"></a><strong>7-10 这真的算得出来吗？ (20 分)</strong></h2><p>给定一个值<em>X</em>, 求出 </p><p><svg xmlns="http://www.w3.org/2000/svg" width="11.533ex" height="4.07ex" viewbox="0 -1149.5 5097.4 1799" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style=""><defs><path id="MJX-2-TEX-SO-2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"/><path id="MJX-2-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-2-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/><path id="MJX-2-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-2-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-2-TEX-LO-230A" d="M224 -649V1150H275V-598H511V-649H224Z"/><path id="MJX-2-TEX-I-1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/><path id="MJX-2-TEX-LO-230B" d="M252 -598V1150H303V-649H16V-598H252Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mstyle"><g data-mml-node="munderover"><g data-mml-node="mo"><use xlink:href="#MJX-2-TEX-SO-2211"/></g><g data-mml-node="TeXAtom" transform="translate(1056, 477.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msup"><g data-mml-node="mn"><use xlink:href="#MJX-2-TEX-N-31"/><use xlink:href="#MJX-2-TEX-N-30" transform="translate(500, 0)"/></g><g data-mml-node="TeXAtom" transform="translate(1000, 393.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use xlink:href="#MJX-2-TEX-N-31"/><use xlink:href="#MJX-2-TEX-N-30" transform="translate(500, 0)"/><use xlink:href="#MJX-2-TEX-N-30" transform="translate(1000, 0)"/></g></g></g></g><g data-mml-node="TeXAtom" transform="translate(1056, -285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D458"/></g><g data-mml-node="mo" transform="translate(521, 0)"><use xlink:href="#MJX-2-TEX-N-3D"/></g><g data-mml-node="mn" transform="translate(1299, 0)"><use xlink:href="#MJX-2-TEX-N-30"/></g></g></g><g data-mml-node="mrow" transform="translate(2598.5, 0)"><g data-mml-node="mo"><use xlink:href="#MJX-2-TEX-LO-230A"/></g><g data-mml-node="mfrac" transform="translate(528, 0)"><g data-mml-node="mi" transform="translate(420.3, 394) scale(0.707)"><use xlink:href="#MJX-2-TEX-I-1D44B"/></g><g data-mml-node="msup" transform="translate(220, -464.9) scale(0.707)"><g data-mml-node="mn"><use xlink:href="#MJX-2-TEX-N-31"/><use xlink:href="#MJX-2-TEX-N-30" transform="translate(500, 0)"/></g><g data-mml-node="TeXAtom" transform="translate(1000, 393.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D458"/></g></g></g><rect width="1203" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1971, 0)"><use xlink:href="#MJX-2-TEX-LO-230B"/></g></g></g></g></g></g></svg></p><p>的值。</p><h3 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行输入一个整数<em>X</em>(1≤<em>X</em>≤10^100000).</p><h3 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出答案。</p><h3 id="输入样例1-2"><a href="#输入样例1-2" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1225</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1-2"><a href="#输出样例1-2" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1360</span></span><br></pre></td></tr></table></figure><p>解释：1360 = 1225 + 122 + 12 + 1 + 0 + 0 + … + 0</p><h3 id="输入样例2-2"><a href="#输入样例2-2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">99999</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2-2"><a href="#输出样例2-2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">111105</span></span><br></pre></td></tr></table></figure><h3 id="输入样例3"><a href="#输入样例3" class="headerlink" title="输入样例3:"></a>输入样例3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">314159265358979323846264338327950288419716939937510</span></span><br></pre></td></tr></table></figure><h3 id="输出样例3"><a href="#输出样例3" class="headerlink" title="输出样例3:"></a>输出样例3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">349065850398865915384738153697722542688574377708317</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*写这道题是真艰辛，原本开始位数，以为是高精度运算，结果一顿超时，后面优化着优化着，慢慢接近前缀和的形式，然后写出了前缀和，AC了，但是大佬的算法实在是太简洁了*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,cr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算所有位数的总和，即前缀和的最后一位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> &amp;c : s)</span><br><span class="line">        sum += c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">/*然后开始进行计算，余数单独存储，sum值不断减本位的值进行更新，用一个变量代替了一个n个大小的前缀和数组，实在是高*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        s[i] = (sum + cr) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        cr = (sum + cr) / <span class="number">10</span>;</span><br><span class="line">        sum -= t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后判断是不是要进位</span></span><br><span class="line">    cout &lt;&lt; (cr ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;&quot;</span>) &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;7-1-加法求值-10-分&quot;&gt;&lt;a href=&quot;#7-1-加法求值-10-分&quot; class=&quot;headerlink&quot; title=&quot;7-1 加法求值 (10 分)&quot;&gt;&lt;/a&gt;&lt;strong&gt;7-1 加法求值 (10</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>P1480 A/B Problem</title>
    <link href="http://wangxu1905.github.io/2022/01/08/P1480%20A%C3%B7B%20Problem/"/>
    <id>http://wangxu1905.github.io/2022/01/08/P1480%20A%C3%B7B%20Problem/</id>
    <published>2022-01-08T09:54:07.605Z</published>
    <updated>2022-01-08T10:11:38.325Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数 a,b，输出它们的商。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>两行，第一行是被除数，第二行是除数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，商的整数部分。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>0≤a≤10^5000，1≤b≤10^9。</p><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想：</strong></h2><p>​    看题干就是高精度。</p><p>​    高精度乘法需要考虑的问题：</p><ul><li>经典倒序存储，但是这次是从高位向低位进行除法计算，存储余数</li><li>余数加到下一位时需要先乘10再进行运算</li><li>最后处理前导0，和减法一样，最后至少要留下一位，比如0 / 2 = 0</li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp;a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> &amp;r)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">res</span><span class="params">(a.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() <span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        res[i] = (a[i] + r * <span class="number">10</span>) / b;</span><br><span class="line">        r= (a[i] + r * <span class="number">10</span>) % b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(res.<span class="built_in">back</span>() == <span class="number">0</span> &amp;&amp; res.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">toVector</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">res</span><span class="params">(s.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        res[pos++] =  s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string str1;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b,r;</span><br><span class="line">    cin &gt;&gt; str1 &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; a = <span class="built_in">toVector</span>(str1);</span><br><span class="line">    vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; c = <span class="built_in">div</span>(a,b,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        cout &lt;&lt; c[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种高精度除低精度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r 存储余数</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">( vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r )</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- ) &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>( r / b );</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// C存储由高位到低位</span></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> ( C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span> ) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;输入两个整数 a,b，输出它们的商。&lt;/p&gt;
&lt;h2 id=&quot;输入格式&quot;&gt;</summary>
      
    
    
    
    
    <category term="高精度" scheme="http://wangxu1905.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>P1303 A*B Problem</title>
    <link href="http://wangxu1905.github.io/2022/01/08/P1303%20A%C3%97B%20Problem/"/>
    <id>http://wangxu1905.github.io/2022/01/08/P1303%20A%C3%97B%20Problem/</id>
    <published>2022-01-08T09:43:39.136Z</published>
    <updated>2022-01-08T09:53:14.502Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求两数的积。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>两行，两个整数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数表示乘积。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>每个数字不超过 10^2000 ，需用高精。</p><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想：</strong></h2><p>​    看题干就是高精度。</p><p>​    高精度乘法需要考虑的问题：</p><ul><li>经典倒序存储，从低位向高位进行乘法计算，更新进位</li><li>考虑到空间复杂度，我们可以一边乘一边加，不需要算完所有的中间项，最后一起相加</li><li>进位溢出问题，a*b的最大位数为a的位数+b的位数，比如99* 99= 9801，我们可以先往多了开，最后一起处理前导0</li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a,vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(a.size() + b.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">            res[i + j] += a[i] * b[j];</span><br><span class="line">            res[i + j + <span class="number">1</span>] += res[i + j] / <span class="number">10</span>;</span><br><span class="line">            res[i + j] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(res.<span class="built_in">back</span>() == <span class="number">0</span> &amp;&amp; res.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">toVector</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(s.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        res[pos++] =  s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string str1,str2;</span><br><span class="line">    cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a = <span class="built_in">toVector</span>(str1);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; b = <span class="built_in">toVector</span>(str2);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c = <span class="built_in">mul</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        cout &lt;&lt; c[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是高精度乘高精度，下面这个是高精度*低精度（不过可以同样用上面的模板算）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">( vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b )</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i =<span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>( t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span> ) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;求两数的积。&lt;/p&gt;
&lt;h2 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入</summary>
      
    
    
    
    
    <category term="高精度" scheme="http://wangxu1905.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>P2142 高精度减法</title>
    <link href="http://wangxu1905.github.io/2022/01/08/P2142%20%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/"/>
    <id>http://wangxu1905.github.io/2022/01/08/P2142%20%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95/</id>
    <published>2022-01-08T08:13:04.269Z</published>
    <updated>2022-01-08T08:27:33.818Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>高精度减法。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>两个整数 a,b（第二个可能比第一个大）。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>结果（是负数要输出负号）。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><ul><li>20% 数据 a,b 在 long long 范围内；</li><li>100% 数据0&lt;a,b≤10^10086。</li></ul><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想：</strong></h2><p>​    看题干就是高精度。</p><p>​    高精度减法需要考虑的问题：</p><ul><li>结果为负数，我们无法用数组存储负号，我们指定a大于等于b，我们先判断a,b的大小，a小于b，那么a和b交换，一旦交换就输出一个负号<ul><li>位数不同时，谁的位数大谁大</li><li>位数相同时，从高位向低位比较，直到遇见不同位</li><li>如果完全相同，则a和b相等</li></ul></li><li>和加法一样，我们采取倒序存储，从低位向高位进行减法计算，更新借位</li><li>处理前导0，但这里需要注意，如果a和b相等，相减的结果数组全为0,但我们需要留下一位，所以删除的时候还需要判断c.size() &gt; 1</li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a,vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>())    <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span>(a[i] != b[i])    <span class="keyword">return</span> a[i] &gt; b[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a,vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">cmp</span>(a,b))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(a.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    b.<span class="built_in">resize</span>(a.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        c[i] += a[i] - b[i];</span><br><span class="line">        <span class="keyword">if</span>(c[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            c[i] += <span class="number">10</span>;</span><br><span class="line">            c[i + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">back</span>() == <span class="number">0</span> &amp;&amp; c.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">        c.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">toVector</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(s.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        res[pos++] =  s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string str1,str2;</span><br><span class="line">    cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a = <span class="built_in">toVector</span>(str1);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; b = <span class="built_in">toVector</span>(str2);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c = <span class="built_in">sub</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        cout &lt;&lt; c[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sub的另一种写法（当然有很多中写法）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">( vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B )</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="comment">//  t表示借位，为0或1</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++ ) &#123;</span><br><span class="line">        t  = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> ( i &lt; B.<span class="built_in">size</span>() ) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>( (t+<span class="number">10</span>) % <span class="number">10</span> )</span><br><span class="line">        <span class="keyword">if</span>( t &lt; <span class="number">0</span> ) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉前导0</span></span><br><span class="line">    <span class="keyword">while</span> ( C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span> ) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;高精度减法。&lt;/p&gt;
&lt;h2 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入</summary>
      
    
    
    
    
    <category term="高精度" scheme="http://wangxu1905.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>出错记录</title>
    <link href="http://wangxu1905.github.io/2022/01/07/%E5%87%BA%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    <id>http://wangxu1905.github.io/2022/01/07/%E5%87%BA%E9%94%99%E8%AE%B0%E5%BD%95/</id>
    <published>2022-01-07T13:32:57.554Z</published>
    <updated>2022-01-07T14:08:12.253Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="1-建立堆"><a href="#1-建立堆" class="headerlink" title="1.建立堆"></a>1.建立堆</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++heapsize] = x;  <span class="comment">//先++，再赋值，所以是前缀++</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = heapsize; heap[i] &lt; heap[i / <span class="number">2</span>]; i /= <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">swap</span>(heap[i], heap[i / <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对于堆来说，和二叉排序树不一样，必须查找两个赋值，与其递归求解，还不入</span></span><br><span class="line"><span class="comment">顺序查找，哎，当时直接想到了递归，回头想想，还是顺序查找好*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= heapsize; ++i)</span><br><span class="line">        <span class="keyword">if</span>(heap[i] == x)    <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h4 id=&quot;1-建立堆&quot;&gt;&lt;a href=&quot;#1-建立堆&quot; class=&quot;headerlink&quot; title=&quot;1.建立堆&quot;&gt;&lt;/a&gt;1.建立堆&lt;/h4&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table</summary>
      
    
    
    
    
    <category term="随便写点" scheme="http://wangxu1905.github.io/tags/%E9%9A%8F%E4%BE%BF%E5%86%99%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>C++ 其他类型转字符串</title>
    <link href="http://wangxu1905.github.io/2022/01/07/C++%20%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://wangxu1905.github.io/2022/01/07/C++%20%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-01-07T13:09:06.098Z</published>
    <updated>2022-01-07T13:28:13.387Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><pre><code>#### 1.to_string()</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1234</span>;</span><br><span class="line">string b = <span class="built_in">to_string</span>(a);</span><br></pre></td></tr></table></figure><h4 id="2-字符流stringstream"><a href="#2-字符流stringstream" class="headerlink" title="2.字符流stringstream"></a>2.字符流stringstream</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1234</span>;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss &lt;&lt; a;</span><br><span class="line">string b = ss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure><p>如果转多个加上str(“”)；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>,c = <span class="number">456</span>;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss &lt;&lt; a;</span><br><span class="line">string b = ss.<span class="built_in">str</span>();</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">ss.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">ss &lt;&lt; c;</span><br><span class="line">cout &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;pre&gt;&lt;code&gt;#### 1.to_string()
&lt;/code&gt;&lt;/pre&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    
    <category term="C++函数" scheme="http://wangxu1905.github.io/tags/C-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>P1601 A+B Problem（高精）</title>
    <link href="http://wangxu1905.github.io/2022/01/07/P1601%20A+B%20Problem%EF%BC%88%E9%AB%98%E7%B2%BE%EF%BC%89/"/>
    <id>http://wangxu1905.github.io/2022/01/07/P1601%20A+B%20Problem%EF%BC%88%E9%AB%98%E7%B2%BE%EF%BC%89/</id>
    <published>2022-01-07T12:13:22.094Z</published>
    <updated>2022-01-08T10:12:11.585Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>高精度加法，相当于a+b problem，<strong>不用考虑负数</strong>.</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>分两行输入。a,b≤10^500</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出只有一行，代表a+b的值</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输入 #2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1001</span></span><br><span class="line"><span class="number">9099</span></span><br></pre></td></tr></table></figure><p><strong>输出 #2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10100</span></span><br></pre></td></tr></table></figure><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想：</strong></h2><p>​    如果数据范围是10^500次方，显然即使是long long也得爆，所以有两种方法存储，一种是数组，一种是字符串，然后通过遍历模拟运算。</p><p>​    然后考虑计算会出现的问题</p><ul><li>首先，如果a和b位数不同时，根据竖式，低位要和低位对齐，但不管是字符串还是数组都是从高位开始依次读取，遍历的话，如果使用同一个指针进行遍历会出现以下情况</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"> + <span class="number">1</span> <span class="number">2</span></span><br><span class="line"> _________</span><br><span class="line"> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>显然这是不对的，所以按常规思路的话，使用两个指针分别遍历a和b，但显然挺复杂。</p><ul><li><p>其次是进位问题，第i位的值 = (a的第i位的值 + b的第i位的值 + 第i- 1进位) %10,第i位的进位 = (a的第i位的值 + b的第i位的值 + 第i- 1进位) /10</p></li><li><p>最后是最高位的进位，显然如果最高位需要进位的话，我们需要动态增加空间来存储最高位的进位</p><p>综合前面几点，我们可以采取倒序存储，即从低位到高位存储，然后如果位数不同可以向后补0，同时如果最高位进位，也比较好补位。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"> + <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> _________</span><br><span class="line"> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​    最后再讨论是用数组存还是字符串存，显然用数组存进行数值运算的话要比字符串要快，所以采用数组存。</p><p>总体要做的操作：</p><ul><li>首先读取两个字符串，然后把两个字符串倒序存入两个数组中，数组需要初始化为0（提前补0）</li><li>然后进行模拟运算，res可以开到a和b的最大位数，但可以把res的数组多开一位（计算方便），可以把进位直接赋值给下一位，然后计算下一位时，可以直接在已经计算进位的基础上加上a和b对应位置的值</li><li>最后，判断res的最后一位是否为0，为0的话删除，不为0的话，说明最高位有进位，不需要删除</li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a,vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(a.size() + <span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        res[i] += a[i] + b[i];</span><br><span class="line">        res[i + <span class="number">1</span>] = res[i] / <span class="number">10</span>;</span><br><span class="line">        res[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!res[res.<span class="built_in">size</span>() - <span class="number">1</span>])    res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string str1,str2;</span><br><span class="line">    cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">    <span class="keyword">int</span> maxsize = <span class="built_in">max</span>(str1.<span class="built_in">size</span>(),str2.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(maxsize,<span class="number">0</span>)</span>,<span class="title">b</span><span class="params">(maxsize,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = str1.<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        a[pos++] = str1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = str2.<span class="built_in">size</span>() - <span class="number">1</span>,pos = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        b[pos++] = str2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res = <span class="built_in">add</span>(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        cout &lt;&lt; res[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;高精度加法，相当于a+b problem，&lt;strong&gt;不用考虑负数&lt;/</summary>
      
    
    
    
    
    <category term="高精度" scheme="http://wangxu1905.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>P2574 XOR的艺术</title>
    <link href="http://wangxu1905.github.io/2022/01/06/P2574%20XOR%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <id>http://wangxu1905.github.io/2022/01/06/P2574%20XOR%E7%9A%84%E8%89%BA%E6%9C%AF/</id>
    <published>2022-01-06T12:26:18.098Z</published>
    <updated>2022-01-08T10:13:43.782Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中，他发现，这个游戏的伤害计算有一个规律，规律如下</p><ol><li>拥有一个伤害串，是一个长度为 n 的只含字符 <code>0</code> 和字符 <code>1</code> 的字符串。规定这个字符串的首字符是第一个字符，即下标从 11 开始。</li><li>给定一个范围[l, r]，伤害为伤害串的这个范围内中字符 <code>1</code> 的个数</li><li>会修改伤害串中的数值，修改的方法是把 [l, r] 中所有原来的字符 <code>0</code> 变成 <code>1</code>，将 <code>1</code> 变成 <code>0</code>。</li></ol><p>AKN 想知道一些时刻的伤害，请你帮助他求出这个伤害。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行有两个用空格隔开的整数，分别表示伤害串的长度 n，和操作的个数 m。</p><p>输入第二行是一个长度为 n的字符串 S，代表伤害串。</p><p>第 3 到第 (m + 2) 行，每行有三个用空格隔开的整数 op,l,r。代表第 i 次操作的方式和区间，规则是：</p><ul><li>若 op = 0，则表示将伤害串的 [l, r] 区间内的 <code>0</code> 变成 <code>1</code>，<code>1</code> 变成 <code>0</code>。</li><li>若 op = 1，则表示询问伤害串的 [l, r] 区间内有多少个字符 <code>1</code>。</li></ul><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每次询问，输出一行一个整数，代表区间内 <code>1</code> 的个数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">6</span></span><br><span class="line"><span class="number">1011101001</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><h4 id="样例输入输出-1-解释"><a href="#样例输入输出-1-解释" class="headerlink" title="样例输入输出 1 解释"></a>样例输入输出 1 解释</h4><p>原伤害串为 <code>1011101001</code>。</p><p>对于第一次操作，改变 [2, 4] 的字符，伤害串变为 <code>1100101001</code>。</p><p>对于第二次操作，查询 [1, 5] 内 <code>1</code> 的个数，共有 3 个。</p><p>对于第三次操作，改变 [3, 7] 的字符，伤害串变为 <code>1111010001</code>。</p><p>对于第四次操作，查询 [1, 10] 内 <code>1</code> 的个数，共有 6 个。</p><p>对于第五次操作，改变 [1, 4] 的字符，伤害串变为 <code>0000010001</code>。</p><p>对于第六次操作，查询 [2, 6] 内 <code>1</code> 的个数，共有 1 个。</p><h4 id="数据范围与约定"><a href="#数据范围与约定" class="headerlink" title="数据范围与约定"></a>数据范围与约定</h4><p>对于 10% 的数据，保证 n,m≤10。</p><p>另有 30% 的数据，保证 n,m≤2×10^3。</p><p>对于 100% 的数据，保证 2≤n,m≤2×10^5，0≤op≤1，1≤l≤r≤n，S 中只含字符 <code>0</code> 和字符 <code>1</code>。</p><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想：</strong></h2><p>​    采用线段树，然后因为字符串只有0和1，所以一个子串中有多少个1，直接这个子串的0和1相加的总和就是1的个数，所以线段树维护的是区间和。</p><p>​    当op = 0时，0和1相互变化，所以新的区间和变为区间长度-原区间和，可以用懒标记下传。经过两次0和1的相互变化相当于没有变化。所以lazytag对1异或即可，因为0和1异或是1,1和1异或是0，可以通过位运算进行懒标记0和1的变化。</p><p>​    还有用了ios::sync_with_stdio(false);之后确实快，原本900+ms,缩短到了600+ms。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> pre,lazytag;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn + <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        t[p].pre = s[l] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        t[p].lazytag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> ,l ,mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">    t[p].pre = t[p &lt;&lt; <span class="number">1</span>].pre + t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].lazytag)&#123;</span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span>].pre = (t[p &lt;&lt; <span class="number">1</span>].r - t[p &lt;&lt; <span class="number">1</span>].l + <span class="number">1</span>) - t[p &lt;&lt; <span class="number">1</span>].pre;</span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].pre = (t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].r - t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l + <span class="number">1</span>) - t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].pre;</span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span>].lazytag ^= <span class="number">1</span>;</span><br><span class="line">        t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazytag ^= <span class="number">1</span>;</span><br><span class="line">        t[p].lazytag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre = (t[p].r - t[p].l + <span class="number">1</span>) - t[p].pre;</span><br><span class="line">        t[p].lazytag ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change</span>(p &lt;&lt; <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)      <span class="built_in">change</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,x,y);</span><br><span class="line">    t[p].pre = t[p &lt;&lt; <span class="number">1</span>].pre + t[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)  <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    ans += <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)      ans += <span class="built_in">ask</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag,x,y;</span><br><span class="line">        cin &gt;&gt; flag &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(!flag)    <span class="built_in">change</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        <span class="keyword">else</span>        cout &lt;&lt; <span class="built_in">ask</span>(<span class="number">1</span>,x,y) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中</summary>
      
    
    
    
    
    <category term="线段树" scheme="http://wangxu1905.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>提高程序效率的位运算</title>
    <link href="http://wangxu1905.github.io/2022/01/05/%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E6%95%88%E7%8E%87%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://wangxu1905.github.io/2022/01/05/%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E6%95%88%E7%8E%87%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2022-01-05T13:02:43.822Z</published>
    <updated>2022-01-05T13:08:55.311Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><ul><li>如果树的父亲结点为n,则左孩子结点为n &lt;&lt; 1,右孩子为 n &lt;&lt; 1 | 1;</li><li>二分查找mid = (left + right) &gt;&gt; 1;</li><li>还有自己写scanf函数读取整数值来提高运行效率（tql）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll x=<span class="number">0</span>;<span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;ul&gt;
&lt;li&gt;如果树的父亲结点为n,则左孩子结点为n &amp;lt;&amp;lt; 1,右孩子为 n &amp;lt;&amp;lt; 1 | 1;&lt;/li&gt;
&lt;li&gt;二分查找mid = (left + right) &amp;gt;&amp;gt; 1;&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="位运算" scheme="http://wangxu1905.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>P3373 【模板】线段树 2</title>
    <link href="http://wangxu1905.github.io/2022/01/05/P3373%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%202/"/>
    <id>http://wangxu1905.github.io/2022/01/05/P3373%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%202/</id>
    <published>2022-01-05T12:45:25.154Z</published>
    <updated>2022-01-08T10:14:27.518Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面三种操作：</p><ul><li>将某区间每一个数乘上 x</li><li>将某区间每一个数加上 x</li><li>求出某区间每一个数的和</li></ul><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含三个整数 n,m,p，分别表示该数列数字的个数、操作的总个数和模数。</p><p>第二行包含 n个用空格分隔的整数，其中第 i个数字表示数列第 i项的初始值。</p><p>接下来 m 行每行包含若干个整数，表示一个操作，具体如下：</p><p>操作 1： 格式：<code>1 x y k</code> 含义：将区间 [x,y][<em>x</em>,<em>y</em>] 内每个数乘上 k</p><p>操作 2： 格式：<code>2 x y k</code> 含义：将区间 [x,y][<em>x</em>,<em>y</em>] 内每个数加上 k</p><p>操作 3： 格式：<code>3 x y</code> 含义：输出区间 [x,y][<em>x</em>,<em>y</em>] 内每个数的和对 p 取模所得的结果</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 3 的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">38</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>【数据范围】</p><p>对于 30% 的数据：n≤8，m≤10<br>对于 70% 的数据：n≤10^3，m≤10^4<br>对于 100% 的数据：n≤10^5，m≤10^5</p><p>除样例外，p = 571373</p><p>（数据已经过加强^_^）</p><p>样例说明：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/2255.png" alt="img"></p><p>故输出应为 17、2（40 mod 38=2 ）</p><h2 id="锹黑板："><a href="#锹黑板：" class="headerlink" title="锹黑板："></a><strong>锹黑板：</strong></h2><p>首先我们回忆一下线段树１的加法标记<strong>他其实是打在父亲节点上的标记儿子加多少的</strong>，打完标记的同时父亲的sum其实已经加上了add * len</p><p>那我们回到这道题我们发现题目要求在加数的同时<strong>还要区间乘</strong></p><p>比如现在有3个数1,2,3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">1</span>~<span class="number">3</span>(<span class="number">1</span>)</span><br><span class="line">         /     \</span><br><span class="line">    <span class="number">1</span>~<span class="number">2</span>(<span class="number">2</span>)      <span class="number">3</span>(<span class="number">3</span>)</span><br><span class="line">   /      \</span><br><span class="line"><span class="number">1</span>(<span class="number">4</span>)      <span class="number">2</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>我们先给1~3加上2</strong>,画个小小小小的图，<strong>节点后面的括号代表节点下标</strong></p><p>所以</p><p>t[1].add += 2;</p><p>t[1].sum+=( (3 - 1) + 1) * 2;</p><p><strong>我们再给1~3乘上3</strong></p><p>所以</p><p>t[1].mu *= 3;</p><p><strong>我们再给1~3加上4，那是不是先加再乘</strong></p><p>t[1].add += 4;</p><p>obviously我们发现不能先加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">操作<span class="number">2</span>之后的式子是:</span><br><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>)*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>)*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>)*<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>如果直接加:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">式子是:</span><br><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>+<span class="number">4</span>)*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>+<span class="number">4</span>)*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>+<span class="number">4</span>)*<span class="number">3</span>;</span><br><span class="line">   =(a[<span class="number">1</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>*<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>我们发现这和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>+(a[<span class="number">2</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>+(a[<span class="number">3</span>]+<span class="number">2</span>)*<span class="number">3</span>+<span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>并不等价</p><p>而要等价必须这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=(a[<span class="number">1</span>]+<span class="number">2</span>+<span class="number">4</span>/<span class="number">3</span>)*<span class="number">3</span>+(a[<span class="number">2</span>]+<span class="number">2</span>+<span class="number">4</span>/<span class="number">3</span>)*<span class="number">3</span>+(a[<span class="number">3</span>]+<span class="number">2</span>+<span class="number">4</span>/<span class="number">3</span>)*<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><strong>我们发现这样就成了实数运算了,还有可能除成无限小数</strong></p><p>而先乘后加:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum=(a[<span class="number">1</span>]*<span class="number">3</span>+<span class="number">2</span>*<span class="number">3</span>+<span class="number">4</span>)+(a[<span class="number">2</span>]*<span class="number">3</span>+<span class="number">2</span>*<span class="number">3</span>+<span class="number">4</span>)+(a[<span class="number">3</span>]*<span class="number">3</span>+<span class="number">2</span>*<span class="number">3</span>+<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"><span class="keyword">int</span> a[maxn + <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre,add,mul;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn + <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;t[p].r = r;</span><br><span class="line">    t[p].add = <span class="number">0</span>;t[p].mul = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        t[p].pre = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> , l , mid);</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">    t[p].pre = (t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 根据先乘后加的优先度，儿子的值 = 此刻儿子的值*爸爸乘法的lazytag +儿子的区间长度*爸爸加法的lazytag */</span></span><br><span class="line">    t[p * <span class="number">2</span>].pre = (t[p * <span class="number">2</span>].pre * t[p].mul + t[p].add * (t[p * <span class="number">2</span>].r - t[p * <span class="number">2</span>].l + <span class="number">1</span>)) % mod;</span><br><span class="line">    t[p * <span class="number">2</span> + <span class="number">1</span>].pre = (t[p * <span class="number">2</span> + <span class="number">1</span>].pre * t[p].mul + t[p].add * (t[p * <span class="number">2</span> + <span class="number">1</span>].r - t[p * <span class="number">2</span> + <span class="number">1</span>].l + <span class="number">1</span>)) % mod;</span><br><span class="line">    <span class="comment">//维护lazytag</span></span><br><span class="line">    t[p * <span class="number">2</span>].mul = (t[p * <span class="number">2</span>].mul * t[p].mul) % mod;</span><br><span class="line">    t[p * <span class="number">2</span> + <span class="number">1</span>].mul = (t[p * <span class="number">2</span> + <span class="number">1</span>].mul * t[p].mul) % mod;</span><br><span class="line">    t[p * <span class="number">2</span>].add = (t[p * <span class="number">2</span>].add * t[p].mul + t[p].add) % mod;</span><br><span class="line">    t[p * <span class="number">2</span> + <span class="number">1</span>].add = (t[p * <span class="number">2</span> + <span class="number">1</span>].add * t[p].mul + t[p].add) % mod;</span><br><span class="line">    <span class="comment">//父节点的lazytag初始哈</span></span><br><span class="line">    t[p].mul = <span class="number">1</span>;</span><br><span class="line">    t[p].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="comment">//被覆盖的话</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre = (t[p].pre * z) % mod;</span><br><span class="line">        t[p].mul = (t[p].mul * z) % mod;</span><br><span class="line">        t[p].add = (t[p].add * z) % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有被覆盖，则下传lazytag</span></span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change1</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change1</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    t[p].pre = (t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加法，和乘法同理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change2</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre = (t[p].pre + (<span class="keyword">long</span> <span class="keyword">long</span>)z * (t[p].r - t[p].l + <span class="number">1</span>)) % mod;</span><br><span class="line">        t[p].add = (t[p].add + z) % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change2</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change2</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    t[p].pre = (t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)  <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    ans += <span class="built_in">ask</span>(p * <span class="number">2</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       ans += <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> q,x,y,k;</span><br><span class="line">        cin &gt;&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            <span class="built_in">change1</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(q == <span class="number">2</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            <span class="built_in">change2</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">ask</span>(<span class="number">1</span>,x,y) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如题，已知一个数列，你需要进行下面三种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将</summary>
      
    
    
    
    
    <category term="线段树" scheme="http://wangxu1905.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>P3372 【模板】线段树 1</title>
    <link href="http://wangxu1905.github.io/2022/01/05/P3372%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%201/"/>
    <id>http://wangxu1905.github.io/2022/01/05/P3372%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%201/</id>
    <published>2022-01-05T11:55:30.887Z</published>
    <updated>2022-01-08T10:14:56.527Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li>将某区间每一个数加上 k。</li><li>求出某区间每一个数的和。</li></ol><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 n, m，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 n个用空格分隔的整数，其中第 i 个数字表示数列第 i项的初始值。</p><p>接下来 m 行每行包含 3或 4 个整数，表示一个操作，具体如下：</p><ol><li><code>1 x y k</code>：将区间 [x, y][<em>x</em>,<em>y</em>] 内每个数加上 k。</li><li><code>2 x y</code>：输出区间 [x, y][<em>x</em>,<em>y</em>] 内每个数的和。</li></ol><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 2 的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>对于 30% 的数据：n≤8，m≤10。<br>对于 70% 的数据：n≤10^3，m≤10^4。<br>对于 100% 的数据：1≤n,m≤10^5。</p><p>保证任意时刻数列中任意元素的和在 [−2^63,2^63) 内。</p><p><strong>【样例解释】</strong></p><p><img src="https://cdn.luogu.com.cn/upload/pic/2251.png" alt="img"></p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>​    看题干就知道线段树，线段树可以维护区间加，区间查找等操作，其余还有区间乘，区间最大值，甚至最大子段和等操作。</p><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h4 id="1-线段树的存储"><a href="#1-线段树的存储" class="headerlink" title="1.线段树的存储"></a>1.线段树的存储</h4><p>采用结构体存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn + <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre,add;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn + <span class="number">2</span>];</span><br></pre></td></tr></table></figure><h4 id="2-建树"><a href="#2-建树" class="headerlink" title="2.建树"></a>2.建树</h4><p>所谓建树，就是把数组a[1 - n]放到线段树中</p><p>在线段树中，对于一个区间(编号为p),它的左儿子为2 * p,右儿子为2 * p + 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;t[p].r = r; <span class="comment">//存储该节点维护的区间范围</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;<span class="comment">//如果区间只有一个数，则直接赋值</span></span><br><span class="line">        t[p].pre = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则维护的值等于左儿子加右儿子</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> , l , mid);</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-懒标记"><a href="#3-懒标记" class="headerlink" title="3.懒标记"></a>3.懒标记</h4><p>​    懒标记的精髓就是打标计和下传操作，由于要做的操作是区间加一个数，所以不妨在区间进行修改时为该区间打上一个标记，就不必再修改它的儿子所维护的区间，等到要是用该节结点儿子维护的值，再将懒标记下放即可，可以省下很多时间，对于每次区间修改和查询，将懒标记下传，可以节省很多时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add)&#123; <span class="comment">//如果懒标记不为0，就将其下传，修改左右儿子维护的值</span></span><br><span class="line">        t[p * <span class="number">2</span>].pre += t[p].add * (t[p * <span class="number">2</span>].r - t[p * <span class="number">2</span>].l + <span class="number">1</span>);</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].pre += t[p].add * (t[p * <span class="number">2</span> + <span class="number">1</span>].r - t[p * <span class="number">2</span> + <span class="number">1</span>].l + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//为该结点的左右儿子打上标记</span></span><br><span class="line">        t[p * <span class="number">2</span>].add += t[p].add;</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].add += t[p].add;</span><br><span class="line">        <span class="comment">//下传之后将该结点的懒标记清0</span></span><br><span class="line">        t[p].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-区间修改"><a href="#4-区间修改" class="headerlink" title="4.区间修改"></a>4.区间修改</h4><p>​    考虑到将一个区间加上一个数，我们可以从根结点不断向下查找，当发现我们要修改的区间覆盖了当前结点时，我们就把这个区间修改，并打上懒标记（由于懒标记的存在，我们就不必再修改它的儿子结点），否则下传懒标记，继续向下找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123; <span class="comment">//被覆盖的话，就对其进行修改</span></span><br><span class="line">        t[p].pre += (<span class="keyword">long</span> <span class="keyword">long</span>)z * (t[p].r - t[p].l + <span class="number">1</span>);</span><br><span class="line">        t[p].add += z;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*如果发现没有被覆盖，那么继续向下找，考虑儿子所维护的区间可能因为懒标记的存在而没有修改，因此懒标记下放*/</span></span><br><span class="line">    <span class="built_in">spread</span>(p); </span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果要修改的区间覆盖了左儿子，就修改左儿子，右儿子同理</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    <span class="comment">//最终维护的值等于左儿子值加右儿子值</span></span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-区间查询"><a href="#5-区间查询" class="headerlink" title="5.区间查询"></a>5.区间查询</h4><p>​    考虑询问一个区间的和，依旧是从根结点向下查找，当发现结点被覆盖时，就返回维护的值，否则下传懒标记，查询左右儿子，累加答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果被覆盖，就返回维护的值</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)  <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    <span class="comment">//下传懒标记，并查询左右儿子</span></span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    ans += <span class="built_in">ask</span>(p * <span class="number">2</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       ans += <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn + <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre,add;</span><br><span class="line">&#125;t[<span class="number">4</span> * maxn + <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    t[p].l = l;t[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        t[p].pre = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> , l , mid);</span><br><span class="line">    <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add)&#123;</span><br><span class="line">        t[p * <span class="number">2</span>].pre += t[p].add * (t[p * <span class="number">2</span>].r - t[p * <span class="number">2</span>].l + <span class="number">1</span>);</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].pre += t[p].add * (t[p * <span class="number">2</span> + <span class="number">1</span>].r - t[p * <span class="number">2</span> + <span class="number">1</span>].l + <span class="number">1</span>);</span><br><span class="line">        t[p * <span class="number">2</span>].add += t[p].add;</span><br><span class="line">        t[p * <span class="number">2</span> + <span class="number">1</span>].add += t[p].add;</span><br><span class="line">        t[p].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123;</span><br><span class="line">        t[p].pre += (<span class="keyword">long</span> <span class="keyword">long</span>)z * (t[p].r - t[p].l + <span class="number">1</span>);</span><br><span class="line">        t[p].add += z;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    <span class="built_in">change</span>(p * <span class="number">2</span>,x,y,z);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       <span class="built_in">change</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y,z);</span><br><span class="line">    t[p].pre = t[p * <span class="number">2</span>].pre + t[p * <span class="number">2</span> + <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)  <span class="keyword">return</span> t[p].pre;</span><br><span class="line">    <span class="built_in">spread</span>(p);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (t[p].l + t[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)    ans += <span class="built_in">ask</span>(p * <span class="number">2</span>,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid)       ans += <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> q,x,y,z;</span><br><span class="line">        cin &gt;&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,x,y,z);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">ask</span>(<span class="number">1</span>,x,y) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如题，已知一个数列，你需要进行下面两种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将</summary>
      
    
    
    
    
    <category term="线段树" scheme="http://wangxu1905.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>42. 接雨水</title>
    <link href="http://wangxu1905.github.io/2022/01/05/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>http://wangxu1905.github.io/2022/01/05/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/</id>
    <published>2022-01-05T02:26:06.613Z</published>
    <updated>2022-01-08T10:15:36.261Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><blockquote><p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：height = [4,2,0,3,2,5]<br>输出：9</p></blockquote><p><strong>提示：</strong></p><ul><li>n == height.length</li><li>1 &lt;= n &lt;= 2 * 104</li><li>0 &lt;= height[i] &lt;= 105</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a><strong>方法一：动态规划</strong></h3><p>​    根据木桶原理，左右两个柱子，最后能存多少雨水，取决于最短的板子，所以可以从左到右遍历一遍，求得从左到该位置的最长的板子，从右到左遍历，求得从右到该位置的最长的板子。</p><p>​    计算完左右最长的板子后，然后再遍历一遍，该柱子能否存储雨水，取决于左右最长柱子中的最短柱子和该柱子的差。</p><p><img src="https://assets.leetcode-cn.com/solution-static/42/1.png"></p><h4 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>,<span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        left[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        right[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            left[i] = <span class="built_in">max</span>(left[i - <span class="number">1</span>],height[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            right[i] = <span class="built_in">max</span>(right[i + <span class="number">1</span>],height[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            ans += <span class="built_in">min</span>(left[i],right[i]) - height[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)，计算left，right和雨水量需要遍历三次</li><li>空间复杂度：O(n)，创建两个长度为n的数组存储left和right</li></ul><h3 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a><strong>方法二：单调栈</strong></h3><p>​    维护一个单调栈，单调栈存储的是下标，满足从栈底到栈顶的下标对应的数组 height 中的元素递减。</p><p>​    从左到右遍历数组，如果栈内至少有两个元素，记栈顶元素为 top，top 的下面一个元素是 left，则一定有 height[left] ≥ height[top]。如果 height[i]&gt;height[top]，则得到一个可以接雨水的区域，该区域的宽度是i−left−1，高度是 min(height[left],height[i])−height[top]，根据宽度和高度即可计算得到该区域能接的雨水量。</p><p>​    为了得到 left，需要将 top 出栈。在对top 计算能接的雨水量之后，left 变成新的 top，重复上述操作，直到栈变为空，或者栈顶下标对应的height 中的元素大于或等于height[i]。</p><h4 id="实现代码：-1"><a href="#实现代码：-1" class="headerlink" title="实现代码："></a>实现代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,n = height.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="keyword">int</span> top = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">int</span> curWidth = i - left - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> curHeight = <span class="built_in">min</span>(height[left],height[i]) - height[top];</span><br><span class="line">                ans += curHeight * curWidth;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：O(n)，其中 n 是数组height 的长度。从 0 到 n−1 的每个下标最多只会入栈和出栈各一次。</li><li>空间复杂度：O(n)，主要取决于栈空间</li></ul><h3 id="方法三：双指针"><a href="#方法三：双指针" class="headerlink" title="方法三：双指针"></a><strong>方法三：双指针</strong></h3><p>​    和动态规划一样，只不过用双指针代替求左右最长板子的两个数组。</p><p>​    维护两个指针left和right，以及两个变量leftMax和rightMax,在移动过程中更新leftMax和rightMax。</p><p>​    当两个指针没有相遇时，进行如下操作：</p><ul><li>使用height[left]和height[right]的值更新leftMax和rightMax</li><li>如果height[left] &lt; height[right]，则必有leftMax &lt; rightMax，下标left能接的雨水量等于leftMax - height[left]，然后left向右移动一位</li><li>如果height[left] &gt;= height[right]，则必有leftMax &gt;= rightMax，下标right能接的雨水量等于rightMax - height[right]，然后right向左移动一位</li></ul><p>当两个指针相遇时，即可得到能接的雨水总量。</p><h4 id="实现代码：-2"><a href="#实现代码：-2" class="headerlink" title="实现代码："></a>实现代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>,left = <span class="number">0</span>,right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>,rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            leftMax = <span class="built_in">max</span>(leftMax,height[left]);</span><br><span class="line">            rightMax = <span class="built_in">max</span>(rightMax,height[right]);</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                ans += leftMax - height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += rightMax - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p>时间复杂度：O(n)，其中 n 是数组height 的长度。两个指针的移动总次数不超过 n。</p></li><li><p>空间复杂度：O(1)，只需要使用常数的额外空间。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定 &lt;code&gt;n&lt;/code&gt; 个非负整数表示每个宽度为 &lt;code&gt;1&lt;/code&gt; 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="双指针" scheme="http://wangxu1905.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="动态规划" scheme="http://wangxu1905.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="单调栈" scheme="http://wangxu1905.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>P3368 【模板】树状数组 2</title>
    <link href="http://wangxu1905.github.io/2022/01/04/P3368%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%202/"/>
    <id>http://wangxu1905.github.io/2022/01/04/P3368%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%202/</id>
    <published>2022-01-04T09:56:28.308Z</published>
    <updated>2022-01-08T10:15:09.032Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li>将某区间每一个数数加上 x；</li><li>求出某一个数的值。</li></ol><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 N、M，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 N个用空格分隔的整数，其中第 i个数字表示数列第 i项的初始值。</p><p>接下来 M行每行包含 2 或 4个整数，表示一个操作，具体如下：</p><p>操作 1： 格式：<code>1 x y k</code> 含义：将区间 [x,y][<em>x</em>,<em>y</em>] 内每个数加上 k；</p><p>操作 2： 格式：<code>2 x</code> 含义：输出第 x个数的值。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 2的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><h4 id="样例-1-解释："><a href="#样例-1-解释：" class="headerlink" title="样例 1 解释："></a>样例 1 解释：</h4><p><img src="https://cdn.luogu.com.cn/upload/pic/2258.png" alt="img"></p><p>故输出结果为 6、10。</p><hr><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 30% 的数据：N≤8,M≤10;</p><p>对于 70% 的数据：N≤ 10000,M≤10000;</p><p>对于 100%的数据：1 ≤ N, M≤ 500000，1 ≤ x, y ≤n，保证任意时刻序列中任意元素的绝对值都不大于 2^30。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, m, tree[<span class="number">500100</span>], input[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k &amp; -k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">        tree[x] += k;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">        ans += tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; input[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y, z;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="built_in">add</span>(x, z);</span><br><span class="line">            <span class="built_in">add</span>(y + <span class="number">1</span>, -z);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; input[x] + <span class="built_in">search</span>(x) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如题，已知一个数列，你需要进行下面两种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将</summary>
      
    
    
    
    
    <category term="树状数组" scheme="http://wangxu1905.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>P3374 【模板】树状数组 1</title>
    <link href="http://wangxu1905.github.io/2022/01/04/P3374%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%201/"/>
    <id>http://wangxu1905.github.io/2022/01/04/P3374%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%201/</id>
    <published>2022-01-04T09:51:30.230Z</published>
    <updated>2022-01-08T10:15:25.631Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，已知一个数列，你需要进行下面两种操作：</p><ul><li>将某一个数加上 x</li><li>求出某区间每一个数的和</li></ul><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数 n,m，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 n个用空格分隔的整数，其中第 i 个数字表示数列第 i项的初始值。</p><p>接下来 m行每行包含 3个整数，表示一个操作，具体如下：</p><ul><li><code>1 x k</code> 含义：将第 x个数加上 k</li><li><code>2 x y</code> 含义：输出区间 [x,y][<em>x</em>,<em>y</em>] 内每个数的和</li></ul><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作 2的结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>【数据范围】</p><p>对于 30%30% 的数据，1 ≤ n ≤ 8，1≤ m ≤ 10；<br>对于 70%70% 的数据，1≤ n,m ≤ 10^4；<br>对于 100%100% 的数据，1≤ n,m ≤ 5×10^5。</p><p>样例说明：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/2256.png" alt="img"></p><p>故输出结果14、16</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,tree[<span class="number">2000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k &amp; -k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n)&#123;</span><br><span class="line">        tree[x] += k;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        ans += tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="built_in">add</span>(i,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">add</span>(b,c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">2</span>)</span><br><span class="line">            cout &lt;&lt; <span class="built_in">sum</span>(c) - <span class="built_in">sum</span>(b - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如题，已知一个数列，你需要进行下面两种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将某</summary>
      
    
    
    
    
    <category term="树状数组" scheme="http://wangxu1905.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>P2880 [USACO07JAN]Balanced Lineup G</title>
    <link href="http://wangxu1905.github.io/2022/01/04/P2880%20[USACO07JAN]Balanced%20Lineup%20G/"/>
    <id>http://wangxu1905.github.io/2022/01/04/P2880%20[USACO07JAN]Balanced%20Lineup%20G/</id>
    <published>2022-01-04T09:47:03.190Z</published>
    <updated>2022-01-08T10:15:48.994Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>For the daily milking, Farmer John’s N cows (1 ≤ N ≤ 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height.</p><p>Farmer John has made a list of Q (1 ≤ Q ≤ 180,000) potential groups of cows and their heights (1 ≤ height ≤ 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group.</p><p>每天,农夫 John 的 n(1\le n\le 5\times 10^4)<em>n</em>(1≤<em>n</em>≤5×104) 头牛总是按同一序列排队。</p><p>有一天, John 决定让一些牛们玩一场飞盘比赛。他准备找一群在队列中位置连续的牛来进行比赛。但是为了避免水平悬殊，牛的身高不应该相差太大。John 准备了 q(1\le q\le 1.8\times10^5)<em>q</em>(1≤<em>q</em>≤1.8×105) 个可能的牛的选择和所有牛的身高 h_i(1\le h_i\le 10^6,1\le i\le n)<em>h**i</em>(1≤<em>h**i</em>≤106,1≤<em>i</em>≤<em>n</em>)。他想知道每一组里面最高和最低的牛的身高差。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Line 1: Two space-separated integers, N and Q.</p><p>Lines 2..N+1: Line i+1 contains a single integer that is the height of cow i</p><p>Lines N+2..N+Q+1: Two integers A and B (1 ≤ A ≤ B ≤ N), representing the range of cows from A to B inclusive.</p><p>第一行两个数 n,q。</p><p>接下来 n行，每行一个数 h_i。</p><p>再接下来 q行，每行两个整数 a 和 b，表示询问第 a头牛到第 b头牛里的最高和最低的牛的身高差。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>Lines 1..Q: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range.</p><p>输出共 q行，对于每一组询问，输出每一组中最高和最低的牛的身高差。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>​    因为涉及到区间最值查询，可以用ST表实现（现在还没看懂），先贴上代码再说</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//lxy数组用于求最大值，hrb数组用于求最小值</span></span><br><span class="line"><span class="keyword">int</span> n,m,lxy[<span class="number">180010</span>][<span class="number">22</span>],hrb[<span class="number">180010</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ST</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="built_in">log2</span>(r - l + <span class="number">1</span>),x,y;</span><br><span class="line">    x = <span class="built_in">max</span>(lxy[l][s],lxy[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]);    <span class="comment">//区间最大</span></span><br><span class="line">    y = <span class="built_in">min</span>(hrb[l][s],hrb[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]);  <span class="comment">//区间最小</span></span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; lxy[i][<span class="number">0</span>];</span><br><span class="line">        hrb[i][<span class="number">0</span>] = lxy[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">21</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k + (<span class="number">1</span> &lt;&lt; i) &lt;= n + <span class="number">1</span>; ++k)&#123;</span><br><span class="line">            lxy[k][i] = <span class="built_in">max</span>(lxy[k][i - <span class="number">1</span>],lxy[k + (<span class="number">1</span> &lt;&lt;(i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">            hrb[k][i] = <span class="built_in">min</span>(hrb[k][i - <span class="number">1</span>],hrb[k + (<span class="number">1</span> &lt;&lt;(i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">ST</span>(l,r) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;For the daily milking, Farmer John’s N</summary>
      
    
    
    
    
    <category term="ST表" scheme="http://wangxu1905.github.io/tags/ST%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>7-9 重排链表 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/03/7-9%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/03/7-9%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%20(25%20%E5%88%86)/</id>
    <published>2022-01-03T13:26:35.327Z</published>
    <updated>2022-01-03T13:32:36.298Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定一个单链表 <em>L</em>1→<em>L</em>2→⋯→<em>L**n</em>−1→<em>L**n</em>，请编写程序将链表重新排列为 <em>L**n</em>→<em>L</em>1→<em>L**n</em>−1→<em>L</em>2→⋯。例如：给定<em>L</em>为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数<em>N</em> (≤105)。结点的地址是5位非负整数，NULL地址用−1表示。</p><p>接下来有<em>N</em>行，每行格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>其中<code>Address</code>是结点地址；<code>Data</code>是该结点保存的数据，为不超过105的正整数；<code>Next</code>是下一结点的地址。题目保证给出的链表上至少有两个结点。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00100</span> <span class="number">6</span></span><br><span class="line"><span class="number">00000</span> <span class="number">4</span> <span class="number">99999</span></span><br><span class="line"><span class="number">00100</span> <span class="number">1</span> <span class="number">12309</span></span><br><span class="line"><span class="number">68237</span> <span class="number">6</span> <span class="number">-1</span></span><br><span class="line"><span class="number">33218</span> <span class="number">3</span> <span class="number">00000</span></span><br><span class="line"><span class="number">99999</span> <span class="number">5</span> <span class="number">68237</span></span><br><span class="line"><span class="number">12309</span> <span class="number">2</span> <span class="number">33218</span>结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">68237</span> <span class="number">6</span> <span class="number">00100</span></span><br><span class="line"><span class="number">00100</span> <span class="number">1</span> <span class="number">99999</span></span><br><span class="line"><span class="number">99999</span> <span class="number">5</span> <span class="number">12309</span></span><br><span class="line"><span class="number">12309</span> <span class="number">2</span> <span class="number">00000</span></span><br><span class="line"><span class="number">00000</span> <span class="number">4</span> <span class="number">33218</span></span><br><span class="line"><span class="number">33218</span> <span class="number">3</span> <span class="number">-1</span>结尾无空行</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> node_data[<span class="number">100001</span>],node_next[<span class="number">100001</span>];</span><br><span class="line">    <span class="keyword">int</span> head,n;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    cin &gt;&gt; head &gt;&gt; n;</span><br><span class="line">    <span class="comment">//初始化静态链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        node_data[a] = b;</span><br><span class="line">        node_next[a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历一遍链表，将各个结点的地址进行记录</span></span><br><span class="line">    <span class="keyword">int</span> h = head;</span><br><span class="line">    <span class="keyword">while</span>(h != <span class="number">-1</span>)&#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(h);</span><br><span class="line">        h = node_next[h];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是一个坑，对应一个测试点，因为会出现有多个结点为next都为-1，即不在该链表上的结点，所以要重新算一下长度</span></span><br><span class="line">    <span class="keyword">int</span> num = v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">address</span><span class="params">(num)</span></span>;</span><br><span class="line">    <span class="comment">//按题目要求，对链表结点进行重新排序</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>,high = num - <span class="number">1</span>,k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        address[k++] = v[high--];</span><br><span class="line">        address[k++] = v[low++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low == high) address[k] = v[low];</span><br><span class="line">    <span class="comment">//输出即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> add = address[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>,add,node_data[add],address[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1\n&quot;</span>,address[num - <span class="number">1</span>],node_data[address[num - <span class="number">1</span>]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定一个单链表 &lt;em&gt;L&lt;/em&gt;1→&lt;em&gt;L&lt;/em&gt;2→⋯→&lt;em&gt;L**n&lt;/em&gt;−1→&lt;em&gt;L**n&lt;/em&gt;，请编写程序将链表重新排列为 &lt;em&gt;L**n&lt;/em&gt;→&lt;em&gt;L&lt;/em&gt;1→&lt;em&gt;L**n</summary>
      
    
    
    
    
    <category term="静态链表" scheme="http://wangxu1905.github.io/tags/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>7-6 最长对称子串 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/01/03/7-6%20%E6%9C%80%E9%95%BF%E5%AF%B9%E7%A7%B0%E5%AD%90%E4%B8%B2%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/01/03/7-6%20%E6%9C%80%E9%95%BF%E5%AF%B9%E7%A7%B0%E5%AD%90%E4%B8%B2%20(25%20%E5%88%86)/</id>
    <published>2022-01-03T12:28:33.225Z</published>
    <updated>2022-01-03T13:23:16.290Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定<code>Is PAT&amp;TAP symmetric?</code>，最长对称子串为<code>s PAT&amp;TAP s</code>，于是你应该输出11。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出长度不超过1000的非空字符串。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出最长对称子串的长度。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Is PAT&amp;TAP symmetric?</span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line">结尾无空行</span><br></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>​    采用中心扩散法，主要是Manacher 算法一看就很复杂，不想学，中心扩散法的基本原理就是以每个元素作为中心，向左右两边扩散，如果无法继续扩散，此时和最大长度比较。</p><p>​    而字符串元素的个数分为奇数和偶数</p><ul><li>奇数：由中间一个字符作为中心进行扩散，对称轴为中间这个字符</li><li>偶数：由中间两个字符作为中心进行扩散，对称轴夹在两个字符中间</li></ul><p>力扣相关题：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5.最长回文子串</a></p><p>力扣视频链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/">最长回文子串</a></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(low &gt;= <span class="number">0</span> &amp;&amp; high &lt; s.<span class="built_in">size</span>() &amp;&amp; s[low] == s[high])&#123;</span><br><span class="line">        low--;</span><br><span class="line">        high++;</span><br><span class="line">    &#125;</span><br><span class="line">    maxlen = <span class="built_in">max</span>(maxlen,high - low - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="built_in">Judge</span>(i,i);</span><br><span class="line">        <span class="built_in">Judge</span>(i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxlen &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定&lt;code&gt;Is PAT&amp;amp;TAP symmetric?&lt;/code&gt;，最长对称子串为&lt;code&gt;s PAT&amp;amp;TAP s&lt;/code&gt;，于是你应该输出</summary>
      
    
    
    
    
    <category term="字符串" scheme="http://wangxu1905.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
