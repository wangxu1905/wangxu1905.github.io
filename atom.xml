<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moon</title>
  
  
  <link href="http://wangxu1905.github.io/atom.xml" rel="self"/>
  
  <link href="http://wangxu1905.github.io/"/>
  <updated>2022-04-04T15:21:48.839Z</updated>
  <id>http://wangxu1905.github.io/</id>
  
  <author>
    <name>Moon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>7-2 括号序列--改 (50 分)</title>
    <link href="http://wangxu1905.github.io/2022/04/04/7-2%20%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97--%E6%94%B9%20(50%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/04/04/7-2%20%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97--%E6%94%B9%20(50%20%E5%88%86)/</id>
    <published>2022-04-04T15:19:06.899Z</published>
    <updated>2022-04-04T15:21:48.839Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><em>原题来自CSP-S 2021 本题略有改动</em></p><p>给定一个长度为<em>n</em>的括号序列，有些位置确定了，有些位置没有确定，未确定的位置用<code>?</code>表示，求合法括号序列有多少。</p><p>一个合法括号序列满足下列条件：</p><p>1.（）是合法的括号序列</p><p>2.若 <em>S</em> 是合法的括号序列，那么<em>SS</em>,(<em>S</em>)也是合法的括号序列</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行输入一个正整数<em>n</em>(1≤<em>n</em>≤2000)</p><p>第二行输入一个长度为<em>n</em>的字符串，表示括号序列。数据保证字符串只由<code>(</code>,<code>)</code>,<code>?</code>组成。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出一个非负整数表示答案对 109+7 取模的结果。</p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line">(??)</span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>给定字符串可能形成下面两种合法的括号序列<br><code>(())</code><br><code>()()</code></p><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">?????</span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="输入样例3"><a href="#输入样例3" class="headerlink" title="输入样例3:"></a>输入样例3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line">(????)</span><br></pre></td></tr></table></figure><h3 id="输出样例3"><a href="#输出样例3" class="headerlink" title="输出样例3:"></a>输出样例3:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>有以下五种情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">((()))</span><br><span class="line">(()())</span><br><span class="line">()()()</span><br><span class="line">(())()</span><br><span class="line">()(())</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    用<em>dp</em>i*,<em>j</em>表示前<em>i</em>个字符中还有*j个<code>(</code>需要匹配的答案的数量。</p><p>​    若<em>s</em>[<em>i</em>]可以为<code>(</code>,那么<em>dpi</em>,<em>j</em>+=<em>dpi</em>−1,<em>j</em>−1</p><p>​    若<em>s</em>[<em>i</em>]可以为<code>)</code>,那么<em>dpi</em>,<em>j</em>+=<em>dpi</em>−1,<em>j</em>+1</p><p>​    最终答案就是<em>dpn</em>,0</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">    ll dp[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;?&#x27;</span>) </span><br><span class="line">            <span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) % MOD;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span> || s[i] == <span class="string">&#x27;?&#x27;</span>) </span><br><span class="line">            <span class="keyword">for</span>(ll j = <span class="number">0</span>; j &lt;= n - <span class="number">1</span>; ++j)</span><br><span class="line">                dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][j + <span class="number">1</span>]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;em&gt;原题来自CSP-S 2021 本题略有改动&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;给定一个长度为&lt;em&gt;n&lt;/em&gt;的括号序列，有些位置确定了，有些位置没有确定，未确定的位置用&lt;code&gt;?&lt;/code&gt;表示，求合法括号序列有多少</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-1 地铁一日游 (30 分)</title>
    <link href="http://wangxu1905.github.io/2022/04/04/7-1%20%E5%9C%B0%E9%93%81%E4%B8%80%E6%97%A5%E6%B8%B8%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/04/04/7-1%20%E5%9C%B0%E9%93%81%E4%B8%80%E6%97%A5%E6%B8%B8%20(30%20%E5%88%86)/</id>
    <published>2022-04-04T15:05:30.915Z</published>
    <updated>2022-04-04T15:14:14.249Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>森森喜欢坐地铁。这个假期，他终于来到了传说中的地铁之城——魔都，打算好好过一把坐地铁的瘾！</p><p>魔都地铁的计价规则是：起步价 2 元，出发站与到达站的最短距离（即<strong>计费距离</strong>）每 K 公里增加 1 元车费。</p><p>例如取 <strong>K</strong> = 10，动安寺站离魔都绿桥站为 40 公里，则车费为 2 + 4 = 6 元。</p><p>为了获得最大的满足感，森森决定用以下的方式坐地铁：在某一站上车（不妨设为地铁站 <strong>A</strong>），则对于所有车费相同的到达站，森森只会在计费距离最远的站或线路末端站点出站，然后用森森美图 App 在站点外拍一张认证照，再按同样的方式前往下一个站点。</p><p>坐着坐着，森森突然好奇起来：在给定出发站的情况下（在出发时森森也会拍一张照），他的整个旅程中能够留下哪些站点的认证照？</p><p>地铁是铁路运输的一种形式，指在地下运行为主的城市轨道交通系统。一般来说，地铁由若干个站点组成，并有多条不同的线路双向行驶，可类比公交车，当两条或更多条线路经过同一个站点时，可进行<strong>换乘</strong>，更换自己所乘坐的线路。举例来说，魔都 1 号线和 2 号线都经过人民广场站，则乘坐 1 号线到达人民广场时就可以换乘到 2 号线前往 2 号线的各个站点。换乘不需出站（也拍不到认证照），因此森森乘坐地铁时换乘不受限制。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第一行是三个正整数 <strong>N</strong>、<strong>M</strong> 和 <strong>K</strong>，表示魔都地铁有 <strong>N</strong> 个车站 (1 ≤ <strong>N</strong> ≤ 200)，<strong>M</strong> 条线路 (1 ≤ <strong>M</strong> ≤ 1500)，最短距离每超过 <strong>K</strong> 公里 (1 ≤ <strong>K</strong> ≤ 106)，加 1 元车费。</p><p>接下来 <strong>M</strong> 行，每行由以下格式组成：</p><p>&lt;站点1&gt;&lt;空格&gt;&lt;距离&gt;&lt;空格&gt;&lt;站点2&gt;&lt;空格&gt;&lt;距离&gt;&lt;空格&gt;&lt;站点3&gt; … &lt;站点X-1&gt;&lt;空格&gt;&lt;距离&gt;&lt;空格&gt;&lt;站点X&gt;</p><p>其中站点是一个 1 到 <strong>N</strong> 的编号；两个站点编号之间的距离指两个站在该线路上的距离。两站之间距离是一个不大于 106 的正整数。一条线路上的站点互不相同。</p><p><strong>注意</strong>：两个站之间可能有多条直接连接的线路，且距离不一定相等。</p><p>再接下来有一个正整数 <strong>Q</strong> (1 ≤ <strong>Q</strong> ≤ 200)，表示森森尝试从 <strong>Q</strong> 个站点出发。</p><p>最后有 <strong>Q</strong> 行，每行一个正整数 <strong>Xi</strong>，表示森森尝试从编号为 <strong>Xi</strong> 的站点出发。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对于森森每个尝试的站点，输出一行若干个整数，表示能够到达的站点编号。站点编号从小到大排序。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">2</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    暴力枚举，也不算暴力，就是一个一个试，用过之后，vis[i] = 1</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, m, k, s, q, mar[<span class="number">205</span>][<span class="number">205</span>], dis[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; edge[<span class="number">205</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">205</span>], start[<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                mar[i][j] = <span class="built_in">min</span>(mar[i][k] + mar[k][j], mar[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    res.<span class="built_in">push_back</span>(s);</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge[s].<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[s][i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="built_in">memset</span>(mar, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mar));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) mar[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        <span class="comment">//记录起点</span></span><br><span class="line">        start[a] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            cin &gt;&gt; c &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span>(mar[a][b] &gt; c)   mar[a][b] = mar[b][a] = c;</span><br><span class="line">            a = b;</span><br><span class="line">        &#125; <span class="keyword">while</span>(<span class="built_in">getchar</span>() != <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="comment">//记录终点</span></span><br><span class="line">        start[a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Floyed</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; book;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="comment">//map记录相同花费的最长路径</span></span><br><span class="line">            <span class="keyword">if</span>(mar[i][j] &lt; INF &amp;&amp; book[mar[i][j] / k] &lt; mar[i][j])&#123;</span><br><span class="line">                book[mar[i][j] / k] = mar[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果距离和map存的距离相同或者是起点终点，则有边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mar[i][j] == book[mar[i][j] / k] || (i != j &amp;&amp; mar[i][j] &lt; INF &amp;&amp; start[j]))&#123;</span><br><span class="line">                edge[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="built_in">dfs</span>(s, res);</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j)   cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; res[j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;森森喜欢坐地铁。这个假期，他终于来到了传说中的地铁之城——魔都，打算好好过一把坐地铁的瘾！&lt;/p&gt;
&lt;p&gt;魔都地铁的计价规则是：起步价 2 元，出发站与到达站的最短距离（即&lt;strong&gt;计费距离&lt;/strong&gt;）每 K </summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-4 还原文件 (35 分)</title>
    <link href="http://wangxu1905.github.io/2022/04/04/7-4%20%E8%BF%98%E5%8E%9F%E6%96%87%E4%BB%B6%20(35%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/04/04/7-4%20%E8%BF%98%E5%8E%9F%E6%96%87%E4%BB%B6%20(35%20%E5%88%86)/</id>
    <published>2022-04-04T13:23:28.304Z</published>
    <updated>2022-04-04T15:11:43.557Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>一份重要文件被撕成两半，其中一半还被送进了碎纸机。我们将碎纸机里找到的纸条进行编号，如图 1 所示。然后根据断口的折线形状跟没有切碎的半张纸进行匹配，最后还原成图 2 的样子。要求你输出还原后纸条的正确拼接顺序。</p><p><img src="https://images.ptausercontent.com/ea36b896-47dd-432b-b6ca-1846551690d7.JPG" alt="file1.JPG"></p><p>图1 纸条编号</p><p><img src="https://images.ptausercontent.com/bf24077c-3593-46bf-b49a-6ba1d4bf5fad.JPG" alt="file2.JPG"></p><p>图2 还原结果</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先在第一行中给出一个正整数 <em>N</em>（1&lt;<em>N</em>≤105），为没有切碎的半张纸上断口折线角点的个数；随后一行给出从左到右 <em>N</em> 个折线角点的高度值（均为不超过 100 的非负整数）。</p><p>随后一行给出一个正整数 <em>M</em>（≤100），为碎纸机里的纸条数量。接下去有 <em>M</em> 行，其中第 <em>i</em> 行给出编号为 <em>i</em>（1≤<em>i</em>≤<em>M</em>）的纸条的断口信息，格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K h[1] h[2] ... h[K]</span><br></pre></td></tr></table></figure><p>其中 <code>K</code> 是断口折线角点的个数（不超过 104+1），后面是从左到右 <code>K</code> 个折线角点的高度值。为简单起见，这个“高度”跟没有切碎的半张纸上断口折线角点的高度是一致的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出还原后纸条的正确拼接顺序。纸条编号间以一个空格分隔，行首尾不得有多余空格。</p><p>题目数据保证存在唯一解。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">95</span> <span class="number">70</span> <span class="number">80</span> <span class="number">97</span> <span class="number">97</span> <span class="number">68</span> <span class="number">58</span> <span class="number">58</span> <span class="number">80</span> <span class="number">72</span> <span class="number">88</span> <span class="number">81</span> <span class="number">81</span> <span class="number">68</span> <span class="number">68</span> <span class="number">60</span> <span class="number">80</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">4</span> <span class="number">68</span> <span class="number">58</span> <span class="number">58</span> <span class="number">80</span></span><br><span class="line"><span class="number">3</span> <span class="number">81</span> <span class="number">68</span> <span class="number">68</span></span><br><span class="line"><span class="number">3</span> <span class="number">95</span> <span class="number">70</span> <span class="number">80</span></span><br><span class="line"><span class="number">3</span> <span class="number">68</span> <span class="number">60</span> <span class="number">80</span></span><br><span class="line"><span class="number">5</span> <span class="number">80</span> <span class="number">72</span> <span class="number">88</span> <span class="number">81</span> <span class="number">81</span></span><br><span class="line"><span class="number">4</span> <span class="number">80</span> <span class="number">97</span> <span class="number">97</span> <span class="number">68</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    暴力枚举，也不算暴力，就是一个一个试，用过之后，vis[i] = 1</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, t, arr[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ve[<span class="number">105</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.<span class="built_in">size</span>() == m) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i)   cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ve[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[s + j] != ve[i][j]) &#123;</span><br><span class="line">                flag = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)   <span class="keyword">continue</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(s + ve[i].<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; arr[i];</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        ve[i].<span class="built_in">resize</span>(t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t; ++j)  cin &gt;&gt; ve[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;一份重要文件被撕成两半，其中一半还被送进了碎纸机。我们将碎纸机里找到的纸条进行编号，如图 1 所示。然后根据断口的折线形状跟没有切碎的半张纸进行匹配，最后还原成图 2 的样子。要求你输出还原后纸条的正确拼接顺序。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="训练营" scheme="http://wangxu1905.github.io/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>7-3 摧毁道路 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/04/04/7-3%20%E6%91%A7%E6%AF%81%E9%81%93%E8%B7%AF%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/04/04/7-3%20%E6%91%A7%E6%AF%81%E9%81%93%E8%B7%AF%20(25%20%E5%88%86)/</id>
    <published>2022-04-04T13:09:16.238Z</published>
    <updated>2022-04-04T13:19:54.455Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>魔王K打算入侵A王国，为了胜利，他想要破坏A王国中各个城镇的联系。A王国总共有<em>N</em>个城镇，<em>M</em>条<strong>双向道路</strong>，其中有两个重要城市<em>S</em>与<em>T</em>,魔王要破坏一些道路使得城市<em>S</em>无法到达城市<em>T</em>.破坏不同的道路需要花费的代价是可能是不同的，魔王想要花费最小的代价来破坏道路，他希望作为军师的你来帮助他。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行四个整数 <em>N</em>,<em>M</em>,<em>S</em>,<em>T</em>(1≤<em>N</em>≤100,1≤<em>M</em>≤5000) 。</p><p>接下来的 <em>M</em> 行，每行三个整数<em>u</em>,<em>v</em>,<em>w</em>表示 <em>u</em>与 <em>v</em>之间有一条边，破坏的代价是<em>w</em>(1≤<em>w</em>≤231−1)</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出最小代价</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure><p><img src="https://images.ptausercontent.com/9a8de216-dfda-4d22-a96d-650ada07f29e.png" alt="QQ截图20220401085412.png"></p><p>样例如图，破坏1与4之间的联系需要的最小花费是：13</p><p>分别是破坏3–4之间的边花费2的代价、破坏1–5之间的边花费3的代价、破坏1–4之间的边花费8的代价</p><p>注意：是双向道路！！！</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    咱也不懂，听说网络最大流和最小割是个对偶问题，网络流有FF,EK,dinic算法，先上代码，等懂了之后，再做解释</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, len,head[maxn],dep[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, fail;</span><br><span class="line">    <span class="built_in">edge</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _fail) &#123;</span><br><span class="line">        v = _v, w = _w, fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[len] = <span class="built_in">edge</span>(v, w, head[u]);</span><br><span class="line">    head[u] = len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(s);</span><br><span class="line">    dep[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i ; i = e[i].fail) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">            <span class="comment">//没访问过且存在剩余容量则标记</span></span><br><span class="line">            <span class="keyword">if</span>(w &amp;&amp; !dep[v]) &#123;</span><br><span class="line">                qu.<span class="built_in">push</span>(v);</span><br><span class="line">                dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果存在到汇点的增广路，则dep[t] != 0,否则返回0</span></span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不懂（先别看）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i ; i = e[i].fail) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v,w = e[i].w;</span><br><span class="line">        <span class="comment">/*每次找增广路的时候，都只找比当前点层数多1的点进行增广（这样就可以确保我们找到的增广路是最短的*/</span></span><br><span class="line">        <span class="keyword">if</span> (w &amp;&amp; dep[v] == dep[u] + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//继续找增广路，流量为自身容量和现在最大容量的最小值</span></span><br><span class="line">            <span class="keyword">int</span> tf = <span class="built_in">dfs</span>(v, t, <span class="built_in">min</span>(e[i].w, flow - pre));</span><br><span class="line">            <span class="keyword">if</span> (tf) e[i].w -= tf, e[i ^ <span class="number">1</span>].w += tf, pre += tf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre &lt; flow) dep[u] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//bfs分层，不存在到汇点的增广路，则停止增广</span></span><br><span class="line">    <span class="comment">//确保我们找到的增广路是最短路</span></span><br><span class="line">    <span class="comment">//dfs进行多路增广</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) res += <span class="built_in">dfs</span>(s,t,INF);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">        <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dinic</span>(s, t) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;魔王K打算入侵A王国，为了胜利，他想要破坏A王国中各个城镇的联系。A王国总共有&lt;em&gt;N&lt;/em&gt;个城镇，&lt;em&gt;M&lt;/em&gt;条&lt;strong&gt;双向道路&lt;/strong&gt;，其中有两个重要城市&lt;em&gt;S&lt;/em&gt;与&lt;em&gt;T&lt;</summary>
      
    
    
    
    
    <category term="图论" scheme="http://wangxu1905.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="网络流" scheme="http://wangxu1905.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>7-39 直捣黄龙 (30 分)</title>
    <link href="http://wangxu1905.github.io/2022/04/03/7-39%20%E7%9B%B4%E6%8D%A3%E9%BB%84%E9%BE%99%20(30%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/04/03/7-39%20%E7%9B%B4%E6%8D%A3%E9%BB%84%E9%BE%99%20(30%20%E5%88%86)/</id>
    <published>2022-04-03T12:36:33.086Z</published>
    <updated>2022-04-03T12:42:08.979Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>本题是一部战争大片 —— 你需要从己方大本营出发，一路攻城略地杀到敌方大本营。首先时间就是生命，所以你必须选择合适的路径，以最快的速度占领敌方大本营。当这样的路径不唯一时，要求选择可以沿途解放最多城镇的路径。若这样的路径也不唯一，则选择可以有效杀伤最多敌军的路径。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出2个正整数<code>N</code>（2 ≤ <code>N</code> ≤ 200，城镇总数）和<code>K</code>（城镇间道路条数），以及己方大本营和敌方大本营的代号。随后<code>N</code>-1行，每行给出除了己方大本营外的一个城镇的代号和驻守的敌军数量，其间以空格分隔。再后面有<code>K</code>行，每行按格式<code>城镇1 城镇2 距离</code>给出两个城镇之间道路的长度。这里设每个城镇（包括双方大本营）的代号是由3个大写英文字母组成的字符串。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按照题目要求找到最合适的进攻路径（题目保证速度最快、解放最多、杀伤最强的路径是唯一的），并在第一行按照格式<code>己方大本营-&gt;城镇1-&gt;...-&gt;敌方大本营</code>输出。第二行顺序输出最快进攻路径的条数、最短进攻距离、歼敌总数，其间以1个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">12</span> PAT DBY</span><br><span class="line">DBY <span class="number">100</span></span><br><span class="line">PTA <span class="number">20</span></span><br><span class="line">PDS <span class="number">90</span></span><br><span class="line">PMS <span class="number">40</span></span><br><span class="line">TAP <span class="number">50</span></span><br><span class="line">ATP <span class="number">200</span></span><br><span class="line">LNN <span class="number">80</span></span><br><span class="line">LAO <span class="number">30</span></span><br><span class="line">LON <span class="number">70</span></span><br><span class="line">PAT PTA <span class="number">10</span></span><br><span class="line">PAT PMS <span class="number">10</span></span><br><span class="line">PAT ATP <span class="number">20</span></span><br><span class="line">PAT LNN <span class="number">10</span></span><br><span class="line">LNN LAO <span class="number">10</span></span><br><span class="line">LAO LON <span class="number">10</span></span><br><span class="line">LON DBY <span class="number">10</span></span><br><span class="line">PMS TAP <span class="number">10</span></span><br><span class="line">TAP DBY <span class="number">10</span></span><br><span class="line">DBY PDS <span class="number">10</span></span><br><span class="line">PDS PTA <span class="number">10</span></span><br><span class="line">DBY ATP <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PAT-&gt;PTA-&gt;PDS-&gt;DBY</span><br><span class="line"><span class="number">3</span> <span class="number">30</span> <span class="number">210</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​        Dijkstra的改编，dis为路径，num为杀敌数量，cnt为解放城市的数量，pre记录路径，sum记录最短的路数</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, w, k, val[maxn];</span><br><span class="line">string str, s, d;</span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt; book1; <span class="comment">//名字映射标号</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, string&gt; book2; <span class="comment">//标号映射名字</span></span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[n + <span class="number">1</span>], num[n + <span class="number">1</span>], cnt[n + <span class="number">1</span>],pre[n + <span class="number">1</span>],sum[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        dis[i] = mar[u][i];</span><br><span class="line">    dis[u] = <span class="number">0</span>, vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">    <span class="built_in">fill</span>(cnt,cnt + n + <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fill</span>(sum,sum + n + <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> minnum = INF, pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span>((minnum &gt; dis[j]) ) &#123;</span><br><span class="line">                    pos = j;</span><br><span class="line">                    minnum = dis[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minnum == INF)   <span class="keyword">break</span>;</span><br><span class="line">        vis[pos] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]) &#123;</span><br><span class="line">                <span class="comment">//如果能够找到最小的路，全部更新</span></span><br><span class="line">                <span class="keyword">if</span>(dis[j] &gt; dis[pos] + mar[pos][j]) &#123;</span><br><span class="line">                    dis[j] = dis[pos] + mar[pos][j];</span><br><span class="line">                    num[j] = num[pos] + val[j];</span><br><span class="line">                    pre[j] = pos;</span><br><span class="line">                    cnt[j] = cnt[pos] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//路径赋值，而不是相加</span></span><br><span class="line">                    sum[j] = sum[pos];</span><br><span class="line">                 &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dis[j] == dis[pos] + mar[pos][j])&#123;</span><br><span class="line">                    <span class="comment">//如果能够更新解放的城市，则更新</span></span><br><span class="line">                    <span class="keyword">if</span>(cnt[j] &lt; cnt[pos] + <span class="number">1</span>)&#123;</span><br><span class="line">                        cnt[j] = cnt[pos] + <span class="number">1</span>;</span><br><span class="line">                        num[j] = num[pos] + val[j];</span><br><span class="line">                        pre[j] = pos;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果能够更新杀敌的数量，更新</span></span><br><span class="line">                    <span class="keyword">if</span>(num[j] &lt; num[pos] + val[j])&#123;</span><br><span class="line">                        cnt[j] = cnt[pos] + <span class="number">1</span>;</span><br><span class="line">                        num[j] = num[pos] + val[j];</span><br><span class="line">                        pre[j] = pos;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//路径数量相加</span></span><br><span class="line">                    sum[j] += sum[pos];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> h = book1[d],flag = <span class="number">0</span>;</span><br><span class="line">    stack&lt;string&gt; st;</span><br><span class="line">    <span class="keyword">while</span>(pre[h] != <span class="number">-1</span>)&#123;</span><br><span class="line">        st.<span class="built_in">push</span>(book2[h]);</span><br><span class="line">        h = pre[h];</span><br><span class="line">    &#125;</span><br><span class="line">    st.<span class="built_in">push</span>(book2[h]);</span><br><span class="line">    <span class="keyword">int</span> val1 = val[h];</span><br><span class="line">    st.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>    flag = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sum[book1[d]] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt;dis[book1[d]]  &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; num[book1[d]]  + val1&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d;</span><br><span class="line">    book1[s] = k, val[k] = <span class="number">0</span>, book2[k++] = s;</span><br><span class="line">    <span class="built_in">memset</span>(mar, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mar));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) mar[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; str &gt;&gt; w;</span><br><span class="line">        <span class="keyword">if</span>(!book1.<span class="built_in">count</span>(str)) &#123;</span><br><span class="line">            book1[str] = k;</span><br><span class="line">            val[k] = w;</span><br><span class="line">            book2[k++] = str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        string a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        <span class="keyword">int</span> u = book1[a], v = book1[b];</span><br><span class="line">        mar[u][v] = mar[v][u] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(book1[s]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;本题是一部战争大片 —— 你需要从己方大本营出发，一路攻城略地杀到敌方大本营。首先时间就是生命，所以你必须选择合适的路径，以最快的速度占领敌方大本营。当这样的路径不唯一时，要求选择可以沿途解放最多城镇的路径。若这样的路径也不</summary>
      
    
    
    
    
    <category term="图论" scheme="http://wangxu1905.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路" scheme="http://wangxu1905.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="Dijkstra" scheme="http://wangxu1905.github.io/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>7-37 旅游规划 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/04/03/7-37%20%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/04/03/7-37%20%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92%20(25%20%E5%88%86)/</id>
    <published>2022-04-03T12:35:05.647Z</published>
    <updated>2022-04-03T12:36:14.776Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入数据的第1行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0~(<em>N</em>−1)；<em>M</em>是高速公路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。随后的<em>M</em>行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">20</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">30</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">4</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">20</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">40</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​        Dijsktra堆优化，没啥</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, s, d,cost[maxn][maxn];</span><br><span class="line">vector&lt;PII&gt; mar[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[n + <span class="number">1</span>], num[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//别vis[s] = 1,要不while循环不起作用</span></span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">top</span>().y;</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//如果访问过，继续</span></span><br><span class="line">        <span class="keyword">if</span>(vis[u])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//标记访问</span></span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mar[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = mar[u][i].x, w = mar[u][i].y;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                    dis[v] = dis[u] + w;</span><br><span class="line">                    num[v] = num[u] + cost[u][v];</span><br><span class="line">                    qu.<span class="built_in">push</span>(&#123;dis[v], v&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dis[v] == dis[u] + w &amp;&amp; num[v] &gt; num[u] + cost[u][v]) &#123;</span><br><span class="line">                    num[v] = num[u] + cost[u][v];</span><br><span class="line">                    qu.<span class="built_in">push</span>(&#123;dis[v], v&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dis[d] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num[d] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d;</span><br><span class="line">    <span class="built_in">memset</span>(cost, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cost));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) cost[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w, c;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c;</span><br><span class="line">        mar[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">        mar[v].<span class="built_in">push_back</span>(&#123;u, w&#125;);</span><br><span class="line">        cost[u][v] = cost[v][u] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="图论" scheme="http://wangxu1905.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路" scheme="http://wangxu1905.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="Dijkstra" scheme="http://wangxu1905.github.io/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>7-49 螺旋矩阵 (10 分)</title>
    <link href="http://wangxu1905.github.io/2022/04/03/7-49%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20(10%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/04/03/7-49%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%20(10%20%E5%88%86)/</id>
    <published>2022-04-03T12:28:15.842Z</published>
    <updated>2022-04-03T12:33:37.933Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>所谓“螺旋矩阵”，是指对任意给定的N，将1到N×N的数字从左上角第1个格子开始，按顺时针螺旋方向顺序填入N×N的方阵里。本题要求构造这样的螺旋方阵。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行中给出一个正整数N（&lt;10）。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出N×N的螺旋方阵。每行N个数字，每个数字占4位。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"><span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span>   <span class="number">6</span></span><br><span class="line"><span class="number">15</span>  <span class="number">24</span>  <span class="number">25</span>  <span class="number">20</span>   <span class="number">7</span></span><br><span class="line"><span class="number">14</span>  <span class="number">23</span>  <span class="number">22</span>  <span class="number">21</span>   <span class="number">8</span></span><br><span class="line"><span class="number">13</span>  <span class="number">12</span>  <span class="number">11</span>  <span class="number">10</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    头大，没啥算法，单纯的模拟，但就是不想写</p><p>​    从网上找篇题解，看看，感觉还行，就是单纯的模拟</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h2><h2 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> a[n][n];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//向右走</span></span><br><span class="line">        <span class="keyword">for</span>(j = i; j &lt; n - i; j++)</span><br><span class="line">            a[i][j] = ++count;</span><br><span class="line">        <span class="comment">//向下走</span></span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n - i; j++)</span><br><span class="line">            a[j][n - i - <span class="number">1</span>] = ++count;</span><br><span class="line">        <span class="comment">//向左走</span></span><br><span class="line">        <span class="keyword">for</span>(j = n - i - <span class="number">2</span>; j &gt; i; j--)</span><br><span class="line">            a[n - i - <span class="number">1</span>][j] = ++count;</span><br><span class="line">        <span class="comment">//向上走</span></span><br><span class="line">        <span class="keyword">for</span>(j = n - i - <span class="number">1</span>; j &gt;= i + <span class="number">1</span>; j--)</span><br><span class="line">            a[j][i] = ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>, a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;所谓“螺旋矩阵”，是指对任意给定的N，将1到N×N的数字从左上角第1个格子开始，按顺时针螺旋方向顺序填入N×N的方阵里。本题要求构造这样的螺旋方阵。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; cla</summary>
      
    
    
    
    
    <category term="模拟" scheme="http://wangxu1905.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>7-48 最大公约数 (20 分)</title>
    <link href="http://wangxu1905.github.io/2022/04/03/7-48%20%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%20(20%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/04/03/7-48%20%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%20(20%20%E5%88%86)/</id>
    <published>2022-04-03T12:22:53.471Z</published>
    <updated>2022-04-03T12:28:28.139Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给出整数a，b，m，n，p，且a和b互质，a&gt;b，求<em>a**m</em>-<em>b**m</em>和<em>a**n</em>-<em>b**n</em>的最大公约数模p的结果。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行中包含5个32位无符号整数a，b，m，n和p，且p&gt;1。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出在一行中给出计算结果。</p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">7</span> <span class="number">5</span> <span class="number">4</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> <span class="number">5</span> <span class="number">6</span> <span class="number">3</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    大佬说是裴蜀定理，看了一遍，看懂了，但是不知道和这题有啥联系</p><p>​    搜题干，搜了必应，找了两页没发现相关的理论，通过苗姐指导，搜百度，首页第一条就是(百度，我错了，当初不该瞧不起你)</p><p>设K是m与n的最大公约数，则<br>(a的n次方-b的n次方)与(a的m次方-b的m次方)的最大公约数:<br>=(a的K次方-b的K次方)</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)   res *= x;</span><br><span class="line">        x *= x;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,m,n,p;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; m &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="keyword">int</span> d = __gcd(m,n);</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">fastpow</span>(a,d) - <span class="built_in">fastpow</span>(b,d) + p) % p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给出整数a，b，m，n，p，且a和b互质，a&amp;gt;b，求&lt;em&gt;a**m&lt;/em&gt;-&lt;em&gt;b**m&lt;/em&gt;和&lt;em&gt;a**n&lt;/em&gt;-&lt;em&gt;b**n&lt;/em&gt;的最大公约数模p的结果。&lt;/p&gt;
&lt;h3 id=&quot;输入格</summary>
      
    
    
    
    
    <category term="数论" scheme="http://wangxu1905.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="裴蜀定理" scheme="http://wangxu1905.github.io/tags/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>7-45 区间质数 (50 分)</title>
    <link href="http://wangxu1905.github.io/2022/04/03/7-47%20%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%20(10%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/04/03/7-47%20%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%20(10%20%E5%88%86)/</id>
    <published>2022-04-03T12:18:47.737Z</published>
    <updated>2022-04-03T12:17:41.743Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定<em>T</em>组询问，每次询问一个区间[l,r]中的质数个数</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤<em>T</em>≤106</p><p>1≤<em>l</em>≤<em>r</em>≤106</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行输入一个整数<em>T</em>，代表询问次数, 接下来有<em>T</em>行，每行有两个数<em>l</em>,<em>r</em>代表询问区间.</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出<em>T</em>行,表示每组询问的结果.</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 10</span><br><span class="line">10 20</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>样例解释：1 ~ 10中有4个质数（2，3，5，7），10 ~ 20中有4个质数（11，13，17，19）</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    一看区间质数，二话不说先敲模板，敲完之后发现不对，本身数据也不是很大，而且是多次查询，总不能每次查询就跑一遍区间素数。</p><p>​    我不会线筛，虽然我知道它快，但是我会埃氏筛，时间上还行，哈哈哈哈哈</p><p>​    直接来一遍最大范围的埃氏筛，然后求一遍前缀和，以达到查询时间<code>O(1)</code></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> n, l, r, sum[maxn];</span><br><span class="line"><span class="keyword">bool</span> is_prime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(is_prime, <span class="literal">true</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(is_prime));</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i) is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">solve</span>(maxn);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; ++i) </span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + is_prime[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum[r] - sum[l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定&lt;em&gt;T&lt;/em&gt;组询问，每次询问一个区间[l,r]中的质数个数&lt;/p&gt;
&lt;h3 id=&quot;数据范围&quot;&gt;&lt;a href=&quot;#数据范围&quot; class=&quot;headerlink&quot; title=&quot;数据范围&quot;&gt;&lt;/a&gt;数据范围&lt;/</summary>
      
    
    
    
    
    <category term="素数筛" scheme="http://wangxu1905.github.io/tags/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    
  </entry>
  
  <entry>
    <title>7-47 欧拉函数 (10 分)</title>
    <link href="http://wangxu1905.github.io/2022/04/03/7-45%20%E5%8C%BA%E9%97%B4%E8%B4%A8%E6%95%B0%20(50%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/04/03/7-45%20%E5%8C%BA%E9%97%B4%E8%B4%A8%E6%95%B0%20(50%20%E5%88%86)/</id>
    <published>2022-04-03T12:10:55.254Z</published>
    <updated>2022-04-03T12:22:35.070Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>在数论中，对正整数n，欧拉函数<em>ϕ</em>(<em>n</em>)是小于或等于n的正整数中与n 互质的数的数目。此函数以其首名研究者欧拉命名，它又称为φ函数（由高斯所命名）</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>一个正整数n。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>一个数，表示欧拉函数<em>ϕ</em>(<em>n</em>)。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>注释：表示10以内有4个数与10 互质，它们是：1，3，7，9</p><p>$\phi(n)=n \prod_{i=1}^{r}\left(1-1 / p_{i}\right) $其中，其中<em>p</em>1,<em>p</em>2……<em>p**r</em>为n的所有质因数</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    一看区间质数，二话不说先敲模板，敲完之后发现不对，本身数据也不是很大，而且是多次查询，总不能每次查询就跑一遍区间素数。</p><p>​    我不会线筛，虽然我知道它快，但是我会埃氏筛，时间上还行，哈哈哈哈哈</p><p>​    直接来一遍最大范围的埃氏筛，然后求一遍前缀和，以达到查询时间<code>O(1)</code></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> x = n;</span><br><span class="line">    <span class="keyword">double</span> res = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res *= (<span class="number">1</span> - <span class="number">1.0</span> / i);</span><br><span class="line">            <span class="comment">/*因为是素数因子，所以不存在大的素数没有小的素数因子，直接出干净就行*/</span></span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)   n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)   res *= (<span class="number">1</span> - <span class="number">1.0</span> / n);</span><br><span class="line">    cout &lt;&lt; (<span class="keyword">int</span>)res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;在数论中，对正整数n，欧拉函数&lt;em&gt;ϕ&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;)是小于或等于n的正整数中与n 互质的数的数目。此函数以其首名研究者欧拉命名，它又称为φ函数（由高斯所命名）&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="欧拉函数" scheme="http://wangxu1905.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>7-44 负环最短路 (10 分)</title>
    <link href="http://wangxu1905.github.io/2022/04/03/7-44%20%E8%B4%9F%E7%8E%AF%E6%9C%80%E7%9F%AD%E8%B7%AF%20(10%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/04/03/7-44%20%E8%B4%9F%E7%8E%AF%E6%9C%80%E7%9F%AD%E8%B7%AF%20(10%20%E5%88%86)/</id>
    <published>2022-04-03T11:31:13.765Z</published>
    <updated>2022-04-03T13:11:16.525Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>给定一个可能包含负权边的有向图，可以求得任意两个顶点间的最短路径长度。但如果该图包含权值和为负的环，如图1所示，则一些顶点间的最短路径则变得没有意义，因为在负环内每走一圈，距离都会变得更短。请编写程序求得任意两个顶点间的最短路径长度，如果图包含负权环，程序亦能识别。假定图中包含n个顶点，编号为0至n-1。</p><p><img src="https://images.ptausercontent.com/85b38b54-1dd0-43b4-a499-96016871aa2f.jpg" alt="negitivecircle.jpg"></p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p><strong>输入包含多组数据</strong>，每组数据第一行为3个正整数n、e、m，n和e分别为图的顶点数和边数，均不超过100。接下来e行表示每条边的信息，每行为3个整数a、b、c，其中a和b表示该边的端点编号，c表示权值。各边并非按端点编号顺序排列。接下来m行表示m组查询，每行2个整数x和y，表示两个顶点编号。</p><p>提示：可使用EOF判断输入结束</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对于每组数据，如果图中含负权环，则仅输出“negative circle”，若图中不含负权环，则输出为m行，每行为顶点x到顶点y的最短路径长度，如x和y不连通，则输出“none”。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">-2</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">none</span><br><span class="line">negative circle</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    关于spfa死没死，我是不知道的（狗头）</p><p>​    一看50ms，先试试spfa,结果发现跑出来4ms，应该Bellman-Ford也是可以过去</p><p>（本题测试数据量太小了）</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//spfa写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, fail;</span><br><span class="line">    <span class="built_in">edge</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> _v, <span class="keyword">int</span> _w, <span class="keyword">int</span> _fail) &#123;</span><br><span class="line">        v = _v, w = _w, fail = _fail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[<span class="number">5050</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, q, len, dis[<span class="number">5050</span>], in[<span class="number">5050</span>], head[<span class="number">5050</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">5050</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++len] = <span class="built_in">edge</span>(v, w, head[u]);</span><br><span class="line">    head[u] = len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(in));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(s);</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i ; i = e[i].fail) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">                    qu.<span class="built_in">push</span>(v);</span><br><span class="line">                    vis[v] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(++in[v] &gt;= n)   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;q) != EOF) &#123;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            <span class="built_in">add</span>(u, v, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  <span class="built_in">add</span>(n, i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//超级源点判负环</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">spfa</span>(n)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;negative circle&quot;</span> &lt;&lt; endl;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                <span class="built_in">spfa</span>(u);</span><br><span class="line">                <span class="keyword">if</span>(dis[v] &gt;= INF)    cout &lt;&lt; <span class="string">&quot;none&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">else</span>    cout &lt;&lt; dis[v] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,k,u,v,in[maxn],dis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = e[j].u,v = e[j].v,w = e[j].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + w)&#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(i == n - <span class="number">1</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果此轮循环没有更新过，则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;k) != EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">BellmanFord</span>(<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">                cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">                <span class="built_in">BellmanFord</span>(u);</span><br><span class="line">                <span class="keyword">if</span>(dis[v] &gt;= INF)   cout &lt;&lt; <span class="string">&quot;none&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">else</span>    cout &lt;&lt; dis[v] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)  cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;negative circle&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;给定一个可能包含负权边的有向图，可以求得任意两个顶点间的最短路径长度。但如果该图包含权值和为负的环，如图1所示，则一些顶点间的最短路径则变得没有意义，因为在负环内每走一圈，距离都会变得更短。请编写程序求得任意两个顶点间的最短</summary>
      
    
    
    
    
    <category term="图论" scheme="http://wangxu1905.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路" scheme="http://wangxu1905.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="spfa" scheme="http://wangxu1905.github.io/tags/spfa/"/>
    
    <category term="Bellman-Ford" scheme="http://wangxu1905.github.io/tags/Bellman-Ford/"/>
    
  </entry>
  
  <entry>
    <title>7-41 哥尼斯堡的“七桥问题” (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/04/03/7-41%20%E5%93%A5%E5%B0%BC%E6%96%AF%E5%A0%A1%E7%9A%84%E2%80%9C%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%98%E2%80%9D%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/04/03/7-41%20%E5%93%A5%E5%B0%BC%E6%96%AF%E5%A0%A1%E7%9A%84%E2%80%9C%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%98%E2%80%9D%20(25%20%E5%88%86)/</id>
    <published>2022-04-03T11:12:03.435Z</published>
    <updated>2022-04-03T11:31:06.988Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>哥尼斯堡是位于普累格河上的一座城市，它包含两个岛屿及连接它们的七座桥，如下图所示。</p><p><img src="https://images.ptausercontent.com/51" alt="img"></p><p>可否走过这样的七座桥，而且每桥只走过一次？瑞士数学家欧拉(Leonhard Euler，1707—1783)最终解决了这个问题，并由此创立了拓扑学。</p><p>这个问题如今可以描述为判断欧拉回路是否存在的问题。欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个无向图，问是否存在欧拉回路？</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第一行给出两个正整数，分别是节点数<em>N</em> (1≤<em>N</em>≤1000)和边数<em>M</em>；随后的<em>M</em>行对应<em>M</em>条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号（节点从1到<em>N</em>编号）。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>若欧拉回路存在则输出1，否则输出0。</p><h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    关于欧拉回路，也忘得差不多了</p><p>​    判断一个图是否有欧拉回路，其充分必要条件为不存在度为奇数的点。</p><p>​    判断是欧拉回路则是度为奇数的点个数为0或者2个</p><p>​    同时此题还需判断图是否是连通状态的，所以要用一个并查集来判断</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,degree[maxn],f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] == <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> f[x] = <span class="built_in">Find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="comment">//记录度数</span></span><br><span class="line">        degree[u]++,degree[v]++;</span><br><span class="line">        <span class="keyword">int</span> fa = <span class="built_in">Find</span>(u),fb = <span class="built_in">Find</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(fa != fb)    f[fb] = fa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> father = <span class="built_in">Find</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果所有结点的父亲不是同一个，则图不连通</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(father != <span class="built_in">Find</span>(i))&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有奇数度的点，则不存在欧拉回路</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(degree[i] &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;哥尼斯堡是位于普累格河上的一座城市，它包含两个岛屿及连接它们的七座桥，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.ptausercontent.com/51&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="图论" scheme="http://wangxu1905.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="欧拉回路" scheme="http://wangxu1905.github.io/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>7-23 逆序对的数量 (20 分)</title>
    <link href="http://wangxu1905.github.io/2022/04/03/7-23%20%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F%20(20%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/04/03/7-23%20%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F%20(20%20%E5%88%86)/</id>
    <published>2022-04-03T10:28:13.763Z</published>
    <updated>2022-04-03T11:10:38.047Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>知识点：归并排序</p><p>给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。</p><p>逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i&lt;j 且 a[i]&gt;a[j]，则其为一个逆序对；否则不是。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行包含整数 n(1≤n≤100000)，表示数列的长度。</p><p>第二行包含 n 个整数，表示整个数列,数列中的元素的取值范围 [1~10^9]。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>请在这里描述输出格式。例如：对每一组输入，在一行中输出A+B的值。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    虽说题干说是用归并排序，但我就是要用树状数组（狗头）</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1000005</span>;</span><br><span class="line">ll n,a[maxn],num[maxn],numrank[maxn],tree[maxn];</span><br><span class="line"><span class="function">ll <span class="title">lowbit</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x, ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">        tree[x] += k;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        res += tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span> ; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; ++i) num[i] = a[i];</span><br><span class="line">    <span class="built_in">sort</span>(num + <span class="number">1</span>,num + n + <span class="number">1</span>);</span><br><span class="line">    ll m = <span class="built_in">unique</span>(num + <span class="number">1</span>,num + n + <span class="number">1</span>) - (num + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//数据进行离散化处理</span></span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        numrank[i] = <span class="built_in">lower_bound</span>(num + <span class="number">1</span>,num + n + <span class="number">1</span>,a[i]) - num;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//然后每次numrank[i]的位置+1，res加上i与前numrank[i]项的差值</span></span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">add</span>(numrank[i],<span class="number">1</span>);</span><br><span class="line">        res += i - <span class="built_in">ask</span>(numrank[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,res,a[maxn],tmp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(mid + <span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> i = l,j = mid + <span class="number">1</span>,k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[j]) tmp[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r)   tmp[k++] = a[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l,j = <span class="number">0</span>;i &lt;= r;i++,j++) a[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    归并排序的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,res,a[maxn],tmp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(mid + <span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> i = l,j = mid + <span class="number">1</span>,k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//转移到tmp数组上</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[j]) tmp[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果符合逆序对定义，则res+=mid-i+1</span></span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r)   tmp[k++] = a[j++];</span><br><span class="line">    <span class="comment">//然后转移到原数组上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l,j = <span class="number">0</span>;i &lt;= r;i++,j++) a[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我还是喜欢树状数组（主要归并排序我不会写，哈哈哈哈）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;知识点：归并排序&lt;/p&gt;
&lt;p&gt;给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。&lt;/p&gt;
&lt;p&gt;逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i&amp;lt;j 且 a[i]&amp;gt;a[j]，则其</summary>
      
    
    
    
    
    <category term="归并排序" scheme="http://wangxu1905.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
    <category term="树状数组" scheme="http://wangxu1905.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>08-图9 关键活动</title>
    <link href="http://wangxu1905.github.io/2022/04/03/08-%E5%9B%BE9%20%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8%20/"/>
    <id>http://wangxu1905.github.io/2022/04/03/08-%E5%9B%BE9%20%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8%20/</id>
    <published>2022-04-03T08:18:25.163Z</published>
    <updated>2022-04-03T09:07:04.906Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。</p><p>比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和C程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如C程序设计和数据结构两门课，必须先学习前者。</p><p>但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务A依赖于子任务B，子任务B依赖于子任务C，子任务C又依赖于子任务A”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。</p><p>任务调度问题中，如果还给出了完成每个子任务需要的时间，则我们可以算出完成整个工程需要的最短时间。在这些子任务中，有些任务即使推迟几天完成，也不会影响全局的工期；但是有些任务必须准时完成，否则整个项目的工期就要因此延误，这种任务就叫“关键活动”。</p><p>请编写程序判定一个给定的工程项目的任务调度是否可行；如果该调度方案可行，则计算完成整个工程项目需要的最短时间，并输出所有的关键活动。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出两个正整数<em>N</em>(≤100)和<em>M</em>，其中<em>N</em>是任务交接点（即衔接相互依赖的两个子任务的节点，例如：若任务2要在任务1完成后才开始，则两任务之间必有一个交接点）的数量。交接点按1<del><em>N</em>编号，<em>M</em>是子任务的数量，依次编号为1</del><em>M</em>。随后<em>M</em>行，每行给出了3个正整数，分别是该任务开始和完成涉及的交接点编号以及该任务所需的时间，整数间用空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>如果任务调度不可行，则输出0；否则第1行输出完成整个工程项目需要的时间，第2行开始输出所有关键活动，每个关键活动占一行，按格式“V-&gt;W”输出，其中V和W为该任务开始和完成涉及的交接点编号。关键活动输出的顺序规则是：任务开始的交接点编号小者优先，起点编号相同时，与输入时任务的顺序相反。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line"><span class="number">2</span>-&gt;<span class="number">4</span></span><br><span class="line"><span class="number">4</span>-&gt;<span class="number">6</span></span><br><span class="line"><span class="number">6</span>-&gt;<span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    回头再看看拓扑排序。</p><p>​    <strong>拓扑排序顺序为：</strong></p><ul><li>记录入度（或出度）</li><li>然后将入度0的入队，更新距离（找最大距离），删边，此时入度为0的结点入队</li><li>结束遍历，如果入过队的不是n个，则无解，否则则有解</li></ul><p><strong>而关键路径，在此的基础上多出几步：</strong></p><ul><li><p>将LTime数组赋值成拓扑求得的最大距离</p></li><li><p>将出度为0的结点入队，更新距离（找最小距离），删边，此时出度为0的结点入队</p></li><li><p>结束遍历即可</p></li><li><p>然后打印路径,路径就是当前点到下一个点满足<code>ETime[u]+w=LTime[v]</code></p><p>即，当前点的最早时间+路径长度=下一个点的最晚时间，此时无法在进行松弛，即为关键路径</p></li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>​    过去写的，采用的邻接矩阵</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F 999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M,ECT;</span><br><span class="line"><span class="keyword">int</span> mar[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> Indegree[<span class="number">101</span>],Outdegree[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> ETime[<span class="number">101</span>],LTime[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Late</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ;++i)&#123;</span><br><span class="line">        LTime[i] = ECT;</span><br><span class="line">        <span class="keyword">if</span>(Outdegree[i] == <span class="number">0</span>)  qu.<span class="built_in">push</span>(i); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mar[i][t] != F)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--Outdegree[i] == <span class="number">0</span>)    qu.<span class="built_in">push</span>(i);</span><br><span class="line">                <span class="keyword">if</span>(LTime[t] - mar[i][t] &lt; LTime[i])</span><br><span class="line">                    LTime[i] = LTime[t] - mar[i][t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TopSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ;++i)</span><br><span class="line">        <span class="keyword">if</span>(Indegree[i] == <span class="number">0</span>)  qu.<span class="built_in">push</span>(i); </span><br><span class="line">    <span class="keyword">while</span>(qu.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mar[t][i] != F)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--Indegree[i] == <span class="number">0</span>)    qu.<span class="built_in">push</span>(i);</span><br><span class="line">                <span class="keyword">if</span>(ETime[t] + mar[t][i] &gt; ETime[i])</span><br><span class="line">                    ETime[i] = ETime[t] + mar[t][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt != N)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ECT = *<span class="built_in">max_element</span>(ETime + <span class="number">1</span>,ETime + <span class="number">1</span> + N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">fill</span>(mar[<span class="number">0</span>],mar[<span class="number">0</span>] + <span class="number">101</span> * <span class="number">101</span>,F);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        mar[a][b] = c;</span><br><span class="line">        Indegree[b]++;</span><br><span class="line">        Outdegree[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">TopSort</span>())&#123;</span><br><span class="line">        cout &lt;&lt; ECT &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Late</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = N; j &gt;= <span class="number">1</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mar[i][j] != F &amp;&amp; ETime[i] + mar[i][j] == LTime[j])</span><br><span class="line">                    cout &lt;&lt; i &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在写的，采用邻接表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">int</span> n,m,ECT,in[<span class="number">501</span>],out[<span class="number">501</span>],ETime[<span class="number">501</span>],LTime[<span class="number">501</span>];</span><br><span class="line">vector&lt;PII&gt; mar[<span class="number">501</span>],mar2[<span class="number">501</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Late</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(out[i] == <span class="number">0</span>) qu.<span class="built_in">push</span>(i);</span><br><span class="line">        LTime[i] = ECT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//注意将反向表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mar2[u].<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = mar2[u][i].x,w = mar2[u][i].y;</span><br><span class="line">            <span class="keyword">if</span>(LTime[v] &gt; LTime[u] - w) LTime[v] = LTime[u] - w;</span><br><span class="line">            <span class="keyword">if</span>(--out[v] == <span class="number">0</span>)   qu.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tupo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(in[i] == <span class="number">0</span>)  qu.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mar[u].<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = mar[u][i].x,w = mar[u][i].y;</span><br><span class="line">            <span class="keyword">if</span>(ETime[v] &lt; ETime[u] + w) ETime[v] = ETime[u] + w;</span><br><span class="line">            <span class="keyword">if</span>(--in[v] == <span class="number">0</span>)    qu.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt != n)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ECT = *<span class="built_in">max_element</span>(ETime + <span class="number">1</span>,ETime + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        in[b]++;</span><br><span class="line">        out[a]++;</span><br><span class="line">        mar[a].<span class="built_in">push_back</span>(&#123;b,c&#125;);</span><br><span class="line">        <span class="comment">//建立反邻接表，以便于从后向前遍历</span></span><br><span class="line">        mar2[b].<span class="built_in">push_back</span>(&#123;a,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">tupo</span>())&#123;</span><br><span class="line">        cout &lt;&lt; ECT &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Late</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mar[i].<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> v = mar[i][j].x,w = mar[i][j].y;</span><br><span class="line">                <span class="keyword">if</span>(ETime[i] + w == LTime[v])    cout &lt;&lt; i &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。&lt;/p&gt;
&lt;p&gt;比如完成一个专业的所有课程学习和毕业</summary>
      
    
    
    
    
    <category term="图论" scheme="http://wangxu1905.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="拓扑" scheme="http://wangxu1905.github.io/tags/%E6%8B%93%E6%89%91/"/>
    
  </entry>
  
  <entry>
    <title>7-12 最短工期 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/04/03/7-12%20%E6%9C%80%E7%9F%AD%E5%B7%A5%E6%9C%9F%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/04/03/7-12%20%E6%9C%80%E7%9F%AD%E5%B7%A5%E6%9C%9F%20(25%20%E5%88%86)/</id>
    <published>2022-04-03T07:49:17.706Z</published>
    <updated>2022-04-03T08:01:10.650Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>一个项目由若干个任务组成，任务之间有先后依赖顺序。项目经理需要设置一系列里程碑，在每个里程碑节点处检查任务的完成情况，并启动后续的任务。现给定一个项目中各个任务之间的关系，请你计算出这个项目的最早完工时间。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>首先第一行给出两个正整数：项目里程碑的数量 <em>N</em>（≤100）和任务总数 <em>M</em>。这里的里程碑从 0 到 <em>N</em>−1 编号。随后 <em>M</em> 行，每行给出一项任务的描述，格式为“任务起始里程碑 任务结束里程碑 工作时长”，三个数字均为非负整数，以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如果整个项目的安排是合理可行的，在一行中输出最早完工时间；否则输出”Impossible”。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> <span class="number">12</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">9</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">7</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span> <span class="number">8</span> <span class="number">2</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    考的时候知道是拓扑排序，但是忘了，gg。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,res,mar[maxn][maxn],dis[maxn],in[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//入度为0的入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(in[i] == <span class="number">0</span>)  qu.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> t = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//看看一共有多少个点入过队</span></span><br><span class="line">        cnt++;</span><br><span class="line">        res = <span class="built_in">max</span>(res,dis[t]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">//删除边，更新距离</span></span><br><span class="line">            <span class="keyword">if</span>(mar[t][i] != INF)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--in[i] == <span class="number">0</span>)  qu.<span class="built_in">push</span>(i);</span><br><span class="line">                dis[i] = <span class="built_in">max</span>(dis[i],dis[t] + mar[t][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(mar,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mar));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        mar[u][v] = w;</span><br><span class="line">        <span class="comment">//记录入度</span></span><br><span class="line">        ++in[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="number">0</span>)  cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;一个项目由若干个任务组成，任务之间有先后依赖顺序。项目经理需要设置一系列里程碑，在每个里程碑节点处检查任务的完成情况，并启动后续的任务。现给定一个项目中各个任务之间的关系，请你计算出这个项目的最早完工时间。&lt;/p&gt;
&lt;h3 </summary>
      
    
    
    
    
    <category term="图论" scheme="http://wangxu1905.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="拓扑" scheme="http://wangxu1905.github.io/tags/%E6%8B%93%E6%89%91/"/>
    
    <category term="天梯赛" scheme="http://wangxu1905.github.io/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>C++ STL heap函数</title>
    <link href="http://wangxu1905.github.io/2022/03/23/C++%20STL%20heap%E5%87%BD%E6%95%B0/"/>
    <id>http://wangxu1905.github.io/2022/03/23/C++%20STL%20heap%E5%87%BD%E6%95%B0/</id>
    <published>2022-03-23T11:05:41.811Z</published>
    <updated>2022-03-23T11:40:04.087Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="一、C-关于heap的函数"><a href="#一、C-关于heap的函数" class="headerlink" title="一、C++ 关于heap的函数"></a>一、C++ 关于heap的函数</h3><ul><li>make_heap() 将区间内的元素转化为heap</li><li>push_heap() 对heap增加一个元素</li><li>pop_heap() 对heap弹出根元素</li><li>sort_heap() 进行堆排序</li><li>is_heap() 测试范围内的元素是否是一个二叉堆</li><li>is_heap_until 该函数返回有效二叉堆的最末范围。如果都有效，则返回heap.end()，也就是说返回第一个破坏二叉堆结构元素的迭代器。</li></ul><h3 id="二、函数参数"><a href="#二、函数参数" class="headerlink" title="二、函数参数"></a>二、函数参数</h3><h5 id="1-make-heap"><a href="#1-make-heap" class="headerlink" title="1.make_heap()"></a>1.make_heap()</h5><p>可用于把一个可迭代容器变成一个堆，默认是大顶堆。</p><p>make_heap(heap.begin(),heap.end(),less&lt;&gt;())</p><p>默认是less&lt;&gt;(),生成大顶堆，greater&lt;&gt;(),生成小顶堆</p><h5 id="2-pop-heap"><a href="#2-pop-heap" class="headerlink" title="2.pop_heap()"></a>2.pop_heap()</h5><p>用于将堆的根与最后一个元素交换，针对前n - 1个元素调用make_heap()函数，它也有三个参数，与make_heap()相同，第三个参数应与make_heap保持一致</p><p><strong>注意：</strong>pop_heap()函数，<strong>只是交换了两个数据的位置</strong>，如果要弹出这个元素，则要在<strong>后面</strong>加上heap.pop_back()</p><h5 id="3-push-heap"><a href="#3-push-heap" class="headerlink" title="3.push_heap()"></a>3.push_heap()</h5><p>用于把数据插入堆中，也是三个参数，与make_heap()相同，第三个参数应与make_heap保持一致</p><p><strong>注意：</strong> **在使用push_heap()前，请确保已经把数据通过heap.push_back()**传入heap中，而不是在push_heap()后再使用</p><h5 id="4-sort-heap"><a href="#4-sort-heap" class="headerlink" title="4.sort_heap()"></a>4.sort_heap()</h5><p>用于将堆进行排序，排序后，序列将失去堆的特性，它也具有三个参数，参数意义与make_heap()相同，第三个参数应与make_heap保持一致。大顶堆最后是递增，小顶堆递减。</p><p><strong>注意：</strong>使用这个函数前，<strong>确定序列符合堆的特性</strong>，否则会报错</p><h5 id="5-is-heap"><a href="#5-is-heap" class="headerlink" title="5.is_heap()"></a>5.is_heap()</h5><p>返回值为bool型，它也具有三个参数，参数意义与make_heap()相同,判断是否是大(小)根堆</p><h5 id="6-is-heap-until"><a href="#6-is-heap-until" class="headerlink" title="6.is_heap_until()"></a>6.is_heap_until()</h5><p>返回是迭代器，如果都有效，则返回heap.end()，也就是说返回第一个破坏二叉堆结构元素的迭代器。它也具有三个参数，参数意义与make_heap()相同,判断是否是大(小)根堆</p><h3 id="三、实例"><a href="#三、实例" class="headerlink" title="三、实例"></a>三、实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heap.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; heap[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">26</span>, <span class="number">25</span>, <span class="number">19</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">90</span>, <span class="number">3</span>, <span class="number">36</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>); ++i)</span><br><span class="line">        heap.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">    <span class="built_in">make_heap</span>(heap.<span class="built_in">begin</span>(), heap.<span class="built_in">end</span>(), less&lt;&gt;());</span><br><span class="line">    heap.<span class="built_in">push_back</span>(<span class="number">45</span>);</span><br><span class="line">    <span class="built_in">push_heap</span>(heap.<span class="built_in">begin</span>(), heap.<span class="built_in">end</span>(), less&lt;&gt;());</span><br><span class="line">    <span class="comment">/*pop_heap(heap.begin(),heap.end(),less&lt;&gt;());</span></span><br><span class="line"><span class="comment">       heap.pop_back();*/</span></span><br><span class="line">    <span class="comment">//sort_heap(heap.begin(), heap.end(), less&lt;&gt;());</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; is_heap(heap.begin(),heap.end(),greater&lt;&gt;()) &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_heap_until</span>(heap.<span class="built_in">begin</span>(),heap.<span class="built_in">end</span>(),less&lt;&gt;()) == heap.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;大根堆&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *is_heap_until(heap.begin(),heap.end(),less&lt;&gt;()) &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">Display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;一、C-关于heap的函数&quot;&gt;&lt;a href=&quot;#一、C-关于heap的函数&quot; class=&quot;headerlink&quot; title=&quot;一、C++ 关于heap的函数&quot;&gt;&lt;/a&gt;一、C++ 关于heap的函数&lt;/h3&gt;</summary>
      
    
    
    
    
    <category term="堆" scheme="http://wangxu1905.github.io/tags/%E5%A0%86/"/>
    
    <category term="C++" scheme="http://wangxu1905.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>7-21 三足鼎立 (25 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/23/7-21%20%E4%B8%89%E8%B6%B3%E9%BC%8E%E7%AB%8B%20(25%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/23/7-21%20%E4%B8%89%E8%B6%B3%E9%BC%8E%E7%AB%8B%20(25%20%E5%88%86)/</id>
    <published>2022-03-23T03:12:16.003Z</published>
    <updated>2022-03-23T03:46:24.241Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>当三个国家中的任何两国实力之和都大于第三国的时候，这三个国家互相结盟就呈“三足鼎立”之势，这种状态是最稳定的。</p><p>现已知本国的实力值，又给出 <em>n</em> 个其他国家的实力值。我们需要从这 <em>n</em> 个国家中找 2 个结盟，以成三足鼎立。有多少种选择呢？</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先在第一行给出 2 个正整数 <em>n</em>（2≤<em>n</em>≤105）和 <em>P</em>（≤109），分别为其他国家的个数、以及本国的实力值。随后一行给出 <em>n</em> 个正整数，表示<em>n</em> 个其他国家的实力值。每个数值不超过 109，数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出本国结盟选择的个数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">30</span></span><br><span class="line"><span class="number">42</span> <span class="number">16</span> <span class="number">2</span> <span class="number">51</span> <span class="number">92</span> <span class="number">27</span> <span class="number">35</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="样例解释："><a href="#样例解释：" class="headerlink" title="样例解释："></a>样例解释：</h3><p>能联合的另外 2 个国家的 9 种选择分别为：</p><p>{16, 27}, {16, 35}, {16, 42}, {27, 35}, {27, 42}, {27, 51}, {35, 42}, {35, 51}, {42, 51}。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    试过暴力，超时了。改用二分,先排序</p><p>​    其实就是三角形，两个短边之和要大于长边。记本国实力值为a,分成二种情况</p><p>​    因为遍历的时候，直接记ve[i]为b,所以a,b已知，求解c的范围</p><ul><li><p>a是长边，b + c &gt; a,即c &gt; a - b,b &lt; a,c &lt; a</p></li><li><p>a是短边，b或者c是长边(两者等价)，看我们把谁定义成b,c了</p><p>a + b &gt; c,c &gt; a,c &gt; b</p></li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n, a, res = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">ve</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; n; ++i)  cin &gt;&gt; ve[i];</span><br><span class="line">    <span class="built_in">sort</span>(ve.<span class="built_in">begin</span>(), ve.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//a是长边</span></span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ve[i] &gt; a)   <span class="keyword">break</span>;</span><br><span class="line">        ll b = ve[i];</span><br><span class="line">        <span class="comment">//找第一个符合的</span></span><br><span class="line">        <span class="keyword">auto</span> it1 = <span class="built_in">upper_bound</span>(ve.<span class="built_in">begin</span>() + i + <span class="number">1</span>, ve.<span class="built_in">end</span>(), a - b);</span><br><span class="line">        <span class="comment">//c也要大于a,为了防止b,c重复，则只能往b的后方找</span></span><br><span class="line">        <span class="keyword">auto</span> it2 = <span class="built_in">lower_bound</span>(ve.<span class="built_in">begin</span>() + i + <span class="number">1</span>, ve.<span class="built_in">end</span>(), a);</span><br><span class="line">        res += it2 - it1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//c是长边</span></span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ll b = ve[i];</span><br><span class="line">        <span class="comment">//找第一个不符合的</span></span><br><span class="line">        <span class="keyword">auto</span> it1 = <span class="built_in">lower_bound</span>(ve.<span class="built_in">begin</span>() + i + <span class="number">1</span>, ve.<span class="built_in">end</span>(), a + b);</span><br><span class="line">        <span class="comment">//找a,b中最大的，因为c &gt; a,c &gt; b</span></span><br><span class="line">        <span class="keyword">auto</span> it2 = <span class="built_in">lower_bound</span>(ve.<span class="built_in">begin</span>() + i + <span class="number">1</span>, ve.<span class="built_in">end</span>(), <span class="built_in">max</span>(a, b));</span><br><span class="line">        res += it1 - it2;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;当三个国家中的任何两国实力之和都大于第三国的时候，这三个国家互相结盟就呈“三足鼎立”之势，这种状态是最稳定的。&lt;/p&gt;
&lt;p&gt;现已知本国的实力值，又给出 &lt;em&gt;n&lt;/em&gt; 个其他国家的实力值。我们需要从这 &lt;em&gt;n&lt;/</summary>
      
    
    
    
    
    <category term="天梯赛" scheme="http://wangxu1905.github.io/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    
    <category term="二分" scheme="http://wangxu1905.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>7-20 最小生成树的唯一性 (35 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/23/7-20%20%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%20(35%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/23/7-20%20%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%20(35%20%E5%88%86)/</id>
    <published>2022-03-23T02:57:02.249Z</published>
    <updated>2022-03-23T03:01:20.086Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>7-20 最小生成树的唯一性 (35 分)</p><p>给定一个带权无向图，如果是连通图，则至少存在一棵最小生成树，有时最小生成树并不唯一。本题就要求你计算最小生成树的总权重，并且判断其是否唯一。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>首先第一行给出两个整数：无向图中顶点数 <em>N</em>（≤500）和边数 <em>M</em>。随后 <em>M</em> 行，每行给出一条边的两个端点和权重，格式为“顶点1 顶点2 权重”，其中顶点从 1 到<em>N</em> 编号，权重为正整数。题目保证最小生成树的总权重不会超过 230。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如果存在最小生成树，首先在第一行输出其总权重，第二行输出“Yes”，如果此树唯一，否则输出“No”。如果树不存在，则首先在第一行输出“No MST”，第二行输出图的连通集个数。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line">No</span><br></pre></td></tr></table></figure><h3 id="输入样例-3："><a href="#输入样例-3：" class="headerlink" title="输入样例 3："></a>输入样例 3：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-3："><a href="#输出样例-3：" class="headerlink" title="输出样例 3："></a>输出样例 3：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No MST</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    通过Kruskal进行求解，如果加入了a边，a的下一条边b，权重和a相同，并且b的端点和a的端点在两颗相同的树上，则最小生成树不具有唯一性</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125; e[<span class="number">5000050</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, f[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> edge &amp;a, <span class="keyword">const</span> edge &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] == <span class="number">-1</span>)  <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> f[x] = <span class="built_in">Find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="built_in">sort</span>(e, e + m, cmp);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> fa = <span class="built_in">Find</span>(e[i].u), fb = <span class="built_in">Find</span>(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(fa != fb) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>, fa1 = <span class="built_in">Find</span>(e[j].u), fb1 = <span class="built_in">Find</span>(e[j].v);</span><br><span class="line">            <span class="comment">//有两种情况</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; m &amp;&amp; e[j].w == e[i].w &amp;&amp; ((fa == fa1 &amp;&amp; fb == fb1) || (fa == fb1 &amp;&amp; fb == fa1)))</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">            res += e[i].w;</span><br><span class="line">            f[fb] = fa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(f[i] == <span class="number">-1</span>)  sum++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No MST&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;7-20 最小生成树的唯一性 (35 分)&lt;/p&gt;
&lt;p&gt;给定一个带权无向图，如果是连通图，则至少存在一棵最小生成树，有时最小生成树并不唯一。本题就要求你计算最小生成树的总权重，并且判断其是否唯一。&lt;/p&gt;
&lt;h3 id=&quot;</summary>
      
    
    
    
    
    <category term="图论" scheme="http://wangxu1905.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="天梯赛" scheme="http://wangxu1905.github.io/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    
    <category term="最小生成树" scheme="http://wangxu1905.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
    <category term="Kruskal" scheme="http://wangxu1905.github.io/tags/Kruskal/"/>
    
  </entry>
  
  <entry>
    <title>7-17 堆的建立 (20 分)</title>
    <link href="http://wangxu1905.github.io/2022/03/23/7-17%20%E5%A0%86%E7%9A%84%E5%BB%BA%E7%AB%8B%20(20%20%E5%88%86)/"/>
    <id>http://wangxu1905.github.io/2022/03/23/7-17%20%E5%A0%86%E7%9A%84%E5%BB%BA%E7%AB%8B%20(20%20%E5%88%86)/</id>
    <published>2022-03-23T02:33:36.770Z</published>
    <updated>2022-03-23T02:55:27.159Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>所谓“堆的建立”，是指将已经存在的N个元素调整成最大堆或最小堆。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>第一行是一个整数N，表示元素的个数，N&lt;=10000。第二行N个元素的值。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出2行，第一行是输入序列调整为最大堆后的元素序列，元素之间用空格分开。第二行是输入序列调整为最小堆后的元素序列，元素之间用空格分开。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>在这里给出一组输入。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span> <span class="number">5</span> <span class="number">8</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><p>在这里给出相应的输出。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">5</span> <span class="number">7</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">7</span> <span class="number">8</span> <span class="number">6</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​        和之前的堆建立不同，这个是全部存储后再调整（堆排序的调整方法）。</p><p>​    </p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, heap1[<span class="number">100001</span>], heap2[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    heap1[<span class="number">0</span>] = INT_MAX;</span><br><span class="line">    heap2[<span class="number">0</span>] = INT_MIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从第一个非叶结点开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> child;</span><br><span class="line">        <span class="comment">//向下调整，保证父亲的子树是堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> parent = i; parent &lt;= n / <span class="number">2</span>; parent = child) &#123;</span><br><span class="line">            child = parent * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(child + <span class="number">1</span> &lt;= n &amp;&amp; heap1[child] &lt; heap1[child + <span class="number">1</span>])   child += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(heap1[child] &gt; heap1[parent])</span><br><span class="line">                <span class="built_in">swap</span>(heap1[child],heap1[parent]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> child;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> parent = i; parent &lt;= n / <span class="number">2</span>; parent = child) &#123;</span><br><span class="line">            child = parent * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(child + <span class="number">1</span> &lt;= n &amp;&amp; heap2[child] &gt; heap2[child + <span class="number">1</span>])   child += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(heap2[child] &lt; heap2[parent])</span><br><span class="line">                <span class="built_in">swap</span>(heap2[child],heap2[parent]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">1</span>)   cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; heap1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">1</span>)   cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; heap2[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        heap1[i] = t;</span><br><span class="line">        heap2[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//附上一种偷懒写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ve;</span><br><span class="line">    <span class="keyword">int</span> n, t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        ve.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ve1, ve2;</span><br><span class="line">    ve1 = ve, ve2 = ve;</span><br><span class="line">    <span class="built_in">make_heap</span>(ve1.<span class="built_in">begin</span>(), ve1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">make_heap</span>(ve2.<span class="built_in">begin</span>(), ve2.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve1.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i)   cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; ve1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve2.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i)   cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; ve2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;所谓“堆的建立”，是指将已经存在的N个元素调整成最大堆或最小堆。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式:&quot;&gt;&lt;/a&gt;输入格式:&lt;/h</summary>
      
    
    
    
    
    <category term="天梯赛" scheme="http://wangxu1905.github.io/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"/>
    
    <category term="堆" scheme="http://wangxu1905.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>Kruskal算法</title>
    <link href="http://wangxu1905.github.io/2022/03/21/Floyed%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84/"/>
    <id>http://wangxu1905.github.io/2022/03/21/Floyed%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84/</id>
    <published>2022-03-21T12:26:17.704Z</published>
    <updated>2022-03-21T12:28:01.432Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n, m, s, mar[<span class="number">501</span>][<span class="number">501</span>], dis[<span class="number">501</span>][<span class="number">501</span>], path[<span class="number">501</span>][<span class="number">501</span>];</span><br><span class="line"><span class="comment">//只打印中继结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = path[s][d];</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">PrintPath</span>(s, k);</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintPath</span>(k, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="comment">//path[i][j]的值为i，j的中继节点</span></span><br><span class="line">                <span class="keyword">if</span>(dis[i][j] &gt; dis[i][k] + dis[k][j]) &#123;</span><br><span class="line">                    dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">                    path[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//另外打印起点和终点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1 &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintPath</span>(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(mar, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mar));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(path, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(path));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        mar[i][i] = dis[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        mar[a][b] = mar[b][a] = c;</span><br><span class="line">        dis[a][b] = dis[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Floyd</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6 8</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment">1 3 3</span></span><br><span class="line"><span class="comment">2 3 1</span></span><br><span class="line"><span class="comment">3 5 4</span></span><br><span class="line"><span class="comment">3 4 2</span></span><br><span class="line"><span class="comment">4 5 4</span></span><br><span class="line"><span class="comment">1 6 0</span></span><br><span class="line"><span class="comment">2 6 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    
    <category term="图论" scheme="http://wangxu1905.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路" scheme="http://wangxu1905.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
</feed>
